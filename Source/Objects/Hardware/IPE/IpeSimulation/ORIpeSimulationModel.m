//--------------------------------------------------------
// ORIpeSimulationModel
// Created by Mark  A. Howe on Mon Apr 11 2005
// Code partially generated by the OrcaCodeWizard. Written by Mark A. Howe.
// Copyright (c) 2005 CENPA, University of Washington. All rights reserved.
//-----------------------------------------------------------
//This program was prepared for the Regents of the University of 
//Washington at the Center for Experimental Nuclear Physics and 
//Astrophysics (CENPA) sponsored in part by the United States 
//Department of Energy (DOE) under Grant #DE-FG02-97ER41020. 
//The University has certain rights in the program pursuant to 
//the contract and the program should not be copied or distributed 
//outside your organization.  The DOE and the University of 
//Washington reserve all rights in the program. Neither the authors,
//University of Washington, or U.S. Government make any warranty, 
//express or implied, or assume any liability or responsibility 
//for the use of this software.
//-------------------------------------------------------------

#pragma mark ***Imported Files

#import "ORIpeSimulationModel.h"
#import "ORDataTaker.h"
#import "ORDataTypeAssigner.h"
#import "ORAdeiLoader.h"

#pragma mark ‚Ä¢‚Ä¢‚Ä¢Notification Strings
NSString* ORIpeSimulationModelFieldlineImageFileNameChanged = @"ORIpeSimulationModelFieldlineImageFileNameChanged";
NSString* ORIpeSimulationModelFieldlineImageChanged = @"ORIpeSimulationModelFieldlineImageChanged";
NSString* ORIpeSimulationModelExecutableIsRunningChanged = @"ORIpeSimulationModelExecutableIsRunningChanged";
NSString* ORIpeSimulationModelExecutableFileNameChanged = @"ORIpeSimulationModelExecutableFileNameChanged";
NSString* ORIpeSimulationModelConfigFileNameChanged = @"ORIpeSimulationModelConfigFileNameChanged";
NSString* ORIpeSimulationModelShowDebugOutputChanged = @"ORIpeSimulationModelShowDebugOutputChanged";
NSString* ORIpeSimulationModelShipRecordsChanged	= @"ORIpeSimulationModelShipRecordsChanged";
NSString* ORIpeSimulationModelTotalRequestCountChanged = @"ORIpeSimulationModelTotalRequestCountChanged";
NSString* ORIpeSimulationModelTimeOutCountChanged	= @"ORIpeSimulationModelTimeOutCountChanged";
NSString* ORIpeSimulationModelFastGenSetupChanged	= @"ORIpeSimulationModelFastGenSetupChanged";
NSString* ORIpeSimulationModelSetPointChanged		= @"ORIpeSimulationModelSetPointChanged";
NSString* ORIpeSimulationModelItemTypeChanged		= @"ORIpeSimulationModelItemTypeChanged";
NSString* ORIpeSimulationModelViewItemNameChanged	= @"ORIpeSimulationModelViewItemNameChanged";
NSString* ORIpeSimulationLock                      = @"ORIpeSimulationLock";
NSString* ORIpeSimulationSelectedSensorNumChanged  = @"ORIpeSimulationSelectedSensorNumChanged";
NSString* ORIpeSimulationItemListChanged			= @"ORIpeSimulationItemListChanged";
NSString* ORIpeSimulationAdeiBaseUrlForSensorChanged = @"ORIpeSimulationAdeiBaseUrlForSensorChanged";
NSString* ORIpeSimulationPollTimeChanged			= @"ORIpeSimulationPollTimeChanged";
NSString* ORIpeSimulationLastRequestChanged		= @"ORIpeSimulationLastRequestChanged";
NSString* ORIpeSimulationIPNumberChanged			= @"ORIpeSimulationIPNumberChanged";
NSString* ORIpeSimulationItemTreeChanged					= @"ORIpeSimulationItemTreeChanged";
NSString* ORIpeSimulationModelHistogramChanged		= @"ORIpeSimulationModelHistogramChanged";
NSString* ORIpeSimulationPendingRequestsChanged	= @"ORIpeSimulationPendingRequestsChanged";

//Removed connector MAH May 18,2010
//NSString* ORADEIInConnection						= @"ORADEIInConnection";

#define IPE_SIMULATION_SHORT_NAME @"IPE-SIM"

@interface ORIpeSimulationModel (private)
- (NSMutableArray*) insertNode:(id)aNode intoArray:(NSMutableArray*)anArray path:(NSString*)aPath nodeName:(NSString*)nodeName isLeaf:(BOOL)isLeaf;
- (void) itemTreeResults:(id)result path:(NSString*)aPath;
- (void) polledItemResult:(id)result path:(NSString*)aPath;
- (void) clearPendingRequest:(NSString*)anItemKey;
- (void) setPendingRequest:(NSString*)anItemKey;
- (void) checkForTimeOuts;
- (void) shipTheRecords;
- (NSTimeInterval) timeFromADEIDate:(NSString*)aDate;
- (void) addItemKeyToPollingLookup:(NSString*) anItemKey;
- (void) removeItemKeyFromPollingLookup:(NSString*) anItemKey;
@end

@implementation ORIpeSimulationModel
- (id) init
{
	self = [super init];
	[self initBasics];
	return self;
}

- (id) initBasics
{
    //FZK-internal: [self setAdeiServiceUrl: @"http://ipepdvadei.ka.fzk.de/adei/services/"];//TODO: make attribute -tb-
    [self setIPNumber: @"fuzzy.fzk.de/adei"];
    [self setConfigFileName: @"fieldline_config1.txt"];
    [self setExecutableFileName:@""];
	return self;
}

- (void) dealloc
{
    [fieldlineImageFileName release];
    [executableFileName release];
    [configFileName release];
	[NSObject cancelPreviousPerformRequestsWithTarget:self];
	[connectionHistory release];
	[itemTreeRoot release];
	[requestCache release];
	[super dealloc];
}

- (void) awakeAfterDocumentLoaded
{
	//----------------------------------------------------------------
	//Removed connector MAH May 18,2010
	//this bit of code is for backward compatibility
	ORConnector* aConnector = [self connectorOn:@"ORADEIInConnection"];
	[aConnector disconnect];
	[connectors release];
	connectors = nil;
	//----------------------------------------------------------------
}

- (void) setUpImage
{
	[self setImage:[NSImage imageNamed:@"IpeSimulation"]];
}

- (void) makeMainController
{
	[self linkToController:@"ORIpeSimulationController"];
}


//Removed connector MAH May 18,2010
/*-(void) makeConnectors
{
	//we  have three permanent connectors. The rest we manage for the pci objects.
    ORConnector* aConnector = [[ORConnector alloc] initAt:NSMakePoint(0, 0) withGuardian:self withObjectLink:self];
    [[self connectors] setObject:aConnector forKey:ORADEIInConnection];
    [aConnector setOffColor:[NSColor magentaColor]];
    [aConnector setOffColor:[NSColor brownColor]];
	[aConnector setConnectorType: 'ADEI'];
	[aConnector addRestrictedConnectionType: 'ADEO']; //can only connect to DB Inputs
    [aConnector release];
}
*/

- (void) initConnectionHistory
{
	ipNumberIndex = [[NSUserDefaults standardUserDefaults] integerForKey: [NSString stringWithFormat:@"orca.%@.IPNumberIndex",[self className]]];
	if(!connectionHistory){
		NSArray* his = [[NSUserDefaults standardUserDefaults] objectForKey: [NSString stringWithFormat:@"orca.%@.ConnectionHistory",[self className]]];
		connectionHistory = [his mutableCopy];
	}
	if(!connectionHistory)connectionHistory = [[NSMutableArray alloc] init];
}

- (void) clearHistory
{
	[connectionHistory release];
	connectionHistory = nil;
	
	[self setIPNumber:IPNumber];
}


#pragma mark ***Accessors

- (NSString*) fieldlineImageFileName
{
    return fieldlineImageFileName;
}

- (void) setFieldlineImageFileName:(NSString*)aFieldlineImageFileName
{
    [fieldlineImageFileName autorelease];
    fieldlineImageFileName = [aFieldlineImageFileName copy];    

    [[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSimulationModelFieldlineImageFileNameChanged object:self];
}


- (BOOL) executableIsRunning
{
    return executableIsRunning;
}

- (void) setExecutableIsRunning:(BOOL)aExecutableIsRunning
{
    executableIsRunning = aExecutableIsRunning;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSimulationModelExecutableIsRunningChanged object:self];
}


- (NSString*) executableFileName
{
    return executableFileName;
}

- (void) setExecutableFileName:(NSString*)aExecutableFileName
{
    [[[self undoManager] prepareWithInvocationTarget:self] setExecutableFileName:executableFileName];
    
    [executableFileName autorelease];
    executableFileName = [aExecutableFileName copy];    

    [[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSimulationModelExecutableFileNameChanged object:self];
}

- (NSString*) configFileName
{
    return configFileName;
}

- (void) setConfigFileName:(NSString*)aConfigFileName
{
    [[[self undoManager] prepareWithInvocationTarget:self] setConfigFileName:configFileName];
    
    [configFileName autorelease];
    configFileName = [aConfigFileName copy];    

    [[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSimulationModelConfigFileNameChanged object:self];
}

- (BOOL) showDebugOutput
{
    return showDebugOutput;
}

- (void) setShowDebugOutput:(BOOL)aShowDebugOutput
{
    [[[self undoManager] prepareWithInvocationTarget:self] setShowDebugOutput:showDebugOutput];
    showDebugOutput = aShowDebugOutput;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSimulationModelShowDebugOutputChanged object:self];
}

- (BOOL) shipRecords
{
    return shipRecords;
}

- (void) setShipRecords:(BOOL)aShipRecords
{
    [[[self undoManager] prepareWithInvocationTarget:self] setShipRecords:shipRecords];
    shipRecords = aShipRecords;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSimulationModelShipRecordsChanged object:self];
}

- (int) totalRequestCount
{
    return totalRequestCount;
}

- (void) setTotalRequestCount:(int)aTotalRequestCount
{
    totalRequestCount = aTotalRequestCount;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSimulationModelTotalRequestCountChanged object:self];
}

- (int) timeOutCount
{
    return timeOutCount;
}

- (void) setTimeOutCount:(int)aTimeOutCount
{
    timeOutCount = aTimeOutCount;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSimulationModelTimeOutCountChanged object:self];
}

- (BOOL) fastGenSetup
{
    return fastGenSetup;
}

- (void) setFastGenSetup:(BOOL)aFastGenSetup
{
    [[[self undoManager] prepareWithInvocationTarget:self] setFastGenSetup:fastGenSetup];
    fastGenSetup = aFastGenSetup;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSimulationModelFastGenSetupChanged object:self];
}

- (double) setPoint
{
    return setPoint;
}

- (void) setSetPoint:(double)aSetPoint
{
    [[[self undoManager] prepareWithInvocationTarget:self] setSetPoint:setPoint];
    setPoint = aSetPoint;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSimulationModelSetPointChanged object:self];
}

- (int) itemType
{
    return itemType;
}

- (void) setItemType:(int)aItemType
{
    [[[self undoManager] prepareWithInvocationTarget:self] setItemType:itemType];
    itemType = aItemType;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSimulationModelItemTypeChanged object:self];
}

- (BOOL) viewItemName
{
    return viewItemName;
}

- (void) setViewItemName:(BOOL)aViewItemName
{
    [[[self undoManager] prepareWithInvocationTarget:self] setViewItemName:viewItemName];
    viewItemName = aViewItemName;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSimulationModelViewItemNameChanged object:self];
}

- (NSUInteger) connectionHistoryCount
{
	return [connectionHistory count];
}

- (id) connectionHistoryItem:(NSUInteger)index
{
	if(connectionHistory && index<[connectionHistory count])return [connectionHistory objectAtIndex:index];
	else return nil;
}

- (NSUInteger) ipNumberIndex
{
	return ipNumberIndex;
}

- (NSString*) IPNumber
{
	if(!IPNumber)return @"";
    return IPNumber;
}

- (void) setIPNumber:(NSString*)aIPNumber
{
	if(!aIPNumber) aIPNumber = @"http://ipepdvadei.ka.fzk.de/adei";
	[[[self undoManager] prepareWithInvocationTarget:self] setIPNumber:IPNumber];
	
	[IPNumber autorelease];
	IPNumber = [aIPNumber copy];    
	
	//load into the connection history for the comboxbox popup
	if(!connectionHistory)connectionHistory = [[NSMutableArray alloc] init];
	if(![connectionHistory containsObject:IPNumber]){
		[connectionHistory addObject:IPNumber];
	}
	ipNumberIndex = [connectionHistory indexOfObject:aIPNumber];
	
	[[NSUserDefaults standardUserDefaults] setObject:connectionHistory forKey:[NSString stringWithFormat:@"orca.%@.ConnectionHistory",[self className]]];
	[[NSUserDefaults standardUserDefaults] setInteger:ipNumberIndex forKey:[NSString stringWithFormat:@"orca.%@.IPNumberIndex",[self className]]];
	[[NSUserDefaults standardUserDefaults] synchronize];
	
	[[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSimulationIPNumberChanged object:self];
}

- (NSString*) ipNumberToURL
{
	//convert a host name xxx.xxx.xxx to a url of form http://xxxx.xxx.xxx
	NSMutableString* goodUrl = [NSMutableString stringWithString: [self IPNumber]];
	if([goodUrl length]){
		if(![goodUrl hasPrefix:   @"http://"]) [goodUrl insertString: @"http://"  atIndex: 0];
		if(![goodUrl hasSuffix:   @"/"]) [goodUrl appendString: @"/"];
	}
	return goodUrl;
}

- (NSString*) lastRequest
{
	if(!lastRequest)return @"";
	return lastRequest;
}

- (void) setLastRequest:(NSString*)aString
{
	if([aString length]==0)aString = @"";
	[aString autorelease];
	lastRequest = [aString copy];
	[[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSimulationLastRequestChanged object:self];
}

- (int) pollTime
{
    return pollTime;
}

- (void) setPollTime:(int)aPollTime
{
    [[[self undoManager] prepareWithInvocationTarget:self] setPollTime:pollTime];
    pollTime = aPollTime;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSimulationPollTimeChanged object:self];
	
	if(pollTime)[self performSelector:@selector(pollSlowControls) withObject:nil afterDelay:2];
	else		[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(pollSlowControls) object:nil];
}

- (void) setDataIds:(id)assigner
{
    channelDataId = [assigner assignDataIds:kLongForm];
}

- (void) syncDataIdsWith:(id)anotherObject
{
    [self setChannelDataId:     [anotherObject channelDataId]];
}

- (uint32_t) channelDataId
{
    return channelDataId;
}

- (void) setChannelDataId:(uint32_t) aValue
{
    channelDataId = aValue;
}

- (void) dumpSensorlist
{
	NSLog(@"requestCache:\n%@\n",requestCache);
}


#pragma mark ‚Ä¢‚Ä¢‚Ä¢*** Simulation Task Handler
- (void) startStopExecutable
{
	if(executableIsRunning){
		[self setExecutableIsRunning: FALSE];
	}else{
		[self startExecutable];
		[self setExecutableIsRunning: TRUE];
	}
}

- (void) startExecutable
{
	NSLog(@"Called %@::%@\n",NSStringFromClass([self class]),NSStringFromSelector(_cmd));//TODO: DEBUG -tb-



	//this is according to the XCode Help "Interacting with the Operating System" 2010-08 -tb-
    NSTask *aTask = [[NSTask alloc] init];
	
	//register for 'task ended' notification
    [[NSNotificationCenter defaultCenter] addObserver:self
            selector:@selector(checkATaskStatus:)
            name:NSTaskDidTerminateNotification
            object:aTask];
			
	//create task and launch it
    NSMutableArray *args = [NSMutableArray array];
 
    /* set arguments */
    //[args addObject:[[inputFile stringValue] lastPathComponent]];
    [args addObject:configFileName];
	NSLog(@"Args: %@ \n",args);
    [aTask setCurrentDirectoryPath:[executableFileName stringByDeletingLastPathComponent]];
	NSLog(@"setCurrentDirectoryPath: %@, \n",[executableFileName stringByDeletingLastPathComponent]);
    //[aTask setLaunchPath:[NSString stringWithFormat: @"%@%@", @"./", [executableFileName lastPathComponent]]];
	//NSLog(@"setLaunchPath: %@, \n",[executableFileName lastPathComponent]);
    [aTask setLaunchPath:executableFileName];
	NSLog(@"setLaunchPath: %@, \n",[aTask launchPath] );
    [aTask setArguments:args];
	NSLog(@"Going to launch task executable: \n");
    [aTask launch];
	sleep(5);
    //[aTask interrupt];
	NSLog(@"Tast e. interrupt \n");
	NSLog(@"task isRunning is: %i, \n",[aTask isRunning]);
	[aTask release]; //fix leak -- MAH 11/05/11
	NSLog(@"Tast e. released \n");
}
	
- (void) startPlotter
{
	NSLog(@"Called %@::%@\n",NSStringFromClass([self class]),NSStringFromSelector(_cmd));//TODO: DEBUG -tb-



	//this is according to the XCode Help "Interacting with the Operating System" 2010-08 -tb-
    NSTask *aTask = [[NSTask alloc] init];
	
	//register for 'task ended' notification
    [[NSNotificationCenter defaultCenter] addObserver:self
            selector:@selector(checkATaskStatus:)
            name:NSTaskDidTerminateNotification
            object:aTask];
			
	//create task and launch it
    NSMutableArray *args = [NSMutableArray array];
 
    /* set arguments */
    //[args addObject:[[inputFile stringValue] lastPathComponent]];
    //[args addObject:configFileName];
    [args addObject:@"ORCA"];
    [args addObject:configFileName];
    [args addObject:@"-b"];
	NSLog(@"Args: %@ \n",args);
    [aTask setCurrentDirectoryPath:[executableFileName stringByDeletingLastPathComponent]];
	NSLog(@"setCurrentDirectoryPath: %@, \n",[executableFileName stringByDeletingLastPathComponent]);
	NSLog(@"setCurrentDirectoryPath: %@, \n",[aTask currentDirectoryPath]);
    //[aTask setLaunchPath:[executableFileName lastPathComponent]];
	NSLog(@"setLaunchPath: %@, \n",[[executableFileName stringByDeletingLastPathComponent] stringByAppendingPathComponent:@"FieldlinePlotter"]);
    [aTask setLaunchPath:[[executableFileName stringByDeletingLastPathComponent] stringByAppendingPathComponent:@"FieldlinePlotter"]];
    [aTask setArguments:args];
    [aTask launch];
	NSLog(@"task isRunning is: %i, \n",[aTask isRunning]);
	[aTask release]; //fix leak -- MAH 11/05/11
}
	
- (void) reloadFieldlineImage
{
	NSString *theImagePath;
	theImagePath = [executableFileName stringByDeletingLastPathComponent] ;
	NSLog(@"theImagePath is: %@ \n",theImagePath);
	theImagePath = [theImagePath  stringByAppendingPathComponent:@"../Data/fieldlines.root_PreSpec.gif"];
	NSLog(@"theImagePath is: %@ \n",theImagePath);
	theImagePath = [theImagePath  stringByStandardizingPath];
	NSLog(@"theImagePath (standardized) is: %@ \n",theImagePath);
	[self setFieldlineImageFileName: theImagePath];
    [[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSimulationModelFieldlineImageChanged object:self];
}

- (void)checkATaskStatus:(NSNotification *)aNotification {
	NSLog(@"Called %@::%@\n",NSStringFromClass([self class]),NSStringFromSelector(_cmd));//TODO: DEBUG -tb-
    int status = [[aNotification object] terminationStatus];
    if (status == 0)
        NSLog(@"Task succeeded. (status %i)",status);
    else if (status == 23){
        NSLog(@"Task succeeded: Fieldline (status %i)",status);
		[self startPlotter]; return;//dont clear the notification registration, below
    }else if (status == 24){
        NSLog(@"Task succeeded: FieldlinePlotter (status %i)",status);
		[self reloadFieldlineImage];
    }else
        NSLog(@"Task failed. (status %i)",status);
	//remove the notification request ...	
	[[NSNotificationCenter defaultCenter] removeObserver:self];		

	//handle the GUI
	if(executableIsRunning){
		[self setExecutableIsRunning: FALSE];
	}
}



#pragma mark ***Polled Item via LookupTable index
- (BOOL) itemExists:(int)anIndex
{
	return anIndex<[pollingLookUp count];
}

- (BOOL) isControlItem:(int)anIndex
{
	//anIndex is NOT the channel Number
	if(anIndex<[pollingLookUp count]){
		NSString* itemKey = [pollingLookUp objectAtIndex:anIndex];
		NSDictionary* topLevelDictionary = [requestCache objectForKey:itemKey];
		NSDictionary* itemDictionary = [topLevelDictionary objectForKey:itemKey];
		return [itemDictionary objectForKey:@"Control"]!=nil;
	}
	else return NO;
}

- (BOOL) isControlItemWithItemKey:(NSString*)itemKey
{
		NSDictionary* topLevelDictionary = [requestCache objectForKey:itemKey];
		NSDictionary* itemDictionary = [topLevelDictionary objectForKey:itemKey];
		return [itemDictionary objectForKey:@"Control"]!=nil;
}

- (NSString*) requestCacheItemKey:(int)anIndex
{
	//Note: index is NOT channel, it is the index of the item in the details panel
	//use the lookup table to return the polingCache's topLevelDictionary
	//to have fast access by index to the requestCache, there is a lookupTable Array of the 
	//form: itemKey0,itemKey1,itemKey2....
	if(anIndex<[pollingLookUp count]){
		return [pollingLookUp objectAtIndex:anIndex];
	}
	else return nil;
}

- (NSDictionary*) requestCacheItem:(int)anIndex
{
	//Note: index is NOT channel, it is the index of the item in the details panel
	//use the lookup table to return the polingCache's topLevelDictionary
	//to have fast access by index to the requestCache, there is a lookupTable Array of the 
	//form: itemKey0,itemKey1,itemKey2....
	if(anIndex<[pollingLookUp count]){
		NSString* itemKey = [pollingLookUp objectAtIndex:anIndex];
		NSDictionary* topLevelDictionary = [requestCache objectForKey:itemKey];
		return [topLevelDictionary objectForKey:itemKey];
	}
	else return nil;
}

- (NSUInteger) pollingLookUpCount
{
	return [pollingLookUp count];
}

- (NSString*) createWebRequestForItem:(int)anIndex
{
	//anIndex is NOT the channel number
	//examples for a single sensor request:
	//fuzzy.fzk.de/adei/#db_server=katrin&db_name=hauptspektrometer&db_group=0&db_mask=1&experiment=0-0&window=0&history_id=1232130010554
	//fuzzy.fzk.de/adei/#db_server=katrin&db_name=hauptspektrometer&db_group=0&db_mask=1&experiment=0-0&window=0
	//fuzzy.fzk.de/adei/#minimal=graph&db_server=katrin&db_name=hauptspektrometer&db_group=0&db_mask=1&window=0
	NSString* requestString = nil;
	if(anIndex<[pollingLookUp count]){
		NSString* itemKey	= [pollingLookUp objectAtIndex:anIndex];
		NSDictionary* topLevelDictionary = [requestCache objectForKey:itemKey];
		NSDictionary* itemDictionary	 = [topLevelDictionary objectForKey:itemKey];
		NSString* url		= [itemDictionary objectForKey:@"URL"];
		NSString* path		= [itemDictionary objectForKey:@"Path"];
		requestString = [ORAdeiLoader webRequestStringUrl:url itemPath:path];
		[self setTotalRequestCount:totalRequestCount+1];
	}
	return requestString;
}


#pragma mark ‚Ä¢‚Ä¢‚Ä¢Polled item access via itemKey
- (NSMutableDictionary*) topLevelPollingDictionary:(id)anItemKey
{
	return [requestCache objectForKey:anItemKey];
}

#pragma mark ‚Ä¢‚Ä¢‚Ä¢Channel Loop Up Methods
- (void) makeChannelLookup
{
	[channelLookup release];
	channelLookup = [[NSMutableDictionary dictionary] retain];
	for(id itemKey in pollingLookUp){ //TODO: we need to see the channels used by scripts ... -tb-
		NSDictionary* topLevelDictionary = [requestCache objectForKey:itemKey];
		id channelNumber = [topLevelDictionary objectForKey:@"ChannelNumber"];
		if(channelNumber){
			[channelLookup setObject:itemKey forKey:channelNumber];
		}
	}
}

- (BOOL) channelExists:(int)aChan
{
	NSString* itemKey = [channelLookup objectForKey:[NSNumber numberWithInt:aChan]];
    return (itemKey!=nil);
}


- (int) nextUnusedChannelNumber
{
	int proposedIndex = 0;
	do {
		BOOL alreadyUsed = NO;
		for(id itemKey in pollingLookUp){
			NSDictionary* topLevelDictionary = [requestCache objectForKey:itemKey];
			int aChannelNumber = [[topLevelDictionary objectForKey:@"ChannelNumber"] intValue];
			if(aChannelNumber == proposedIndex){
				alreadyUsed = YES;
				proposedIndex++;
				break; //no need to continue this loop
			}
		}
		if(!alreadyUsed)break;
	} while(1);
	return proposedIndex;
}
- (int) channelNumberForItemKey:(NSString*) anItemKey;
{
        NSMutableDictionary* topLevelDictionary = [requestCache objectForKey: anItemKey];
        int chan=-1;
        id chanNumObj = [topLevelDictionary objectForKey:@"ChannelNumber"];
        if(chanNumObj) chan = [chanNumObj intValue];
		return chan;
        //TODO:  or better search itemKey in channelLookup -> ensure that this is always up to date -tb-
}

//!We return the channel which was set; if the channel already exists, a negative number is returned
- (int) setChannelNumber:(int) aChan forItemKey:(NSString*) anItemKey 
{
    NSMutableDictionary* topLevelDictionary = [requestCache objectForKey: anItemKey];
    if(!topLevelDictionary) return -2;
    int oldChan = [self channelNumberForItemKey: anItemKey];
    if(oldChan == aChan) return aChan; //nothing to do
    [[[self undoManager] prepareWithInvocationTarget:self] setChannelNumber:oldChan forItemKey:anItemKey];
    [topLevelDictionary setObject:[NSNumber numberWithInt:aChan]	forKey:@"ChannelNumber"]; //channel number for access by the processing system
    
    //fill it into the channelLookup
    if(channelLookup){
        [channelLookup removeObjectForKey: [NSNumber numberWithInt: oldChan]];
        [channelLookup setObject:anItemKey  forKey: [NSNumber numberWithInt: aChan]];
    }
    
#if 0  // must be done somewhere else (addItemKeyToPollingLookup, removeItemKeyFromPollingLookup)-tb-
    //pollingLookup
    NSLog( @"setChannelNumber: pollingLookup: key %@, oldch  %i  new ch %i",anItemKey,oldChan,aChan);
    if(oldChan<0 && aChan>=0){
     [pollingLookUp addObject:anItemKey];//[self addItemKeyToPollingLookup:anItemKey];  //adding new item to polling lookup
    }
    if(oldChan>=0 && aChan<0) [pollingLookUp removeObject:anItemKey];// [self removeItemKeyFromPollingLookup:anItemKey];  //adding new item to polling lookup
#endif
    //NSLog( @"setChannelNumber: itemkey:%@, old chan %i, new chan %i\n",anItemKey,oldChan,aChan);

    [[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSimulationItemListChanged object:self];
    return aChan;
}

#pragma mark ‚Ä¢‚Ä¢‚Ä¢Polling Cache Management
//addItems to the polling loop
- (void) addItems:(NSArray*)anItemArray
{
	if(!requestCache)   requestCache = [[NSMutableDictionary dictionary] retain];
	if(!pollingLookUp)  pollingLookUp = [[NSMutableArray array] retain];
	for(id anItem in anItemArray){
		NSString* itemKey = [self itemKey:[anItem objectForKey:@"URL"] path:[anItem objectForKey:@"Path"]];
		
		if(![pollingLookUp containsObject:itemKey]){
			//we have never seen this item before, so add it alone with some extra info for the processing system
			//item not in the list yet... add it
			int aChannelNumber = [self nextUnusedChannelNumber]; //find an unused channel number in the polling List
			NSMutableDictionary* topLevelDictionary = [self makeTopLevelDictionary];
			[topLevelDictionary setObject:anItem forKey:itemKey];			
			[topLevelDictionary setObject:[NSNumber numberWithInt:aChannelNumber]	forKey:@"ChannelNumber"]; //channel number for access by the processing system
			//or [self setChannelNumber:aChannelNumber  forItemKey:itemKey]; // with undo ...
            
			[requestCache setObject:topLevelDictionary forKey:itemKey];
			[self addItemKeyToPollingLookup:itemKey];
		}
	}
}

- (void) removeSet:(NSIndexSet*)aSetToRemove
{
	NSMutableArray* itemsToRemove = [NSMutableArray array];
	NSUInteger current_index = [aSetToRemove firstIndex];
    while (current_index != NSNotFound) {
		if(current_index<[pollingLookUp count]){
			NSString* itemKey = [self requestCacheItemKey:(int)current_index];
			[itemsToRemove addObject:itemKey];
		}
		current_index = [aSetToRemove indexGreaterThanIndex: current_index];
    }
	for(id aKey in itemsToRemove){
		[self removeItemKeyFromPollingLookup:aKey];
	}
}


- (NSMutableDictionary*) makeTopLevelDictionary
{
	NSMutableDictionary* topLevelDictionary = [NSMutableDictionary dictionary];
	[topLevelDictionary setObject:[NSNumber numberWithInt:0]		forKey:@"LoAlarm"]; //used by processing
	[topLevelDictionary setObject:[NSNumber numberWithInt:100]		forKey:@"HiAlarm"]; //used by processing
	[topLevelDictionary setObject:[NSNumber numberWithInt:0]		forKey:@"LoLimit"]; //used by processing
	[topLevelDictionary setObject:[NSNumber numberWithInt:100]		forKey:@"HiLimit"]; //used by processing
	[topLevelDictionary setObject:[NSNumber numberWithInt:-1]		forKey:@"ChannelNumber"];   //used for initializing
	[topLevelDictionary setObject:@"--"		forKey:@"DBValue"];     //used for initializing
	[topLevelDictionary setObject:@"--"     forKey:@"DBTimestamp"]; //used for initializing
	return topLevelDictionary;
}


#pragma mark ‚Ä¢‚Ä¢‚Ä¢Item Tree Management
- (void) setItemTreeRoot:(NSMutableArray*)anArray
{
	[anArray retain];
	[itemTreeRoot release];
	itemTreeRoot = anArray;
	[[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSimulationItemTreeChanged object:self];
}

- (NSArray*) itemTreeRoot
{
	return itemTreeRoot;
}

- (void) loadItemTree
{
	[itemTreeRoot release];
	itemTreeRoot = nil;
	[[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSimulationItemTreeChanged object:self];
	ORAdeiLoader* aLoader = [ORAdeiLoader loaderWithAdeiHost:[self ipNumberToURL] adeiType:itemType delegate:self didFinishSelector:@selector(itemTreeResults:path:)];
    [aLoader setShowDebugOutput: showDebugOutput];//TODO: timeout debugging -tb-
	[aLoader loadPath:@"/" recursive:YES];
}

- (NSString*) itemDetails:(int)anIndex
{
	//anIndex in NOT channel number
	if(anIndex<[pollingLookUp count]){
		NSString* itemKey = [pollingLookUp objectAtIndex:anIndex];
		id topLevelDictionary = [requestCache objectForKey:itemKey];
		NSString* s = [topLevelDictionary description];
		s = [s stringByReplacingOccurrencesOfString:@"{" withString:@""];
		s = [s stringByReplacingOccurrencesOfString:@"}" withString:@""];
		s = [s stringByReplacingOccurrencesOfString:@"\t" withString:@""];
		s = [s stringByReplacingOccurrencesOfString:@";" withString:@""];
		return s;
	}
	else return @"<Error: index out of bounds>";
}

- (NSString*) itemKey:aUrl path:aPath
{
    if(aUrl==nil || aPath==nil) return nil;
	if([aPath hasPrefix:@"/"])return [NSString stringWithFormat:@"%@%@",aUrl,aPath];
	else return [NSString stringWithFormat:@"%@/%@",aUrl,aPath];
}

#pragma mark ‚Ä¢‚Ä¢‚Ä¢Archival
- (id) initWithCoder:(NSCoder*)decoder
{
	self = [super initWithCoder:decoder];

	[[self undoManager] disableUndoRegistration];
	
 	[self initConnectionHistory];
   
    [self initBasics];
	[self setFieldlineImageFileName:[decoder decodeObjectForKey:@"fieldlineImageFileName"]];
	if(fieldlineImageFileName == nil) {[self setFieldlineImageFileName: @""];}
	[self setExecutableFileName:[decoder decodeObjectForKey:@"executableFileName"]];
	if(executableFileName == nil) {[self setExecutableFileName: @"-"];}
	[self setConfigFileName:	[decoder decodeObjectForKey:  @"configFileName"]];
	if(configFileName == nil) {[self setConfigFileName: @"fieldline_config.txt"];NSLog( @"Use default filename: %@\n",configFileName);}

	[self setShowDebugOutput:	[decoder decodeBoolForKey:    @"showDebugOutput"]];
	[self setShipRecords:		[decoder decodeBoolForKey:	  @"shipRecords"]];
	[self setFastGenSetup:		[decoder decodeBoolForKey:	  @"fastGen"]];
	[self setSetPoint:			[decoder decodeDoubleForKey:  @"setPoint"]];
	[self setItemType:			[decoder decodeIntForKey:	  @"itemType"]];
	[self setViewItemName:		[decoder decodeBoolForKey:	  @"viewItemName"]];
	[self setPollTime:			[decoder decodeIntForKey:	  @"pollTime"]];
	[self setIPNumber:			[decoder decodeObjectForKey:  @"IPNumber"]];
	[self setItemTreeRoot:		[decoder decodeObjectForKey:  @"itemTreeRoot"]];
	
	requestCache =				[[decoder decodeObjectForKey: @"requestCache"]retain];
	pollingLookUp =				[[decoder decodeObjectForKey: @"pollingLookUp"]retain];
	[self makeChannelLookup];

	[[self undoManager] enableUndoRegistration];
     
	
	return self;
}

- (void) encodeWithCoder:(NSCoder*)encoder
{
    [super encodeWithCoder:encoder];    
	[encoder encodeObject:fieldlineImageFileName forKey:@"fieldlineImageFileName"];
	[encoder encodeObject:executableFileName forKey:@"executableFileName"];
	[encoder encodeObject:configFileName    forKey:@"configFileName"];
	[encoder encodeBool:showDebugOutput		forKey:@"showDebugOutput"];
	[encoder encodeBool:shipRecords			forKey:@"shipRecords"];
	[encoder encodeBool:fastGenSetup		forKey:@"fastGen"];
	[encoder encodeDouble:setPoint			forKey:@"setPoint"];
	[encoder encodeInteger:itemType				forKey:@"itemType"];
	[encoder encodeBool:viewItemName		forKey:@"viewItemName"];
	[encoder encodeInteger:pollTime				forKey:@"pollTime"];
 	[encoder encodeObject:IPNumber			forKey:@"IPNumber"];
 	[encoder encodeObject:itemTreeRoot		forKey:@"itemTreeRoot"];
 	[encoder encodeObject:pollingLookUp		forKey:@"pollingLookUp"];
	//only store the part of the requestCache that is polled
	NSMutableDictionary* itemsToStore = [NSMutableDictionary dictionary];
	for(id itemKey in pollingLookUp){
		NSDictionary* topLevelDictionary = [requestCache objectForKey:itemKey];
		[itemsToStore setObject:topLevelDictionary forKey:itemKey];
	}
 	[encoder encodeObject:itemsToStore		forKey:@"requestCache"];
	
}

- (NSDictionary*) dataRecordDescription
{
    NSMutableDictionary* dataDictionary = [NSMutableDictionary dictionary];
    NSDictionary* aDictionary = [NSDictionary dictionaryWithObjectsAndKeys:
								 @"ORIpeSimulationDecoderForChannelData",  @"decoder",
								 [NSNumber numberWithLong:channelDataId],   @"dataId",
								 [NSNumber numberWithBool:YES],       @"variable",
								 [NSNumber numberWithLong:-1],        @"length",
								 nil];
    [dataDictionary setObject:aDictionary forKey:@"ChannelData"];
    return dataDictionary;
}

//put out parameters into the header. Called automagically.
- (NSMutableDictionary*) addParametersToDictionary:(NSMutableDictionary*)dictionary
{    
    NSMutableDictionary* objDictionary = [super addParametersToDictionary:dictionary];
	NSMutableDictionary* itemsToPutInHeader = [NSMutableDictionary dictionary];
	for(id itemKey in pollingLookUp){
		NSDictionary* topLevelDictionary = [requestCache objectForKey:itemKey];
		[itemsToPutInHeader setObject:topLevelDictionary forKey:itemKey];
	}
    [objDictionary setObject:itemsToPutInHeader forKey:@"WatchedItems"];    	
    return objDictionary;
}

- (void) appendDataDescription:(ORDataPacket*)aDataPacket userInfo:(NSDictionary*)userInfo
{
    [aDataPacket addDataDescriptionItem:[self dataRecordDescription] forKey:@"IP320"];
}

#pragma mark ‚Ä¢‚Ä¢‚Ä¢Adc or Bit Processing Protocol
/** This is called once per "processing" cycle and is called at the begin of the process cycle.
  * The process control calls (also in test mode): processIsStarting, multiple times (startProcessCycle, endProcessCycle) , processIsStopping
  * The ORAdcModel calls (not in test mode!):  
  @verbatim
  normal cycle is:
    maxValueForChan:
    minValueForChan:
    getAlarmRangeLow:high:channel:
    convertedValue:    
  @endverbatim
  
  * <br>
  * The protocol ORAdcProcessing is in: ORAdcProcessing.h
  * The protocol ORBitProcessing is in: ORBitProcessing.h
  */
//note that everything called by these routines MUST be threadsafe
- (void) processIsStarting
{
	//called when processing is started. nothing to do for now. 
	//called at the HW polling rate in the process dialog. 
	//For now we just use the local polling
}

- (void)processIsStopping
{
	//called when processing is stopping. nothing to do for now.
}

- (void) startProcessCycle
{
	//called at the HW polling rate in the process dialog. 
	//ignore for now.
}

- (void) endProcessCycle
{
}

- (NSString*) processingTitle
{
    return [NSString stringWithFormat: @"%@-%u",IPE_SIMULATION_SHORT_NAME,[self uniqueIdNumber]];
}


- (void) setProcessOutput:(int)channel value:(int)value
{
    //nothing to do
}

/** Note: Adc  Processing supports 30 channels; shipping SC packs channel number into 16 bit (0x00-0xff or 0 ... 255).
  * But there is no limit to the channel number (except it must be a int).
  *
  */ //-tb-
- (BOOL) processValue:(int)channel
{
	return [self convertedValue:channel]!=0;
}

//!convertedValue: and valueForChan: are the same.
- (double) convertedValue:(int)channel
{    
    return [self valueForChan:channel];
}

- (double) maxValueForChan:(int)channel
{
	NSString* itemKey = [channelLookup objectForKey:[NSNumber numberWithInt:channel]];
	if(itemKey){
		NSDictionary* topLevelDictionary = [requestCache objectForKey: itemKey];
		return [[topLevelDictionary objectForKey:@"HiLimit"] doubleValue];
	}
	return 0; // return something if channel number out of range
}

- (double) lowAlarm:(int)channel
{    
	NSString* itemKey = [channelLookup objectForKey:[NSNumber numberWithInt:channel]];
	if(itemKey){
		NSDictionary* topLevelDictionary = [requestCache objectForKey: itemKey];
		return [[topLevelDictionary objectForKey:@"LoAlarm"] doubleValue];
	}
	return 0; // return something if channel number out of range
}

- (double) highAlarm:(int)channel
{
	NSString* itemKey = [channelLookup objectForKey:[NSNumber numberWithInt:channel]];
	if(itemKey){
		NSDictionary* topLevelDictionary = [requestCache objectForKey: itemKey];
		return [[topLevelDictionary objectForKey:@"HiAlarm"] doubleValue];
	}
	return 0; // return something if channel number out of range
}

- (double) minValueForChan:(int)channel
{
	NSString* itemKey = [channelLookup objectForKey:[NSNumber numberWithInt:channel]];
	if(itemKey){
		NSDictionary* topLevelDictionary = [requestCache objectForKey: itemKey];
		return [[topLevelDictionary objectForKey:@"LoLimit"] doubleValue];
	}
	return 0; // return something if channel number out of range
}

//alarm limits for the processing framework.
- (void) getAlarmRangeLow:(double*)theLowLimit high:(double*)theHighLimit  channel:(int)channel
{	
	NSString* itemKey = [channelLookup objectForKey:[NSNumber numberWithInt:channel]];
	if(itemKey){
		NSDictionary* topLevelDictionary = [requestCache objectForKey: itemKey];
		*theLowLimit  =  [[topLevelDictionary objectForKey:@"LoAlarm"]doubleValue] ;
		*theHighLimit  =  [[topLevelDictionary objectForKey:@"HiAlarm"]doubleValue] ;
	}
}

#pragma mark ‚Ä¢‚Ä¢‚Ä¢polling
- (void) pollSlowControls
{
	///
	//TODO
	//-----collect requests for groups into one request. The response code should handle the result...
	//TODO
	//
	NSArray* setupOptions = nil;
	if(fastGenSetup){
		setupOptions = [NSArray arrayWithObjects:@"fastgen",nil];
	}
	[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(pollSlowControls) object:nil];
	for(id anItemKey in pollingLookUp){
		if([self requestIsPending:anItemKey]){//request is still pending
            NSLog( @"You posted a request for a still pending request: %@\n",anItemKey);
            continue;
        }
		id topLevelDictionary = [requestCache objectForKey:anItemKey];
		id anItem = [topLevelDictionary objectForKey:anItemKey];
		int aType = [[anItem objectForKey:@"Control"] intValue];
		ORAdeiLoader* aLoader = [ORAdeiLoader loaderWithAdeiHost:[anItem objectForKey:@"URL"] adeiType:aType delegate:self didFinishSelector:@selector(polledItemResult:path:) setupOptions:setupOptions];
        [aLoader setShowDebugOutput: showDebugOutput];//TODO: timeout debugging -tb-
		[aLoader requestItem:[anItem objectForKey:@"Path"]];
        [self setPendingRequest:anItemKey];
		[self setTotalRequestCount:totalRequestCount+1];

	}		
	
	if(pollTime)[self performSelector:@selector(pollSlowControls) withObject:nil afterDelay:pollTime];
	
	if(shipRecords) [self shipTheRecords];
}

#pragma mark ‚Ä¢‚Ä¢‚Ä¢ID Helpers (see OrcaObject)
- (NSString*) identifier
{
    return [NSString stringWithFormat: @"%@-%u",IPE_SIMULATION_SHORT_NAME,[self uniqueIdNumber]];
}

#pragma mark ‚Ä¢‚Ä¢‚Ä¢Methods Useful For Scripting
//-------------should use only these methods in scripts---------------------------------
- (void) postSensorRequest:(NSString*)aUrl path:(NSString*)aPath
{
//NSLog( @"postSensorRequest: \n");//TODO: debug1
    NSString* anItemKey = [self itemKey:aUrl path:aPath];
//NSLog( @"postSensorRequest: item: %@\n",anItemKey);//TODO: debug1
		if([self requestIsPending:anItemKey]){//request is still pending
            NSLog( @"You posted a request for a still pending item: %@\n",anItemKey);
            //TODO: XXX return;
        }
	ORAdeiLoader* aLoader;
	aLoader = [ORAdeiLoader loaderWithAdeiHost:aUrl adeiType:kSensorType delegate:self didFinishSelector:@selector(polledItemResult:path:)];
    [aLoader setShowDebugOutput: showDebugOutput];//TODO: timeout debugging -tb-
	[aLoader requestItem:aPath];
	[self setPendingRequest:anItemKey];
	[self setTotalRequestCount:totalRequestCount+1];
}

- (void) postControlRequest:(NSString*)aUrl path:(NSString*)aPath
{
//NSLog( @"postControlRequest: \n");//TODO: debug1
    NSString* anItemKey = [self itemKey:aUrl path:aPath];
		if([self requestIsPending:anItemKey]){//request is still pending
            NSLog( @"You posted a request for a still pending item: %@\n",anItemKey);
            //TODO: XXX return;
        }
	ORAdeiLoader* aLoader;
	aLoader = [ORAdeiLoader loaderWithAdeiHost:aUrl adeiType:kControlType delegate:self didFinishSelector:@selector(polledItemResult:path:)];
    [aLoader setShowDebugOutput: showDebugOutput];//TODO: timeout debugging -tb-
	[aLoader requestItem:aPath];
	[self setPendingRequest:anItemKey];
	[self setTotalRequestCount:totalRequestCount+1];
}

- (void) postControlSetpoint:(NSString*)aUrl path:(NSString*)aPath value:(double)aValue
{
	
#if 0
    NSString* anItemKey = [self itemKey:aUrl :aPath];
		if([self requestIsPending:anItemKey]){//request is still pending
            NSLog( @"You posted a request for a still pending item: %@\n",anItemKey);
            //TODO: XXX return;
        }
    ORAdeiLoader* aLoader = [ORAdeiLoader loaderWithAdeiHost:aUrl adeiType:kControlType delegate:self didFinishSelector:@selector(polledItemResult:path:)];
    [aLoader setShowDebugOutput: showDebugOutput];//TODO: timeout debugging -tb-
    [aLoader writeControl:aPath value:aValue];
	[self setPendingRequest:anItemKey];
    [self setTotalRequestCount:totalRequestCount+1];
	
#endif
}


- (int) findChanOfSensor:(NSString*)aUrl path:(NSString*)aPath
{
    int channelNumber=-1;
    NSString* itemKey = [self itemKey:aUrl path:aPath];
	NSDictionary* topLevelDictionary	= [requestCache objectForKey:itemKey];
	NSDictionary* itemDictionary		= [topLevelDictionary objectForKey:itemKey];
	if([itemDictionary objectForKey:@"Control"]) NSLog(@"%@: no Sensor channel found, is a Control channel!\n",NSStringFromClass([self class]));//-tb- warning output  //is a Control, not a Sensor
    else channelNumber = [[topLevelDictionary objectForKey:@"ChannelNumber"] intValue];
    return channelNumber;
}

- (int) findChanOfControl:(NSString*)aUrl path:(NSString*)aPath
{
    int channelNumber=-1;
    NSString* itemKey = [self itemKey:aUrl path:aPath];
	NSDictionary* topLevelDictionary	= [requestCache objectForKey:itemKey];
	NSDictionary* itemDictionary		= [topLevelDictionary objectForKey:itemKey];
	if([itemDictionary objectForKey:@"Control"]) channelNumber = [[topLevelDictionary objectForKey:@"ChannelNumber"] intValue];
    else NSLog(@"%@: no Control channel found, is a non-Control channel!\n",NSStringFromClass([self class]));//-tb- warning output //is a Sensor, not a Control
    return channelNumber;
}

- (int) findChanOfIndex:(int)anIndex
{
    //anIndex is the index/row in the itemListView ...
    int channelNumber=-1;
	if(anIndex<[pollingLookUp count]){
		NSString* itemKey = [pollingLookUp objectAtIndex:anIndex];
        NSDictionary* topLevelDictionary	= [requestCache objectForKey:itemKey];
        channelNumber = [[topLevelDictionary objectForKey:@"ChannelNumber"] intValue];
    }
    return channelNumber;
}


- (void) postRequestForChan:(int)aChan
{
    NSString* itemKey = [channelLookup objectForKey:[NSNumber numberWithInt:aChan]];
    if(itemKey){
		if([self requestIsPending:itemKey]){//request is still pending
            NSLog( @"You posted a request for a still pending item: %@\n",itemKey);
            //TODO: XXX return;//TODO: allow it anyway? -tb-
        }
		id topLevelDictionary = [requestCache objectForKey:itemKey];
		id anItem = [topLevelDictionary objectForKey:itemKey];
        NSString* aUrl  = [anItem objectForKey:@"URL"];
        NSString* aPath = [anItem objectForKey:@"Path"];
        int aType = kSensorType;
		if([anItem objectForKey:@"Control"]){
            aType = kControlType;
		}
        // post request
        ORAdeiLoader* aLoader;
        aLoader = [ORAdeiLoader loaderWithAdeiHost:aUrl adeiType:aType delegate:self didFinishSelector:@selector(polledItemResult:path:)];
        [aLoader setShowDebugOutput: showDebugOutput];//TODO: timeout debugging -tb-
        [aLoader requestItem:aPath];
        [self setPendingRequest:itemKey];
        [self setTotalRequestCount:totalRequestCount+1];
        //
    }else{
        NSLog(@"%@::%@: you tried to use a undefined channel!\n",NSStringFromClass([self class]),NSStringFromSelector(_cmd));
        return;
    }
}

- (void) postControlSetpointForChan:(int)aChan value:(double)aValue
{
    NSString* itemKey = [channelLookup objectForKey:[NSNumber numberWithInt:aChan]];
    if(itemKey){
		id topLevelDictionary = [requestCache objectForKey:itemKey];
		id anItem = [topLevelDictionary objectForKey:itemKey];
		if([anItem objectForKey:@"Control"]){
			NSString* aUrl  = [anItem objectForKey:@"URL"];
			NSString* aPath = [anItem objectForKey:@"Path"];
			[self postControlSetpoint:aUrl path:aPath value:aValue ];
		}else{
            NSLog(@"%@: you tried to write to a non-Control channel!\n",NSStringFromClass([self class]));//-tb- warning output
            return;
        }
    }else{
        NSLog(@"%@: you tried to use a undefined channel!\n",NSStringFromClass([self class]));
        return;
    }
}

- (BOOL) requestIsPendingForChan:(int)aChan
{
    NSString* itemKey = [channelLookup objectForKey:[NSNumber numberWithInt:aChan]];
    if(itemKey){
		id topLevelDictionary = [requestCache objectForKey:itemKey];
		id anItem = [topLevelDictionary objectForKey:itemKey];
        NSString* aUrl  = [anItem objectForKey:@"URL"];
        NSString* aPath = [anItem objectForKey:@"Path"];
        return [pendingRequests objectForKey:[self itemKey:aUrl path:aPath]] != nil;
    }else{
        //NSLog(@"%@: you tried to use a undefined channel!\n",NSStringFromClass([self class]));
        return false;
    }
}


//TODO: control items are badly initialized under certain circumstances!! -tb-
//TODO: after dragging a control into the list its "value" displays the ADEI item number, not the control value!! -tb-
//TODO: better use new entries in the toplevel dictionary (?)
- (double) valueForChan:(int)aChan
{
    NSString* itemKey = [channelLookup objectForKey:[NSNumber numberWithInt:aChan]];
    return [self valueForItemKey: itemKey];
}

- (double) valueForItemKey:(NSString*)itemKey
{
	if(itemKey){
        //scan the new items "DBValue", "DBTimestamp"-tb-
        #if 1
		NSDictionary* topLevelDictionary = [requestCache objectForKey: itemKey];
        return [[topLevelDictionary objectForKey:@"DBValue"] doubleValue];
        #else
		NSDictionary* topLevelDictionary = [requestCache objectForKey: itemKey];
		NSDictionary* itemDictionary = [topLevelDictionary objectForKey:itemKey];
		if([itemDictionary objectForKey:@"Control"]) return [[itemDictionary objectForKey:@"value"] doubleValue];
		else										 return [[itemDictionary objectForKey:@"Value"] doubleValue];
        #endif
	}
	return 0; // return something if channel number out of range
}


- (BOOL) requestIsPending:(NSString*)aUrl path:(NSString*)aPath
{
	return [pendingRequests objectForKey:[self itemKey:aUrl path:aPath]] != nil;
}

- (BOOL) requestIsPending:(NSString*)itemKey
{
	return [pendingRequests objectForKey:itemKey] != nil;
}

//if the item is part of the itemArray
- (void) writeSetPoint:(int)anIndex value:(double)aValue
{
	//index is NOT channel
	if(anIndex<[pollingLookUp count]){
        #if 0
        NSLog(@"pollingLookUp:\n %@\n",pollingLookUp);
        NSLog(@"channelLookup:\n %@\n",channelLookup);
        NSLog(@"requestCache:\n %@\n",requestCache);
        NSLog(@"itemTreeRoot:\n %@\n",itemTreeRoot);
        #endif
		NSString* itemKey = [pollingLookUp objectAtIndex:anIndex];
		id topLevelDictionary = [requestCache objectForKey:itemKey];
		id anItem = [topLevelDictionary objectForKey:itemKey];
		if([anItem objectForKey:@"Control"]){
			NSString* aUrl  = [anItem objectForKey:@"URL"];
			NSString* aPath = [anItem objectForKey:@"Path"];
            #if 1
            [self postControlSetpoint:aUrl path:aPath value:aValue];
            #else
            //TODO: remove from source file -tb-
			ORAdeiLoader* aLoader = [ORAdeiLoader loaderWithAdeiHost:aUrl adeiType:kControlType delegate:self didFinishSelector:nil];
			[aLoader writeControl:aPath value:aValue];
			[self setTotalRequestCount:totalRequestCount+1];
            #endif
		}
	}
}

- (double) valueForUrl:(NSString*)aUrl path:(NSString*)aPath
{
	NSString* itemKey = [self itemKey:aUrl path:aPath];
    return [self valueForItemKey: itemKey];
}
//-------------end of script methods---------------------------------

- (void) histogram:(int)milliSecs
{
	int i = milliSecs;
	if(i>=kResponseTimeHistogramSize)i=kResponseTimeHistogramSize-1;
	histogram[i]++;
	[[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSimulationModelHistogramChanged object:self];
}

- (int32_t) dataTimeHist:(int)index
{
	if(index<kResponseTimeHistogramSize)return histogram[index];
	else return 0;
}

- (NSUInteger) pendingRequestsCount
{
	return [[pendingRequests allKeys] count];
}

- (id) pendingRequest:(id)aKey forIndex:(int)anIndex
{
	if(anIndex < [[pendingRequests allKeys] count]){
		id aKey =  [[pendingRequests allKeys] objectAtIndex:anIndex];
		return aKey;
	}
	else return nil;
}

@end

@implementation ORIpeSimulationModel (private)

- (NSMutableArray*) insertNode:(id)aNode intoArray:(NSMutableArray*)anArray path:(NSString*)aPath nodeName:(NSString*)nodeName isLeaf:(BOOL)isLeaf
{
	for(id aDictionary in anArray){
		NSString* thisNodesName = [aDictionary objectForKey:@"Name"];
		if(!thisNodesName)thisNodesName = [aDictionary objectForKey:@"name"];
		if([thisNodesName isEqualToString:nodeName]){
			//OK the node is already there.
			if(isLeaf){
				//It's a leaf. Replace the existing entry with the new info
				[aDictionary setObject:aNode forKey:@"Children"];
				return nil;
			}
			else return [aDictionary objectForKey:@"Children"];
		}
	}
	
	if(isLeaf){
		for(id item in aNode){
			[item setObject:[self ipNumberToURL] forKey:@"URL"];
			NSString* leafNodePath = [aPath stringByAppendingPathComponent:[item objectForKey:@"value"]];
			[item setObject:leafNodePath forKey:@"Path"];
		}
		NSMutableDictionary* aDictionary = [NSMutableDictionary dictionaryWithObjectsAndKeys:
											nodeName,@"Name",
											[self ipNumberToURL],@"URL",
											aPath,@"Path",
											aNode,@"Children",
											nil];
		[anArray addObject:aDictionary];
		return anArray;
	}
	else {
		//if we get here, there was no entry yet. make one.
		NSMutableArray* newArray = [NSMutableArray array];
		NSMutableDictionary* aDictionary = [NSMutableDictionary dictionaryWithObjectsAndKeys:
											nodeName,@"Name",
											aPath,@"Path",
											[self ipNumberToURL],@"URL",
											newArray,@"Children",
											nil];
		[anArray addObject:aDictionary];
		return newArray;
	}
}

- (void) itemTreeResults:(id)result path:(NSString*)aPath
{	
	[self setLastRequest:aPath];
	NSMutableArray* pathComponents;
	if([aPath isEqual:@"/"] || ([aPath length]==0)){
		//this was the root -- we ignore this and start with the servers
		return;
	}
	else pathComponents = [[aPath componentsSeparatedByString:@"/"] mutableCopy];
	
	if(!itemTreeRoot)itemTreeRoot = [[NSMutableArray array] retain];
	
	// paths are of the form "/server/database/group/item". Always the fourth level is the leaf node
	int level = 0;
	NSMutableArray* aNodeArray = itemTreeRoot;
	for(id nodeName in pathComponents){
        #pragma unused(nodeName)
		aNodeArray = [self insertNode:result
							intoArray:aNodeArray 
								 path: aPath
							 nodeName:[pathComponents objectAtIndex:level] 
							   isLeaf:level==2];
		if(!aNodeArray)break;
		level++;
	}
	[pathComponents release];
	[[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSimulationItemTreeChanged object:self];
}

- (void) polledItemResult:(id)result path:(NSString*)aPath
{
	//got back some results from pollSlowControls. Store it in the requestCache.
	//requestCache form:
	// Array of Dictionaries of the form:
	// itemKey -> topLevelDictionary whose form is:
	//		itemKey -> thePolledItem from database (another Dictionary) 
	//		"LoAlarm" -> loAlarm Value
	//		"HiAlarm" -> hiAlarm Value
	// ...
	// ...
	//
    //NSLog(@"polledItemResult: ... result is %@ \n",result);
	for(id resultItem in result){
        int chan=-1;
		NSString* itemKey = [self itemKey:[resultItem objectForKey:@"URL"] path:[resultItem objectForKey:@"Path"]];
        if(!itemKey) continue; //avoid (null) item key; this may happen if there was a alarm message in the received xml structure (contains no path/url) -tb-
        //should work without: if(!requestCache)   requestCache = [[NSMutableDictionary dictionary] retain];
		id topLevelDictionary = [requestCache objectForKey:itemKey];
		if(!topLevelDictionary){
			//wasn't in the topLevel so we haven't seen this item before. Add it to the cache.
            //REUSE "addItems:"
            //NSArray* anItemArray = [NSArray arrayWithObject: [NSDictionary dictionaryWithObjectsAndKeys:
            //    [resultItem objectForKey:@"URL"],@"URL", [resultItem objectForKey:@"Path"],@"Path",nil         ] ];
            NSArray* anItemArray = [NSArray arrayWithObject: resultItem ];
            [self addItems: anItemArray];
            topLevelDictionary = [requestCache objectForKey:itemKey];
            #if 0
			topLevelDictionary = [self makeTopLevelDictionary];
			[requestCache setObject:topLevelDictionary forKey:itemKey];
            //TODO: insert it into the pollingLookUp and channelLookup (using the first free chan - if no chan numbers available? NSLog ...) -tb-
            chan = [self nextUnusedChannelNumber];
            [self setChannelNumber:chan forItemKey:itemKey];
            //adding to polling and channel cache was missing ...
            #endif
		}
        
        //maybe the item is in the requestCache but not in pollingLookup
        chan = [self channelNumberForItemKey:itemKey];
        if(chan<0){
            [self setChannelNumber:[self nextUnusedChannelNumber] forItemKey:itemKey];
            [self addItemKeyToPollingLookup: itemKey];
        }
        
		//we only replace the resultItem. leaving the other things in the dictionary (i.e. loAlarm, etc...) alone.
		[topLevelDictionary setObject:resultItem forKey:itemKey];
        if([self isControlItemWithItemKey:itemKey]){
            [topLevelDictionary setObject:[resultItem objectForKey:@"value"] forKey:@"DBValue"];
            [topLevelDictionary setObject:[resultItem objectForKey:@"timestamp"] forKey:@"DBTimestamp"];
        }
		else{
            [topLevelDictionary setObject:[resultItem objectForKey:@"Value"] forKey:@"DBValue"];
            [topLevelDictionary setObject:[resultItem objectForKey:@"Date"] forKey:@"DBTimestamp"];//TODO: use Unix time -tb- ? !!!!!!!!!!!!!
            //TODO: use Unix time -tb- ? !!!!!!!!!!!!!
            //TODO: use Unix time -tb- ? !!!!!!!!!!!!!
        }
        
        //housekeeping
		[self clearPendingRequest:itemKey];
	}
    [[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSimulationItemListChanged object:self];
}

- (void) clearPendingRequest:(NSString*) anItemKey
{
	NSTimeInterval t = [NSDate timeIntervalSinceReferenceDate];
	int deltaTime = (t - [[pendingRequests objectForKey:anItemKey] doubleValue])*1000;
	[self histogram:deltaTime];
	[pendingRequests removeObjectForKey:anItemKey];
    [[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSimulationPendingRequestsChanged object:self];
	if([pendingRequests count]==0){
		[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(checkForTimeOuts) object:nil];
		checkingForTimeouts = NO;
	}
}

- (void) setPendingRequest:(NSString*)anItemKey
{
	if(!pendingRequests)pendingRequests = [[NSMutableDictionary dictionary] retain];
	[pendingRequests setObject:[NSNumber numberWithDouble:[NSDate timeIntervalSinceReferenceDate]] forKey:anItemKey];
    [[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSimulationPendingRequestsChanged object:self];
	if(!checkingForTimeouts){
		[self performSelector:@selector(checkForTimeOuts) withObject:nil afterDelay:10]; //delay should be parameter
		checkingForTimeouts = YES;
	}
}


- (void) checkForTimeOuts
{
    int timeoutTime = 15;
	[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(checkForTimeOuts) object:nil];
	NSTimeInterval theCurrentTime = [NSDate timeIntervalSinceReferenceDate];
	if([pendingRequests count] == 0) return; 
	NSArray* theKeys = [pendingRequests allKeys];
	for(id anItemKey in theKeys){
		//it's a dictionary with one key -- the itemKey that holds the time the request was posted
		NSTimeInterval timePosted = [[pendingRequests objectForKey:anItemKey] doubleValue];
		if(theCurrentTime - timePosted > timeoutTime){
			NSLog(@"timeout on %@ (currentTime %f, timePosted %f)\n", anItemKey ,theCurrentTime ,timePosted);
			[self setTimeOutCount:[self timeOutCount]+1];
			[self clearPendingRequest:anItemKey];
		}
	}
	[self performSelector:@selector(checkForTimeOuts) withObject:nil afterDelay:10]; //delay should be parameter

}

- (void) shipTheRecords
{
	union {
		float asFloat;
		uint32_t asLong;
	}dataUnion;
	
	if([pollingLookUp count]){
		if([[ORGlobal sharedGlobal] runInProgress]){
			NSMutableData* theData = [NSMutableData dataWithCapacity:256]; //not a hard limit, just a hint to the data obj
			for(id anItemKey in pollingLookUp){
				NSDictionary* topLevelDictionary	= [requestCache objectForKey:anItemKey];
				NSDictionary* itemDictionary		= [topLevelDictionary objectForKey:anItemKey];
				float theValue;
                #if 0
				if([itemDictionary objectForKey:@"Control"]) theValue =  [[itemDictionary objectForKey:@"value"] floatValue];
				else										 theValue =  [[itemDictionary objectForKey:@"Value"] floatValue];
                #else
                theValue = [self valueForItemKey: anItemKey];
                #endif
				int channelNumber = [[topLevelDictionary objectForKey:@"ChannelNumber"] intValue];
                if(channelNumber ==-1) channelNumber = 0xff;//removed channels have channelNumber -1
                
				NSTimeInterval theTimeStamp =  [self timeFromADEIDate:[itemDictionary objectForKey:@"Date"]];//TODO: controls have no "Date" -tb-
				uint32_t seconds	 = (uint32_t)theTimeStamp;	  //seconds since 1970
				uint32_t subseconds = (theTimeStamp - seconds)*1000; //milliseconds
				
				uint32_t data[7];
				data[0] = channelDataId | 7;
				data[1] = (([self uniqueIdNumber]&0xf) << 21) | (channelNumber&0xff);
							
				dataUnion.asFloat = theValue;
				data[2] = dataUnion.asLong;
				data[3] = seconds; 
				data[4] = subseconds;
				data[5] = 0; //spare
				data[6] = 0; //spare
				
				[theData appendBytes:data length:7*sizeof(uint32_t)];
			}
			[[NSNotificationCenter defaultCenter] postNotificationName:ORQueueRecordForShippingNotification object:theData];
		}
	}
} 

- (NSTimeInterval) timeFromADEIDate:(NSString*)aDate
{
	NSDate *theDate = [NSDate dateFromString:aDate calendarFormat:@"%d-%b-%y %H:%M:%S.%F"];
	return [theDate timeIntervalSince1970];
}

//TODO: is this only for undo? who sets channel number? it is called only from addItems: and polledItemResult: -tb-
- (void) addItemKeyToPollingLookup:(NSString *)anItemKey
{
    [[[self undoManager] prepareWithInvocationTarget:self] removeItemKeyFromPollingLookup:anItemKey];
	[pollingLookUp addObject:anItemKey];
    //TODO: restore the old channel ...
	[self makeChannelLookup];
	[[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSimulationItemListChanged object:self];
}

//! Remove it from pollingLookup (and channelLookup) but keep it in requestCache ...
- (void) removeItemKeyFromPollingLookup:(NSString *)anItemKey
{
    [[[self undoManager] prepareWithInvocationTarget:self] addItemKeyToPollingLookup:anItemKey];
    int aChan = [self channelNumberForItemKey: anItemKey];
    [[[self undoManager] prepareWithInvocationTarget:self] setChannelNumber:aChan forItemKey:anItemKey];
    //TODO: set ChannelNumber to -1 and do a undo for it ... -tb-
        NSMutableDictionary* topLevelDictionary = [requestCache objectForKey: anItemKey];
        [topLevelDictionary setObject:[NSNumber numberWithInt:-1]	forKey:@"ChannelNumber"]; //channel number for access by the processing system
//TODO: [self setChannelNumber:-1 forItemKey:  anItemKey];     
	[pollingLookUp removeObject:anItemKey];
	[self makeChannelLookup];
	[[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSimulationItemListChanged object:self];
}


@end
