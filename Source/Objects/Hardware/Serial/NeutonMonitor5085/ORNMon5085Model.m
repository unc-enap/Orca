//--------------------------------------------------------
// ORNMon5085Model
// Created by Mark  A. Howe on Fri Oct 4, 2014
// Code partially generated by the OrcaCodeWizard. Written by Mark A. Howe.
// Copyright (c) 2013 University of North Carolina. All rights reserved.
//-----------------------------------------------------------
//This program was prepared for the Regents of the University of
//North Carolina  sponsored in part by the United States
//Department of Energy (DOE) under Grant #DE-FG02-97ER41020.
//The University has certain rights in the program pursuant to
//the contract and the program should not be copied or distributed
//outside your organization.  The DOE and the University of
//North Carolina reserve all rights in the program. Neither the authors,
//University of North Carolina, or U.S. Government make any warranty,
//express or implied, or assume any liability or responsibility
//for the us of this software.
//-------------------------------------------------------------

#pragma mark •••Imported Files

#import "ORNMon5085Model.h"
#import "ORSerialPort.h"
#import "ORSerialPortAdditions.h"
#import "ORTimeRate.h"

#pragma mark •••External Strings

NSString* ORNMon5085ModelMaxRadValueChanged       = @"ORNMon5085ModelMaxRadValueChanged";
NSString* ORNMon5085ModelDateOfMaxRadValueChanged = @"ORNMon5085ModelDateOfMaxRadValueChanged";
NSString* ORNMon5085ModelHighVoltageChanged       = @"ORNMon5085ModelHighVoltageChanged";
NSString* ORNMon5085ModelDeadtimeChanged          = @"ORNMon5085ModelDeadtimeChanged";
NSString* ORNMon5085ModelActualModeChanged        = @"ORNMon5085ModelActualModeChanged";
NSString* ORNMon5085ModelDiscriminatorChanged     = @"ORNMon5085ModelDiscriminatorChanged";
NSString* ORNMon5085ModelCalibrationValueChanged  = @"ORNMon5085ModelCalibrationValueChanged";
NSString* ORNMon5085ModelTimeUtilStopChanged      = @"ORNMon5085ModelTimeUtilStopChanged";
NSString* ORNMon5085ModelIsRunningChanged         = @"ORNMon5085ModelIsRunningChanged";
NSString* ORNMon5085ModelUnitsChanged             = @"ORNMon5085ModelUnitsChanged";
NSString* ORNMon5085ModelRadValueChanged          = @"ORNMon5085ModelRadValueChanged";
NSString* ORNMon5085ModelModeTimeChanged          = @"ORNMon5085ModelModeTimeChanged";
NSString* ORNMon5085ModelModeChanged              = @"ORNMon5085ModelModeChanged";
NSString* ORNMon5085Lock                          = @"ORNMon5085Lock";
NSString* ORNMon5085IsLogChanged                  = @"ORNMon5085IsLogChanged";

@interface ORNMon5085Model (private)
- (void) send:(NSString*)aCmd;
- (void) saveMaxRadValue;
- (void) saveNonZeroRadValue;
- (void) processReceivedString:(NSString*)aString;
- (void) sendNextCmd;
- (void) pollHW;
@end

#define kHWPollTime 5

@implementation ORNMon5085Model
- (void) dealloc
{
    [dateOfMaxRadValue release];
    [timeRate release];
    [actualMode release];
    [dateMeasured release];
    [units release];
	[inComingData release];
    [NSObject cancelPreviousPerformRequestsWithTarget:self];

	[super dealloc];
}

- (void)sleep
{
	[NSObject cancelPreviousPerformRequestsWithTarget:self];
    [super sleep];
}

- (void) setUpImage
{
	[self setImage:[NSImage imageNamed:@"NMon5085.tif"]];
}

- (void) makeMainController
{
	[self linkToController:@"ORNMon5085Controller"];
}

#pragma mark •••Accessors

- (float) maxRadValue
{
    return maxRadValue;
}

- (void) setMaxRadValue:(float)aMaxRadValue
{
    maxRadValue = aMaxRadValue;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORNMon5085ModelMaxRadValueChanged object:self];
}

- (NSDate*) dateOfMaxRadValue
{
    return dateOfMaxRadValue;
}

- (void) setDateOfMaxRadValue:(NSDate*)aDateOfMaxRadValue
{
    [aDateOfMaxRadValue retain];
    [dateOfMaxRadValue release];
    dateOfMaxRadValue = aDateOfMaxRadValue;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORNMon5085ModelDateOfMaxRadValueChanged object:self];
}

- (int) highVoltage
{
    return highVoltage;
}

- (void) setHighVoltage:(int)aHighVoltage
{
    highVoltage = aHighVoltage;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORNMon5085ModelHighVoltageChanged object:self];
}

- (int) deadtime
{
    return deadtime;
}

- (void) setDeadtime:(int)aDeadtime
{
    deadtime = aDeadtime;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORNMon5085ModelDeadtimeChanged object:self];
}

- (NSString*) actualMode
{
    if([actualMode length])    return actualMode;
    else return @"?";
}

- (void) setActualMode:(NSString*)aActualMode
{
    [actualMode autorelease];
    actualMode = [aActualMode copy];

    [[NSNotificationCenter defaultCenter] postNotificationName:ORNMon5085ModelActualModeChanged object:self];
}

- (int) discriminator
{
    return discriminator;
}

- (void) setDiscriminator:(int)aDiscriminator
{
    discriminator = aDiscriminator;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORNMon5085ModelDiscriminatorChanged object:self];
}

- (float) calibrationValue
{
    return calibrationValue;
}

- (void) setCalibrationValue:(float)aCalibrationValue
{
    calibrationValue = aCalibrationValue;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORNMon5085ModelCalibrationValueChanged object:self];
}

- (int) timeUtilStop
{
    return timeUtilStop;
}

- (void) setTimeUtilStop:(int)aTimeUtilStop
{
     timeUtilStop = aTimeUtilStop;
    

    [[NSNotificationCenter defaultCenter] postNotificationName:ORNMon5085ModelTimeUtilStopChanged object:self];
}

- (BOOL) isRunning
{
    return isRunning;
}

- (void) setIsRunning:(BOOL)aVaue
{
    isRunning = aVaue;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORNMon5085ModelIsRunningChanged object:self];
}

- (BOOL) isLog
{
    return isLog;
}

- (void) setIsLog:(BOOL)aIsLog
{
    [[[self undoManager] prepareWithInvocationTarget:self] setIsLog:isLog];
    isLog = aIsLog;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORNMon5085IsLogChanged object:self];
}

- (ORTimeRate*)timeRate
{
	return timeRate;
}

- (uint32_t) timeMeasured
{
    return timeMeasured;
}

- (NSDate*) dateMeasured
{
    return dateMeasured;
}

- (NSString*) units
{
    if([units length]==0)return @"--";
    else return units;
}

- (void) setUnits:(NSString*)aUnits
{
    [units autorelease];
    units = [aUnits copy];    
    [[NSNotificationCenter defaultCenter] postNotificationName:ORNMon5085ModelUnitsChanged object:self];
}

- (float) radValue
{
    return radValue;
}

- (void) setRadValue:(float)aRadValue
{
    [dateMeasured release];
    dateMeasured = [[NSDate date]retain];
    
    time_t	ut_Time;
    time(&ut_Time);
    timeMeasured = (uint32_t)ut_Time;
    
    radValue = aRadValue;
    
    if(radValue>0){
        [self saveNonZeroRadValue];
    }
    
    NSDate* now = [NSDate date];
    if(!dateOfMaxRadValue){
        [self setDateOfMaxRadValue:now];
        [self setMaxRadValue:radValue];
    }
    
    if(radValue>maxRadValue){
        [self setMaxRadValue:radValue];
        [self setDateOfMaxRadValue:now];
    }
    
    if([now timeIntervalSinceDate:dateOfMaxRadValue]>=60){
        if(radValue>0)[self saveMaxRadValue];
        radValue = 0;
        [self setDateOfMaxRadValue:now];
    }
    
    if(timeRate == nil) timeRate = [[ORTimeRate alloc] init];
    [timeRate addDataToTimeAverage:radValue];
        
    [[NSNotificationCenter defaultCenter] postNotificationName:ORNMon5085ModelRadValueChanged object:self];
}

- (int) modeTime
{
    return modeTime;
}

- (void) setModeTime:(int)aValue
{
    [[[self undoManager] prepareWithInvocationTarget:self] setModeTime:modeTime];
    modeTime = aValue;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORNMon5085ModelModeTimeChanged object:self];
}

- (int) opMode
{
    return opMode;
}

- (void) setOpMode:(int)aMode
{
    [[[self undoManager] prepareWithInvocationTarget:self] setOpMode:opMode];
    opMode = aMode;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORNMon5085ModelModeChanged object:self];
}

- (void) setUpPort
{
	[serialPort setSpeed:9600];
	[serialPort setParityNone];
	[serialPort setStopBits2:NO];
	[serialPort setDataBits:8];
}

- (void) firstActionAfterOpeningPort
{
    firstPoll = YES;
    [self pollHW];
}

#pragma mark •••Archival
- (id) initWithCoder:(NSCoder*)decoder
{
	self = [super initWithCoder:decoder];
	[[self undoManager] disableUndoRegistration];
	[self setIsLog:		[decoder decodeBoolForKey:@"isLog"]];
	[self setModeTime:  [decoder decodeIntForKey:@"modeTime"]];
    [self setOpMode:      [decoder decodeIntForKey:@"mode"]];
	[[self undoManager] enableUndoRegistration];
	
	return self;
}

- (void) encodeWithCoder:(NSCoder*)encoder
{
    [super encodeWithCoder:encoder];
    [encoder encodeBool:isLog	forKey:@"isLog"];
    [encoder encodeInteger:modeTime forKey:@"modeTime"];
    [encoder encodeInteger:opMode		forKey:@"mode"];
}

#pragma mark •••Commands
- (void) sendMode
{
    
    NSString* modeCmd[4] = {@"R",@"I",@"C",@"S"};
    if(opMode>=0 && opMode<4){
        [self enqueueCmd:@"M"];
        [self enqueueCmd:modeCmd[opMode]];
    }
}

- (NSString*) modeString
{
    switch(opMode){
        case kNMon5085RateMode:     return @"Rate Mode";
        case kNMon5085Integrate:    return @"Integrate Mode";
        case kNMon5085CountsPerS:   return @"Counts/Sec";
        case kNMon5085Scaler:       return @"Scaler Mode";
        default: return @"?";
    }
    return @"?";
}

- (void) sendStart
{
    NSLog(@"Started Neutron Monitor (%@)\n",[self modeString]);
    
    if(opMode == kNMon5085Scaler ||
       opMode == kNMon5085Integrate) autoRestart  = YES;
    else                           autoRestart  = NO;
    
    if(opMode == kNMon5085Scaler || opMode == kNMon5085Integrate){
        [self enqueueCmd:@"S"];
        [self startCountDown];
    }
    else {
        [self enqueueCmd:@"Q"];
    }
}

- (void) startCountDown
{
    [self setTimeUtilStop:modeTime];
    [self performSelector:@selector(countDown) withObject:nil afterDelay:1];
}

- (void) cancelCountDown
{
    [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(countDown) object:nil];  
    [self setTimeUtilStop:0];
}

- (void) countDown
{
    [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(countDown) object:nil];
    int newTime = timeUtilStop-1;
    if(newTime<=0)newTime=0;
    [self setTimeUtilStop:newTime];
    if(newTime!=0){
        [self performSelector:@selector(countDown) withObject:nil afterDelay:1];     
    }
}
- (void) sendTime
{
    if(opMode == kNMon5085Integrate || opMode == kNMon5085Scaler){
        
        int t = modeTime;
        int h = t / 3600;
        t = t % 3600;
        int m = t / 60;
        t = t % 60;
        int s = t;

        [self enqueueCmd:@"T"];
        [self enqueueCmd:[NSString stringWithFormat:@"%d",h]];
        [self enqueueCmd:[NSString stringWithFormat:@"%d",m]];
        [self enqueueCmd:[NSString stringWithFormat:@"%d",s]];
    }
}

- (void) toggleRun
{
    if(!isRunning){
        forcedStop = NO;
        [self sendMode];
        [self sendTime];
        [self sendStart];
        [self setIsRunning:YES];
        [self pollHW];
    }
    
    else {
        switch([self opMode]){
            case kNMon5085Integrate:
            case kNMon5085Scaler:
                autoRestart = NO;
                [self enqueueCmd:@"S"];
            break;
            case kNMon5085RateMode:
            case kNMon5085CountsPerS:
                [self enqueueCmd:@"Q"];
            break;
        }
        forcedStop = YES;
        [self setIsRunning:NO];
        [self cancelCountDown];
        NSLog(@"Stopped Neutron Monitor (%@)\n",[self modeString]);


    }
}

- (void) pollHW
{
    [self enqueueCmd:@"V"];
}

- (void) enqueueCmd:(id)aCmd
{
    if(![(NSString*)aCmd hasSuffix:@"\r"])aCmd = [(NSString*)aCmd stringByAppendingString:@"\r"];
    [super enqueueCmd:aCmd];
    [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(sendNextCmd) object:nil];
    [self performSelector:@selector(sendNextCmd) withObject:nil afterDelay:.3];

}
    
- (void) sendNextCmd
{
    [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(sendNextCmd) object:nil];
    id aCmd = [self nextCmd];
    if(aCmd){
        [serialPort writeString:aCmd];
        [self performSelector:@selector(sendNextCmd) withObject:nil afterDelay:.3];
    }
}

- (void) dataReceived:(NSNotification*)note
{	
    if([[note userInfo] objectForKey:@"serialPort"] == serialPort){
		if(!inComingData)inComingData = [[NSMutableData data] retain];
        [inComingData appendData:[[note userInfo] objectForKey:@"data"]];
        NSRange r;
        NSString* s;
        
        int i;
        for(i=0;i<[inComingData length];i++){
            unsigned char* p = (unsigned char*)[inComingData bytes];
            if(*p == '\n' || *p == '\r' || *p == ' ' || *p == '*'){
                [inComingData replaceBytesInRange:NSMakeRange(0,1) withBytes:nil length:0];
            }
            else break;
        }
        
        s = [[[NSString alloc] initWithData:inComingData encoding:NSASCIIStringEncoding] autorelease];
        r = [s rangeOfString:@"\n"];
        if(r.location!=NSNotFound){
            [self processReceivedString:s];
            [inComingData replaceBytesInRange:NSMakeRange(0,r.location) withBytes:nil length:0];
        }

        s = [[[NSString alloc] initWithData:inComingData encoding:NSASCIIStringEncoding] autorelease];
        r = [s rangeOfString:@"\r"];
        if(r.location!=NSNotFound){
            [self processReceivedString:s];
            [inComingData replaceBytesInRange:NSMakeRange(0,r.location) withBytes:nil length:0];
        }
	}
}
- (void) processReceivedString:(NSString*)aString
{
    aString = [aString stringByReplacingOccurrencesOfString:@"*" withString:@""];
    aString = [aString removeExtraSpaces];
    aString = [aString trimSpacesFromEnds];
    
    if([aString length]==0)return;
    else if([aString rangeOfString:@"?"].location != NSNotFound)return;
    else {
        @try {
            if([aString hasPrefix:@"rate mode"]){
                [self setActualMode:@"Rate"];
                if(firstPoll){
                    firstPoll = NO;
                    [[self undoManager] disableUndoRegistration];
                    [self setOpMode:kNMon5085RateMode];
                    [[self undoManager] enableUndoRegistration];
                }
            }
            else if([aString hasPrefix:@"integrate mode"]) {
                [self setActualMode:@"Integrate"];
                if(firstPoll){
                    firstPoll = NO;
                    [[self undoManager] disableUndoRegistration];
                    [self setOpMode:kNMon5085Integrate];
                    [[self undoManager] enableUndoRegistration];
                }
            }
            
            else if([aString hasPrefix:@"scaler mode"]) {
                [self setActualMode:@"Scaler"];
                if(firstPoll){
                    firstPoll = NO;
                    [[self undoManager] disableUndoRegistration];
                    [self setOpMode:kNMon5085Scaler];
                    [[self undoManager] enableUndoRegistration];
                }
            }
            
            else if([aString hasPrefix:@"CPS mode"]) {
                [self setActualMode:@"CPS"];
                if(firstPoll){
                    firstPoll = NO;
                    [[self undoManager] disableUndoRegistration];
                    [self setOpMode:kNMon5085CountsPerS];
                    [[self undoManager] enableUndoRegistration];
                }
            }
            else if([aString rangeOfString:@"uSv/h"].location!= NSNotFound){                            
                [self setRadValue:[aString floatValue]];
                NSArray* parts = [aString componentsSeparatedByString:@" "];
                if([parts count]>=2) [self setUnits:[[parts objectAtIndex:1] substringToIndex:5]];
                if(!forcedStop)[self setIsRunning:YES];
            }
            else if([aString rangeOfString:@"mrem/h"].location!= NSNotFound){                            
                [self setRadValue:[aString floatValue]];
                NSArray* parts = [aString componentsSeparatedByString:@" "];
                if([parts count]>=2) [self setUnits:[[parts objectAtIndex:1] substringToIndex:6]];
                if(!forcedStop)[self setIsRunning:YES];
            }
            
            else if([aString rangeOfString:@"running"].location!= NSNotFound){
                [self setIsRunning:YES];
            }
                
            else if([aString rangeOfString:@"CPS"].location!= NSNotFound){
                [self setRadValue:[aString floatValue]];
                if(!forcedStop)[self setIsRunning:YES];
                NSArray* parts = [aString componentsSeparatedByString:@" "];
                if([parts count]>=2) [self setUnits:[[parts objectAtIndex:1] substringToIndex:3]];
            }
            
            else if([aString rangeOfString:@"cts"].location!= NSNotFound ||
                    [aString rangeOfString:@"nSv"].location!= NSNotFound){
                [self setRadValue:[[aString substringFromIndex:5] floatValue]];
                NSArray* parts = [aString componentsSeparatedByString:@" "];
                if([parts count]>=3) [self setUnits:[[parts objectAtIndex:2] substringToIndex:3]];
                [self enqueueCmd:@"S"]; //reset
                if(autoRestart){
                    [self enqueueCmd:@"S"]; //restart
                    [self startCountDown];
                }
                else [self setIsRunning:NO];
            }
            else if([aString rangeOfString:@"NEUTRON SURVEY"].location!= NSNotFound){
                //this means that the scalar run is done. We need to restart it
                [self sendMode];
                [self sendStart];
            }

            else if([aString hasPrefix:@"discriminator:"]) [self setDiscriminator:[[aString substringFromIndex:14] intValue]];
            else if([aString hasPrefix:@"deadtime:"])      [self setDeadtime:[[aString substringFromIndex:9] intValue]];
            else if([aString hasPrefix:@"HV:"])            [self setHighVoltage:[[aString substringFromIndex:4] intValue]];
            else if([aString hasPrefix:@"calibration:"])   [self setCalibrationValue:[[aString substringFromIndex:12] floatValue]];
  
            else if([aString hasPrefix:@"data:"]){
                [self setRadValue:[[aString substringWithRange:NSMakeRange(5,6)] floatValue]];
                [self setUnits:[aString substringWithRange:NSMakeRange(10,4)]];

            }
        }
        @catch(NSException* e){
            NSLog(@"ex on %@\n",aString);
        }
    }
}

- (int) processHHMMSS:(NSString*)aString
{
    NSArray* timeParts = [aString componentsSeparatedByString:@":"];
    int timeLeft = 0;
    if([timeParts count]>=3){
        timeLeft = [[timeParts objectAtIndex:0] intValue]*3600 +
        [[timeParts objectAtIndex:1] intValue]*60 +
        [[timeParts objectAtIndex:2] intValue];
    }
    return timeLeft;
}

- (void) saveMaxRadValue
{
#define kDefaultMaxRecordFile @"~/Desktop/NMonMaxValueRecord"
    
    NSFileManager* fm = [NSFileManager defaultManager];
    NSString* filePath = [NSString stringWithFormat:@"%@%d.txt",kDefaultMaxRecordFile,[self uniqueIdNumber]];
    filePath = [filePath stringByExpandingTildeInPath];
    if(![fm fileExistsAtPath:filePath]){
        [fm createFileAtPath:filePath contents:nil attributes:nil];
    }
    
    NSDateFormatter* dateFormatter = [[NSDateFormatter alloc] init];
    [dateFormatter setDateFormat:@"HH:mm:S"];
	NSString* dateString = [dateFormatter stringFromDate:dateOfMaxRadValue];
    [dateFormatter release];

    
    NSFileHandle* fp = [NSFileHandle fileHandleForUpdatingAtPath:filePath];
    NSString* stringToAdd = [NSString stringWithFormat:@"%@,%u,%3.3f\n",dateString,(uint32_t)[dateOfMaxRadValue timeIntervalSince1970],maxRadValue];
    [fp seekToEndOfFile];
    NSData* theData = [stringToAdd dataUsingEncoding:NSASCIIStringEncoding]; 
    [fp writeData:theData];
    [fp closeFile];
}

- (void) saveNonZeroRadValue
{
#define kDefaultNonZeroRecordFile @"~/Desktop/NMonNonZeroRecord"
    
    NSFileManager* fm = [NSFileManager defaultManager];
    NSString* filePath = [NSString stringWithFormat:@"%@%d.txt",kDefaultNonZeroRecordFile,[self uniqueIdNumber]];
    filePath = [filePath stringByExpandingTildeInPath];
    if(![fm fileExistsAtPath:filePath]){
        [fm createFileAtPath:filePath contents:nil attributes:nil];
    }
    NSDate* now = [NSDate date];
 	NSDateFormatter* dateFormatter = [[NSDateFormatter alloc] init];
    [dateFormatter setDateFormat:@"HH:mm:S"];
	NSString* dateString = [dateFormatter stringFromDate:now];
    [dateFormatter release];
    
    NSFileHandle* fp = [NSFileHandle fileHandleForUpdatingAtPath:filePath];
    NSString* stringToAdd = [NSString stringWithFormat:@"%@,%u,%3.3f\n",dateString,(uint32_t)[now timeIntervalSince1970],radValue];
    [fp seekToEndOfFile];
    NSData* theData = [stringToAdd dataUsingEncoding:NSASCIIStringEncoding];
    [fp writeData:theData];
    [fp closeFile];
}

@end
