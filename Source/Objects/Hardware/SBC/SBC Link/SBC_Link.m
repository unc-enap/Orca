//--------------------------------------------------------
// SBC_Link
// Created by Mark  A. Howe on Tue Feb 07 2006
// Code partially generated by the OrcaCodeWizard. Written by Mark A. Howe.
// Copyright (c) 2006 CENPA, University of Washington. All rights reserved.
//-----------------------------------------------------------
//This program was prepared for the Regents of the University of 
//Washington at the Center for Experimental Nuclear Physics and 
//Astrophysics (CENPA) sponsored in part by the United States 
//Department of Energy (DOE) under Grant #DE-FG02-97ER41020. 
//The University has certain rights in the program pursuant to 
//the contract and the program should not be copied or distributed 
//outside your organization.  The DOE and the University of 
//Washington reserve all rights in the program. Neither the authors,
//University of Washington, or U.S. Government make any warranty, 
//express or implied, or assume any liability or responsibility 
//for the use of this software.
//-------------------------------------------------------------

#pragma mark ***Imported Files

#import "SBC_Link.h"
#import "SBC_Linking.h"
#import "ORFileMover.h"
#import "ORReadOutList.h"
#import "SBC_Config.h"
#import "ORTaskSequence.h"
#import "ORSafeQueue.h"
#import "ORSBC_LAMModel.h"
#import "ORCommandList.h"
#import "NSNotifications+Extensions.h"
#import "NSFileManager+Extensions.h"

#import "libkern/OSAtomic.h" //necessary for 10.6 (needed for OSQueueHead, OSAtomicDequeue, etc.) -tb-

#import <netdb.h>
#import <sys/types.h>
#import <sys/socket.h>
#import <sys/select.h>
#import <sys/errno.h>

#import <objc/runtime.h>

#define kNoSelectionError	 0
#define kSelectionTimeout	 0
#define kNoBlock			 0
#define kBlock				 1
#define kError				-1
#define kSelectionError		-1
#define kNoData				-2

#define kSBCRateIntegrationTime 1.5
#define kSBCMaxErrorRate    1000


#pragma mark ***External Strings
NSString* SBC_LinkLoadModeChanged			= @"SBC_LinkLoadModeChanged";
NSString* SBC_LinkInitAfterConnectChanged	= @"SBC_LinkInitAfterConnectChanged";
NSString* SBC_LinkReloadingChanged			= @"SBC_LinkReloadingChanged";
NSString* SBC_LinkWriteValueChanged			= @"SBC_LinkWriteValueChanged";
NSString* SBC_LinkWriteAddressChanged		= @"SBC_LinkWriteAddressChanged";
NSString* SBC_LinkPathChanged				= @"SBC_LinkPathChanged";
NSString* SBC_LinkUserNameChanged			= @"SBC_LinkUserNameChanged";
NSString* SBC_LinkPassWordChanged			= @"SBC_LinkPassWordChanged";
NSString* SBC_LinkPortChanged				= @"SBC_LinkPortChanged";
NSString* SBC_LinkIPNumberChanged			= @"SBC_LinkIPNumberChanged";
NSString* SBC_LinkRunInfoChanged			= @"SBC_LinkRunInfoChanged";
NSString* SBC_LinkLock						= @"SBC_LinkLock";
NSString* SBC_LinkTimeConnectedChanged		= @"SBC_LinkTimeConnectedChanged";
NSString* SBC_LinkConnectionChanged			= @"SBC_LinkConnectionChanged";
NSString* SBC_LinkCompilerErrorsChanged		= @"SBC_LinkCompilerErrorsChanged";
NSString* SBC_LinkCompilerWarningsChanged	= @"SBC_LinkCompilerWarningsChanged";
NSString* SBC_LinkVerboseChanged			= @"SBC_LinkVerboseChanged";
NSString* SBC_LinkForceReloadChanged		= @"SBC_LinkForceReloadChanged";
NSString* SBC_LinkCrateStartStatusChanged	= @"SBC_LinkCrateStartStatusChanged";
NSString* SBC_LinkTryingToStartCrateChanged = @"SBC_LinkTryingToStartCrateChanged";
NSString* SBC_LinkByteRateChanged			= @"SBC_LinkByteRateChanged";
NSString* SBC_LinkRangeChanged				= @"SBC_LinkRangeChanged";
NSString* SBC_LinkDoRangeChanged			= @"SBC_LinkDoRangeChanged";
NSString* SBC_LinkAddressModifierChanged	= @"SBC_LinkAddressModifierChanged";
NSString* SBC_LinkRWTypeChanged             = @"SBC_LinkRWTypeChanged";
NSString* SBC_LinkInfoTypeChanged           = @"SBC_LinkInfoTypeChanged";
NSString* SBC_LinkPingTask                  = @"SBC_LinkPingTask";
NSString* SBC_LinkCBTest					= @"SBC_LinkCBTest";
NSString* SBC_LinkNumCBTextPointsChanged	= @"SBC_LinkNumCBTextPointsChanged";
NSString* SBC_LinkNumPayloadSizeChanged     = @"SBC_LinkNumPayloadSizeChanged";
NSString* SBC_LinkJobStatus                 = @"SBC_LinkJobStatus";
NSString* SBC_LinkErrorTimeOutChanged		= @"SBC_LinkErrorTimeOutChanged";
NSString* SBC_CodeVersionChanged			= @"SBC_CodeVersionChanged";
NSString* SBC_SocketDroppedUnexpectedly     = @"SBC_SocketDroppedUnexpectedly";
NSString* SBC_LinkSbcPollingRateChanged     = @"SBC_LinkSbcPollingRateChanged";
NSString* SBC_LinkErrorInfoChanged          = @"SBC_LinkErrorInfoChanged";
NSString* SBC_LinkMacAddressChanged         = @"SBC_LinkMacAddressChanged";
NSString* SBC_LinkTimeSkewChanged           = @"SBC_LinkTimeSkewChanged";
NSString* SBC_LinkSbcDisableThrottleChanged = @"SBC_LinkSbcDisableThrottleChanged";

@interface SBCPacketWrapper : NSObject {
    NSMutableData* data;
}

+ (id) allocWithZone:(struct _NSZone *)zone;
- (void) dealloc;
- (void) releaseAndCache;
- (SBC_Packet*) sbcPacket;

@end

static OSQueueHead gSBCPacketWrapperHead = OS_ATOMIC_QUEUE_INIT;
static id GetSBCPacketFromCache()
{
    return OSAtomicDequeue(&gSBCPacketWrapperHead, offsetof(struct objc_object,isa));
}

static void AddSBCPacketWrapperToCache(SBCPacketWrapper *sbc)
{
    OSAtomicEnqueue(&gSBCPacketWrapperHead, sbc, offsetof(struct objc_object,isa));
}

@implementation SBCPacketWrapper
+ (id) allocWithZone:(struct _NSZone *)zone
{
    id obj = GetSBCPacketFromCache();
    if (obj) {
        *(Class *)obj = self;
    } else {
        obj = [super allocWithZone:zone];
    }
    return obj;
}

-(void) releaseAndCache
{
    AddSBCPacketWrapperToCache(self);
}

- (void) dealloc
{
    [data release];
    [super dealloc];
}

- (SBC_Packet*) sbcPacket
{
    if(!data) data = [[NSMutableData alloc] initWithLength:sizeof(SBC_Packet)];
    return (SBC_Packet*) [data mutableBytes];
}
@end

@implementation SBC_Link
- (id)   initWithDelegate:(ORCard*)aDelegate
{
	self = [super init];
	delegate = aDelegate; //don't retain.
	socketLock = [[NSLock alloc] init];
	
	exitCBTest    = YES;
	cbTestRunning = NO;
	[self initConnectionHistory];
	return self;
}


- (void) dealloc
{
	@try {
		[self stopCrate];
	}
	@catch (NSException* localException) {
	}
    [sbcMacAddress release];
	[socketLock release];
	[eCpuDeadAlarm clearAlarm];
	[eCpuDeadAlarm release];
	[eRunFailedAlarm clearAlarm];
	[eRunFailedAlarm release];
	[eCpuCBFillingAlarm clearAlarm];
	[eCpuCBFillingAlarm release];
	[eCpuCBLostDataAlarm clearAlarm];
	[eCpuCBLostDataAlarm release];
	[connectionDroppedAlarm clearAlarm];
	[connectionDroppedAlarm release];
    
    [errorsAlarm clearAlarm];
    [errorsAlarm release];

    
    [lastRateUpdate release];
	[timeConnected release];
	[connectionHistory release];
    [filePath release];
    [userName release];
    [passWord release];
    [IPNumber release];
	[lastQueUpdate release];

	[[NSNotificationCenter defaultCenter] removeObserver : self];
	NSString* folder = [mainStagingFolder stringByExpandingTildeInPath];
	[[NSFileManager defaultManager] removeItemAtPath:folder error:nil];
	[mainStagingFolder release];
	
	[super dealloc];
}


- (void) wakeUp 
{
}

- (void) sleep 	
{	
}

- (void) initConnectionHistory
{
	ipNumberIndex = [[NSUserDefaults standardUserDefaults] integerForKey: [NSString stringWithFormat:@"orca.%@.%d.IPNumberIndex",[self className],[self slot]]];
	if(!connectionHistory){
		NSArray* his = [[NSUserDefaults standardUserDefaults] objectForKey: [NSString stringWithFormat:@"orca.%@.%d.ConnectionHistory",[self className],[self slot]]];
		connectionHistory = [his mutableCopy];
	}
	if(!connectionHistory)connectionHistory = [[NSMutableArray alloc] init];
}

#pragma mark ***Accessors
- (long) sbcCodeVersion
{
	return sbcCodeVersion;
}

- (void) setSbcCodeVersion:(long)aVersion
{
    sbcCodeVersion = aVersion;
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_CodeVersionChanged object:self];
}

- (void) checkSBCTime
{
    [self checkSBCTime:YES];
}
- (void) checkSBCAccurateTime
{
    [self checkSBCAccurateTime:YES];
}
- (void) checkSBCAccurateTime:(BOOL)aVerbose
{
    id pw = [[SBCPacketWrapper alloc] init];
    SBC_Packet* aPacket = [pw sbcPacket];
    aPacket->cmdHeader.destination          = kSBC_Process;
    aPacket->cmdHeader.cmdID                = kSBC_GetAccurateTime;
    aPacket->cmdHeader.numberBytesinPayload = 0;
    @try {
        [self send:aPacket receive:aPacket];
        SBC_accurate_time_struct* theTimeStruct = (SBC_accurate_time_struct*)(aPacket->payload);
        
        float theSBCTime    = theTimeStruct->seconds + (theTimeStruct->microSeconds)/1.0E6;
        float theMacTime    = (float)[[NSDate date] timeIntervalSince1970];
        
        float skew = theSBCTime - theMacTime;
        timeSkewValid = YES;
        if(aVerbose){
            NSLog(@"SBC %@ Time Check\n",[delegate fullID]);
            NSLog(@"SBC Time: %f\n",theSBCTime);
            NSLog(@"Mac Time: %f\n",theMacTime);
            NSLog(@"SBC - Mac: %f seconds\n",skew);
        }
    }
    @catch (NSException* e){
        timeSkewValid = NO;
    }
    [pw releaseAndCache];
    
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkTimeSkewChanged object:self];
}

- (void) checkSBCTime:(BOOL)aVerbose
{
    id pw = [[SBCPacketWrapper alloc] init];
    SBC_Packet* aPacket = [pw sbcPacket];
    aPacket->cmdHeader.destination			= kSBC_Process;
    aPacket->cmdHeader.cmdID                = kSBC_GetTimeRequest;
    aPacket->cmdHeader.numberBytesinPayload	= 0;
    @try {
        [self send:aPacket receive:aPacket];
        SBC_time_struct* theTimeStruct = (SBC_time_struct*)(aPacket->payload);
        
        unsigned long theSBCTime    = theTimeStruct->unixTime;
        NSDate*       theSBCDate    = [NSDate dateWithTimeIntervalSince1970:theTimeStruct->unixTime];
        
        unsigned long theMacTime    = (unsigned long)[[NSDate date] timeIntervalSince1970];
        NSDate*       theMacDate    = [NSDate date];

        timeSkew = theSBCTime - theMacTime;
        timeSkewValid = YES;
        if(aVerbose){
            NSLog(@"SBC %@ Time Check\n",[delegate fullID]);
            NSLog(@"SBC Time: [%lu] %@\n",theSBCTime,[theSBCDate stdDescription]);
            NSLog(@"Mac Time: [%lu] %@\n",theMacTime,[theMacDate stdDescription]);
            NSLog(@"SBC - Mac: %ld seconds\n",timeSkew);
        }
    }
    @catch (NSException* e){
        timeSkewValid = NO;
    }
    [pw releaseAndCache];
    
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkTimeSkewChanged object:self];
}

- (long) timeSkew       { return timeSkew;      }
- (BOOL) timeSkewValid  { return timeSkewValid; }

- (void) setSBCTime:(NSString*)rootPwd
{
    NSString* resourcePath = [[NSBundle mainBundle] resourcePath];
    
    ORTaskSequence* aSequence = [ORTaskSequence taskSequenceWithDelegate:self];
    NSString*       pwd       = [rootPwd length]?rootPwd:@"\n";
    
    NSDateComponents* c = [[NSCalendar currentCalendar] components:
                                    NSCalendarUnitSecond    |
                                    NSCalendarUnitMinute    |
                                    NSCalendarUnitHour      |
                                    NSCalendarUnitDay       |
                                    NSCalendarUnitMonth     |
                                    NSCalendarUnitYear
                                        fromDate:[NSDate date]];

    NSString* yearPart = [NSString stringWithFormat:@"%02d%02d%02d%02d%d.%02d",[c month],[c day],[c hour],[c minute],[c year],[c second]];
    
    [aSequence addTask:[resourcePath stringByAppendingPathComponent:@"loginScript"]
                 arguments:[NSArray arrayWithObjects:@"root",pwd,IPNumber,@"date",yearPart,nil]];
 
    [aSequence addTask:[resourcePath stringByAppendingPathComponent:@"loginScript"]
             arguments:[NSArray arrayWithObjects:@"root",pwd,IPNumber,@"hwclock",@"--systohc",nil]];
    
    [aSequence setVerbose:verbose];
    [aSequence setTextToDelegate:YES];
    
    [aSequence launch];
}

- (void) clearHistory
{
	[connectionHistory release];
	connectionHistory = nil;
	
	[self setIPNumber:[self IPNumber]];
}


- (NSUInteger) connectionHistoryCount
{
	return [connectionHistory count];
}

- (id) connectionHistoryItem:(NSUInteger)index
{
	if(connectionHistory && index<[connectionHistory count])return [connectionHistory objectAtIndex:index];
	else return nil;
}

- (NSUInteger) ipNumberIndex
{
	return ipNumberIndex;
}

- (int) slot
{
	return [delegate slot];
}

- (void) setErrorTimeOut:(int)aValue
{
	[[[self undoManager] prepareWithInvocationTarget:self] setErrorTimeOut:errorTimeOut];
    errorTimeOut = aValue;
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkErrorTimeOutChanged object:self];
}

- (int) errorTimeOut
{
	return errorTimeOut;
}

- (int) errorTimeOutSeconds
{
	static int translatedTimeOut[4] = {2,10,60,0};
	if(errorTimeOut<0 || errorTimeOut>3)return 2;
	else return translatedTimeOut[errorTimeOut];
}

- (int) numTestPoints
{
	return numTestPoints;
}

- (void) setNumTestPoints:(int)num
{
	if(num<1) num = 1;
	else if(num>100)num = 100;
	
    [[[self undoManager] prepareWithInvocationTarget:self] setNumTestPoints:numTestPoints];
    
    numTestPoints = num;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkNumCBTextPointsChanged object:self];
}

- (int) infoType
{
	return infoType;
}

- (void) setInfoType:(int)aType;
{
    [[[self undoManager] prepareWithInvocationTarget:self] setInfoType:infoType];
    
    infoType = aType;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkInfoTypeChanged object:self];
}

- (void) setDelegate:(ORCard*)aDelegate
{
	delegate = aDelegate;
}

- (id) delegate
{
	return  delegate;
}

- (NSUndoManager*) undoManager
{
	return [(ORAppDelegate*)[NSApp delegate] undoManager];
}

- (NSString*) sbcLockName
{
	return [delegate sbcLockName];
}

- (void) installDriver:(NSString*)rootPwd 
{ 
	if([delegate respondsToSelector:@selector(driverScriptName)]){
		ORTaskSequence* aSequence;	
		aSequence = [ORTaskSequence taskSequenceWithDelegate:self];
		NSString* resourcePath = [[NSBundle mainBundle] resourcePath];
		
		NSString* driverCodePath;
		if(loadMode)driverCodePath = [filePath stringByAppendingPathComponent:[delegate sbcLocalCodePath]];
		else driverCodePath = [resourcePath stringByAppendingPathComponent:[delegate codeResourcePath]];
		driverCodePath = [driverCodePath stringByAppendingPathComponent:[delegate driverScriptName]];
		driverScriptFileMover = [[ORFileMover alloc] init];
		[driverScriptFileMover doNotUseTempFile];
		[driverScriptFileMover setDelegate:aSequence];
		
		[driverScriptFileMover setMoveParams:[driverCodePath stringByExpandingTildeInPath]
										to:@"" 
								remoteHost:IPNumber 
								  userName:userName 
								  passWord:passWord];
		[driverScriptFileMover setVerbose:YES];
		[driverScriptFileMover doNotMoveFilesToSentFolder];
		[driverScriptFileMover setTransferType:eUseSCP];
		[aSequence addTaskObj:driverScriptFileMover];

		//since we made the task sequence the filemover's delegate, 
		//we have to use the notification to know when the mover is done		
		[[NSNotificationCenter defaultCenter] addObserver : self
												 selector : @selector(fileMoverIsDone:)
													 name : ORFileMoverIsDoneNotification
												   object : driverScriptFileMover];
		
		NSString* scriptRunPath = [NSString stringWithFormat:@"/home/%@/%@",userName,[delegate driverScriptName]];
        NSString* pwd = [rootPwd length]?rootPwd:@"\n";
		[aSequence addTask:[resourcePath stringByAppendingPathComponent:@"loginScript"] 
				 arguments:[NSArray arrayWithObjects:@"root",pwd,IPNumber,scriptRunPath,nil]];
		
		[aSequence launch];
	}
}

- (NSString*) driverScriptName 
{
	if([delegate respondsToSelector:@selector(driverScriptName)]){
		return [delegate driverScriptName];
	}
	else return @"";
}

- (NSString*) driverScriptInfo 
{
	if([delegate respondsToSelector:@selector(driverScriptInfo)]){
		return [delegate driverScriptInfo];
	}
	else return @"";
}

- (int) loadMode
{
    return loadMode;
}

- (void) setLoadMode:(int)aLoadMode
{
    [[[self undoManager] prepareWithInvocationTarget:self] setLoadMode:loadMode];
    
    loadMode = aLoadMode;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkLoadModeChanged object:self];
}

- (BOOL) initAfterConnect
{
    return initAfterConnect;
}

- (void) setInitAfterConnect:(BOOL)aInitAfterConnect
{
    [[[self undoManager] prepareWithInvocationTarget:self] setInitAfterConnect:initAfterConnect];
    
    initAfterConnect = aInitAfterConnect;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkInitAfterConnectChanged object:self];
}

- (BOOL) tryingToStartCrate
{
	return tryingTostartCrate;
}

- (void) setTryingToStartCrate:(BOOL)flag
{
	tryingTostartCrate = flag;
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkTryingToStartCrateChanged object:self];
	
}

- (BOOL) verbose
{
    return verbose;
}

- (void) setVerbose:(BOOL)flag
{
    [[[self undoManager] prepareWithInvocationTarget:self] setVerbose:verbose];
	
    verbose = flag;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkVerboseChanged object:self];
}


- (BOOL) forceReload
{
    return forceReload;
}

- (void) setForceReload:(BOOL)flag
{
    [[[self undoManager] prepareWithInvocationTarget:self] setForceReload:forceReload];
	
    forceReload = flag;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkForceReloadChanged object:self];
}

- (BOOL) reloading
{
    return reloading;
}

- (void) setReloading:(BOOL)aReloading
{
    reloading = aReloading;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkReloadingChanged object:self];
}

- (BOOL) goScriptFailed
{
    return goScriptFailed;
}

- (void) setGoScriptFailed:(BOOL)aGoScriptFailed
{
    goScriptFailed = aGoScriptFailed;
}	

- (void) setCompilerErrors:(int)aValue
{
    compilerErrors = aValue;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkCompilerErrorsChanged object:self];
}

- (int) compilerErrors
{
	return compilerErrors;
}

- (void) setCompilerWarnings:(int)aValue
{
    compilerWarnings = aValue;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkCompilerWarningsChanged object:self];
}

- (int) compilerWarnings
{
	return compilerWarnings;
}

- (NSDate*) lastQueUpdate
{
	return lastQueUpdate;
}
- (void) setLastQueUpdate:(NSDate*)aDate
{
	[aDate retain];
	[lastQueUpdate release];
	lastQueUpdate = aDate;
}

- (SBC_info_struct) runInfo
{
	return runInfo;
}

- (unsigned long) writeValue
{
    return writeValue;
}

- (void) setWriteValue:(unsigned long)aWriteValue
{
    [[[self undoManager] prepareWithInvocationTarget:self] setWriteValue:writeValue];
    
    writeValue = aWriteValue;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkWriteValueChanged object:self];
}

- (unsigned long) writeAddress
{
    return writeAddress;
}

- (void) setWriteAddress:(unsigned long)aAddress
{
    [[[self undoManager] prepareWithInvocationTarget:self] setWriteAddress:writeAddress];
    
    writeAddress = aAddress;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkWriteAddressChanged object:self];
}

- (NSString*) filePath
{
	if(!filePath)return @"";
    else return filePath;
}

- (void) setFilePath:(NSString*)aPath
{
	if(!aPath)aPath = @"~/Dev/Orca";
    [[[self undoManager] prepareWithInvocationTarget:self] setFilePath:filePath];
    
    [filePath autorelease];
    filePath = [aPath copy];    
	
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkPathChanged object:self];
}

- (NSString*) userName
{
	if(!userName)return @"";
    else return userName;
}

- (void) setUserName:(NSString*)aUserName
{
	if(!aUserName)aUserName = @"";
    [[[self undoManager] prepareWithInvocationTarget:self] setUserName:userName];
    
    [userName autorelease];
    userName = [aUserName copy];    
	
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkUserNameChanged object:self];
}

- (NSString*) passWord
{
	if(!passWord)return @"";
    else return passWord;
}

- (void) setPassWord:(NSString*)aPassWord
{
	if(!aPassWord)aPassWord = @"";
    [[[self undoManager] prepareWithInvocationTarget:self] setPassWord:passWord];
    
    [passWord autorelease];
    passWord = [aPassWord copy];    
	
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkPassWordChanged object:self];
}

- (int) portNumber
{
	if(portNumber ==0)portNumber = 44667;
    return portNumber;
}

- (BOOL) isConnected
{
	return isConnected;
}

- (void) setIsConnected:(BOOL)aNewIsConnected
{
	isConnected = aNewIsConnected;
	[[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkConnectionChanged  object: self];
	if(isConnected && connectionDroppedAlarm){
        [connectionDroppedAlarm clearAlarm];
        [connectionDroppedAlarm release];
        connectionDroppedAlarm = nil;
    }
	[self setTimeConnected:isConnected?[NSDate date]:nil];
}

- (NSDate*) timeConnected
{
	return timeConnected;
}

- (void) setTimeConnected:(NSDate*)newTimeConnected
{
	[timeConnected autorelease];
	timeConnected=[newTimeConnected retain];	
	[[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkTimeConnectedChanged object:self];
}

- (void) setPortNumber:(int)aPort
{
	if(aPort == 0) aPort = 44667; //default
    [[[self undoManager] prepareWithInvocationTarget:self] setPortNumber:portNumber];
    
    portNumber = aPort;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkPortChanged object:self];
}

- (NSString*) IPNumber
{
	if(!IPNumber)return @"";
    return IPNumber;
}

- (void) setIPNumber:(NSString*)aIPNumber
{
	if([aIPNumber length]){
		
		[[[self undoManager] prepareWithInvocationTarget:self] setIPNumber:IPNumber];
		
		[IPNumber autorelease];
		IPNumber = [aIPNumber copy];    
		
		if(!connectionHistory)connectionHistory = [[NSMutableArray alloc] init];
		if(![connectionHistory containsObject:IPNumber]){
			[connectionHistory addObject:IPNumber];
		}
		ipNumberIndex = [connectionHistory indexOfObject:aIPNumber];
			
		[[NSUserDefaults standardUserDefaults] setObject:connectionHistory forKey:[NSString stringWithFormat:@"orca.%@.%d.ConnectionHistory",[self className],[self slot]]];
		[[NSUserDefaults standardUserDefaults] setInteger:ipNumberIndex forKey:[NSString stringWithFormat:@"orca.%@.%d.IPNumberIndex",[self className],[self slot]]];
		[[NSUserDefaults standardUserDefaults] synchronize];
		[[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkIPNumberChanged object:self];
	}
}

- (void) clearRates
{
    bytesReceived = 0;
    bytesSent = 0;
    lastErrorCount = 0;
    errorRate = 0;
    [lastRateUpdate release];
    lastRateUpdate = nil;
    [self setByteRateSent: 0];
    [self setByteRateReceived: 0];
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkByteRateChanged object:self];
}

- (void) calculateRates
{
    NSDate* now = [NSDate date];
     if(lastRateUpdate){
        NSTimeInterval deltaTime = [now timeIntervalSinceDate:lastRateUpdate];
        if(deltaTime>0){
            [self setByteRateSent: bytesSent/deltaTime];
            [self setByteRateReceived: bytesReceived/deltaTime];
            bytesReceived   = 0;
            bytesSent       = 0;
            
            
            if(runInfo.err_count>=lastErrorCount){
                errorRate       = (runInfo.err_count - lastErrorCount)    /deltaTime;
                [self checkErrorRates];
            }
            lastErrorCount  = runInfo.err_count;

            [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkByteRateChanged object:self];
        }
    }
    [lastRateUpdate release];
    lastRateUpdate = [now retain];
}

- (void) checkErrorRates
{
    if(errorRate > kSBCMaxErrorRate){
        if(!errorsAlarm){
            errorsAlarm = [[ORAlarm alloc] initWithName:[NSString stringWithFormat:@"%@ errorRate High",[delegate fullID]] severity:kHardwareAlarm];
            [errorsAlarm setSticky:NO];
            [errorsAlarm setHelpString:[NSString stringWithFormat:@"%@ is posting errors at a high rate. Something is seriously wrong with the hardware. This alarm will not go away until it is acknowledged and the error rate is zero.",[delegate fullID]]];
        }
        if(![errorsAlarm isPosted]){
            [errorsAlarm setAcknowledged:NO];
            [errorsAlarm postAlarm];
        }
    }
}

- (void) setByteRateSent:(float)aRate
{    
	byteRateSent = aRate;
}

- (float)byteRateSent
{
	return byteRateSent;
}

- (void) setByteRateReceived:(float)aRate
{    
	byteRateReceived = aRate;
}

- (float)byteRateReceived
{
	return byteRateReceived;
}

- (unsigned short) range
{
    return range;
}

- (void) setRange:(unsigned short)aRange
{
    [[[self undoManager] prepareWithInvocationTarget:self] setRange:range];
    
    range = aRange;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkRangeChanged object:self];
}

- (BOOL) doRange
{
    return doRange;
}

- (void) setDoRange:(BOOL)aDoRange
{
    [[[self undoManager] prepareWithInvocationTarget:self] setDoRange:doRange];
    
    doRange = aDoRange;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkDoRangeChanged object:self];
}


- (unsigned int) readWriteType
{
    return readWriteType;
}

- (void) setReadWriteType:(unsigned int)aValue
{
    [[[self undoManager] prepareWithInvocationTarget:self] setReadWriteType:readWriteType];
    readWriteType = aValue;
    [[NSNotificationCenter defaultCenter]
	 postNotificationName:SBC_LinkRWTypeChanged
	 object:self];
}

- (unsigned long) addressModifier
{
    return addressModifier;
}

- (void) setAddressModifier:(unsigned long)aValue
{
	if(aValue == 0)aValue = 0x29; //default
    [[[self undoManager] prepareWithInvocationTarget:self] setAddressModifier:addressModifier];
    addressModifier = aValue;
    [[NSNotificationCenter defaultCenter]
	 postNotificationName:SBC_LinkAddressModifierChanged
	 object:self];
}

- (ORSBCLinkJobStatus*) jobStatus
{
	return jobStatus;
}

- (void) setJobStatus:(ORSBCLinkJobStatus*)theJobStatus
{
	[theJobStatus retain];
	[jobStatus release];
	jobStatus = theJobStatus;
	
	[[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkJobStatus 
														object:jobDelegate 
													  userInfo:[NSDictionary dictionaryWithObject:jobStatus forKey:@"jobStatus"]];
	
}

#pragma mark ***Archival
- (id) initWithCoder:(NSCoder*)decoder
{
	self = [super init];
	[[self undoManager] disableUndoRegistration];
	
	[self initConnectionHistory];
	
	int num = [decoder decodeIntForKey:   @"numTestPoints"];
	if(num == 0) [self setNumTestPoints:20];
	else [self setNumTestPoints:num];
	
	long lnum = [decoder decodeInt32ForKey:  @"payloadSize"];
	if(lnum==0)[self setPayloadSize:65000];
	else [self setPayloadSize:lnum];


	[self setInfoType:		[decoder decodeIntForKey:   @"infoType"]];
	[self setLoadMode:		[decoder decodeIntForKey:   @"loadMode"]];
    [self setInitAfterConnect:[decoder decodeBoolForKey:@"InitAfterConnect"]];
    [self setDisableThrottle:[decoder decodeBoolForKey: @"disableThrottle"]];
	[self setWriteValue:	[decoder decodeInt32ForKey: @"WriteValue"]];
	[self setWriteAddress:	[decoder decodeInt32ForKey: @"WriteAddress"]];
	[self setFilePath:		[decoder decodeObjectForKey:@"FilePath"]];
	[self setUserName:		[decoder decodeObjectForKey:@"UserName"]];
	[self setPassWord:		[decoder decodeObjectForKey:@"PassWord"]];
	[self setPortNumber:	[decoder decodeIntForKey:   @"PortNumber"]];
	[self setIPNumber:		[decoder decodeObjectForKey:@"IPNumber"]];
	[self setVerbose:		[decoder decodeBoolForKey:	@"Verbose"]];
	[self setForceReload:	[decoder decodeBoolForKey:	@"ForceReload"]];
    [self setRange:			[decoder decodeIntForKey:	@"Range"]];
    [self setDoRange:		[decoder decodeBoolForKey:	@"DoRange"]];
    [self setReadWriteType: [decoder decodeIntForKey:   @"ReadWriteType"]];	
    [self setAddressModifier: [decoder decodeIntForKey: @"addressModifier"]];	
    [self setErrorTimeOut:  [decoder decodeIntForKey:   @"errorTimeOut"]];
    [self setSbcPollingRate:  [decoder decodeIntForKey: @"sbcPollingRate"]];
	
	socketLock = [[NSLock alloc] init];
	
	exitCBTest    = YES;
	cbTestRunning = NO;
    
	[[self undoManager] enableUndoRegistration];
	return self;
}

- (void) encodeWithCoder:(NSCoder*)encoder
{
    [encoder encodeBool:disableThrottle    forKey:@"disableThrottle"];
    [encoder encodeInt32:payloadSize    forKey:@"payloadSize"];
    [encoder encodeInt:numTestPoints	forKey:@"numTestPoints"];
    [encoder encodeInt:infoType			forKey:@"infoType"];
    [encoder encodeInt:range			forKey:@"Range"];
    [encoder encodeBool:doRange			forKey:@"DoRange"];
	[encoder encodeInt:loadMode			forKey:@"loadMode"];
	[encoder encodeBool:initAfterConnect forKey:@"InitAfterConnect"];
	[encoder encodeInt32:writeValue		forKey:@"WriteValue"];
	[encoder encodeInt32:writeAddress	forKey:@"WriteAddress"];
	[encoder encodeObject:filePath		forKey:@"FilePath"];
	[encoder encodeObject:userName		forKey:@"UserName"];
	[encoder encodeObject:passWord		forKey:@"PassWord"];
	[encoder encodeInt:portNumber		forKey:@"PortNumber"];
	[encoder encodeObject:IPNumber		forKey:@"IPNumber"];
	[encoder encodeBool:verbose			forKey:@"Verbose"];
	[encoder encodeBool:forceReload		forKey:@"ForceReload"];
    [encoder encodeInt:readWriteType    forKey:@"ReadWriteType"];
    [encoder encodeInt:addressModifier  forKey:@"addressModifier"];
    [encoder encodeInt:errorTimeOut     forKey:@"errorTimeOut"];
    [encoder encodeInt:sbcPollingRate   forKey:@"sbcPollingRate"];
    
}


- (void) fileMoverIsDone:(NSNotification*)aNote
{
	if([aNote object] == SBCFileMover){
		[[NSNotificationCenter defaultCenter] removeObserver : self
													 name : ORFileMoverIsDoneNotification
												   object : SBCFileMover];
		if ([[SBCFileMover task] terminationStatus] == 0) {
            NSLog(@"Transferred Core SBC Code: %@ to %@\n",[SBCFileMover fileName],[SBCFileMover remoteHost]);

            NSString* folder = [mainStagingFolder stringByExpandingTildeInPath];
            [[NSFileManager defaultManager] removeItemAtPath:folder error:nil];
        } else {
            NSLogColor([NSColor redColor], @"Failed to transfer SBC Code to %@\n",[SBCFileMover remoteHost]);
        }
        [SBCFileMover release];
        SBCFileMover  = nil;
        [mainStagingFolder release];
        mainStagingFolder= nil;
	}
	
	else if([aNote object] == driverScriptFileMover){
		[[NSNotificationCenter defaultCenter] removeObserver : self
														name : ORFileMoverIsDoneNotification
													  object : driverScriptFileMover];
		if ([[driverScriptFileMover task] terminationStatus] == 0) {
            NSLog(@"Transferred Driver Update Script: %@ to %@\n",[driverScriptFileMover fileName],[driverScriptFileMover remoteHost]);
        } else {
            NSLogColor([NSColor redColor], @"Failed to transfer Driver update script to %@\n",
                       [driverScriptFileMover remoteHost]);
        }
		[driverScriptFileMover release];
		driverScriptFileMover  = nil;
	}
}

- (void) tasksCompleted:(id)sender
{
	if(reloading){
		NSString* aCrateName = [self crateName];
		NSLog(@"%@  %d: reload processing done\n",aCrateName,[delegate crateNumber]);
		[self setReloading:NO];
        if(permissionDenied){
            NSLogColor([NSColor redColor], @"Could not log in\n");
        }
        else if ([sender sawErrors]) {
            NSLogColor([NSColor redColor], @"%@: %d Errors were seen during tasks\n",aCrateName,[delegate crateNumber]);
		}
        else if(compilerErrors == 0 && compilerWarnings == 0){
			NSLog(@"%@: %d loaded and compiled without errors\n",aCrateName,[delegate crateNumber]);
		}
		else if(compilerErrors){
			NSLogColor([NSColor redColor],@"%@: %d didn't compile\n",aCrateName,[delegate crateNumber]);
		}
		else if(compilerWarnings){
			NSLogColor([NSColor redColor],@"%@: %d compiled with %d warnings\n",aCrateName,[self compilerWarnings],[delegate crateNumber]);
		}
		[self setCompilerErrors:0];
		[self setCompilerWarnings:0];
		
		[self performSelector:@selector(startCrateCode) withObject:self afterDelay:0];
	}
}

- (void) getRunInfoBlock
{
	id pw = [[SBCPacketWrapper alloc] init];
	SBC_Packet* aPacket = [pw sbcPacket];
	aPacket->cmdHeader.destination			= kSBC_Process;
	aPacket->cmdHeader.cmdID                = kSBC_RunInfoRequest;
	aPacket->cmdHeader.numberBytesinPayload	= 0;
	
	[self send:aPacket receive:aPacket];
	
	memcpy(&runInfo,aPacket->payload,sizeof(SBC_info_struct));
	[pw releaseAndCache];
	
	[[NSNotificationCenter defaultCenter] postNotificationOnMainThreadWithName:SBC_LinkRunInfoChanged object:self];
}

- (void) getErrorInfoBlock
{
    id pw = [[SBCPacketWrapper alloc] init];
    SBC_Packet* aPacket = [pw sbcPacket];
    aPacket->cmdHeader.destination			= kSBC_Process;
    aPacket->cmdHeader.cmdID                = kSBC_ErrorInfoRequest;
    aPacket->cmdHeader.numberBytesinPayload	= 0;
    
    [self send:aPacket receive:aPacket];
    
    memcpy(&errorInfo,aPacket->payload,sizeof(SBC_error_struct));
    [pw releaseAndCache];
    
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkErrorInfoChanged object:self];
}
- (NSString*) sbcMacAddress
{
    if([sbcMacAddress length])return sbcMacAddress;
    else return @"?";
}

- (void) getMacAddress
{
    if([sbcMacAddress length] == 0){

        id pw = [[SBCPacketWrapper alloc] init];
        SBC_Packet* aPacket = [pw sbcPacket];
        aPacket->cmdHeader.destination			= kSBC_Process;
        aPacket->cmdHeader.cmdID                = kSBC_MacAddressRequest;
        aPacket->cmdHeader.numberBytesinPayload	= 0;
        @try {
            [self send:aPacket receive:aPacket];
            unsigned char* mac = (unsigned char*)aPacket->payload;
            
            [sbcMacAddress autorelease];
            sbcMacAddress = [[NSString alloc] initWithFormat:@"%02x:%02x:%02x:%02x:%02x:%02x",mac[0],mac[1],mac[2],mac[3],mac[4],mac[5]];
        }
        @catch (NSException* e){
            
        }
        [pw releaseAndCache];
        
        [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkMacAddressChanged object:self];
    }
}


- (unsigned long) totalErrorCount
{
    return runInfo.err_count + runInfo.busErrorCount;
}

- (unsigned long) throttle
{
	return throttle;
}

- (BOOL) disableThrottle
{
    return disableThrottle;
}

- (void) setDisableThrottle:(BOOL) aFlag
{
    [[[self undoManager] prepareWithInvocationTarget:self] setDisableThrottle:disableThrottle];
    disableThrottle = aFlag;
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkSbcDisableThrottleChanged object:self];
}

- (unsigned long) sbcPollingRate
{
    return sbcPollingRate;
}
- (void) setSbcPollingRate:(unsigned long)aValue
{
    [[[self undoManager] prepareWithInvocationTarget:self] setSbcPollingRate:sbcPollingRate];
    sbcPollingRate = aValue;
  	[[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkSbcPollingRateChanged object:self];
  
}


- (void) reloadClient
{
	[self setReloading:YES];
	[self setCompilerErrors:0];
	[self setCompilerWarnings:0];
	//this loads an entire copy of the client code onto the remote server and does a make.
	//it does NOT start the code
    if(portNumber){
		@try {
			[self stopCrate];
		}
		@catch (NSException* localException) {
			NSLog(@"Could not stop crate ... Probably already stopped\n");
		}
		NSLog(@"Core code for crate reload starting\n");
		
		//get the core and hw specific paths
		NSString* resourcePath = [[NSBundle mainBundle] resourcePath];
		
		NSString* coreCodePath;
		if(loadMode) coreCodePath = [filePath stringByAppendingPathComponent:@"Source/Objects/Hardware/SBC/SBC_Code"];
		else		 coreCodePath = [resourcePath stringByAppendingPathComponent:@"SBC_Code"];
		
		NSString* hwSpecificCodePath;
		if(loadMode)hwSpecificCodePath = [filePath stringByAppendingPathComponent:[delegate sbcLocalCodePath]];
		else hwSpecificCodePath = [resourcePath stringByAppendingPathComponent:[delegate codeResourcePath]];
		
		//make a staging area
		NSString* stagingFolder = [[ApplicationSupport sharedApplicationSupport] applicationSupportFolder:@"Staging"];
        [[NSFileManager defaultManager] removeItemAtPath:stagingFolder error:nil];
        [mainStagingFolder release];
        mainStagingFolder = [[NSFileManager tempPathForFolder:stagingFolder usingTemplate:[[hwSpecificCodePath lastPathComponent] stringByAppendingString:@"_XXX"]] retain];
        
		NSFileManager* fm = [NSFileManager defaultManager];
		[fm createDirectoryAtPath:mainStagingFolder withIntermediateDirectories:YES attributes:nil error:nil];
		
		//copy all files to the staging area
		NSString* srcFolder        = [hwSpecificCodePath stringByExpandingTildeInPath];
		NSArray* filesToStage      = [fm contentsOfDirectoryAtPath:srcFolder error:nil];
		NSString* driverScriptFile = [delegate driverScriptName];
		
		for(id aFile in filesToStage){
			if(![aFile isEqual:@".svn"] && ![aFile isEqual:driverScriptFile]){
				NSString* srcFile = [srcFolder stringByAppendingPathComponent:aFile];
				NSString* desFile = [mainStagingFolder stringByAppendingPathComponent:aFile];
				[fm copyItemAtPath:srcFile toPath:desFile error:nil];
			}
		}
		
		srcFolder    = [coreCodePath stringByExpandingTildeInPath];
		filesToStage = [fm contentsOfDirectoryAtPath:srcFolder error:nil];
		for(id aFile in filesToStage){
			if(![aFile isEqual:@".svn"]){
				NSString* srcFile = [srcFolder stringByAppendingPathComponent:aFile];
				NSString* desFile = [mainStagingFolder stringByAppendingPathComponent:aFile];
				[fm copyItemAtPath:srcFile toPath:desFile error:nil];
			}
		}
		//edit the scripts
		[self fillInScript:@"makeScript"];
		[self fillInScript:@"goScript"];
				 
        NSString* pwd = [passWord length]?passWord:@"\n";
		//ship the files from the staging area
		ORTaskSequence* aSequence = [ORTaskSequence taskSequenceWithDelegate:self];
		[aSequence setVerbose:verbose];
		[aSequence addTask:[resourcePath stringByAppendingPathComponent:@"loginScript"] 
				 arguments:[NSArray arrayWithObjects:userName,pwd,IPNumber,@"/bin/rm",@"-rf",@"ORCA",nil]];
		[aSequence setTextToDelegate:YES];
		
		SBCFileMover = [[ORFileMover alloc] init];
		[SBCFileMover doNotUseTempFile];
		[SBCFileMover setDelegate:aSequence];
		[SBCFileMover setMoveParams:[mainStagingFolder stringByExpandingTildeInPath]
									 to:@"ORCA" 
							 remoteHost:IPNumber 
							   userName:userName 
							   passWord:passWord];
		[SBCFileMover setVerbose:verbose];//TODO: was NO; for testing I would like to see this output; this takes the CB state from the GUI -tb-
		[SBCFileMover doNotMoveFilesToSentFolder];
		[SBCFileMover setTransferType:eUseSCP];
		[aSequence addTaskObj:SBCFileMover];

		//since we made the task sequence the filemover's delegate, 
		//we have to use the notification to know when the mover is done
		[[NSNotificationCenter defaultCenter] addObserver : self
						 selector : @selector(fileMoverIsDone:)
							 name : ORFileMoverIsDoneNotification
						   object : SBCFileMover];
		
		[aSequence addTask:[resourcePath stringByAppendingPathComponent:@"loginScript"] 
				 arguments:[NSArray arrayWithObjects:userName,pwd,IPNumber,@"~/ORCA/makeScript",nil]];
		
		[aSequence launch];
	}
}

- (void) killCrate
{
	@try {
		startCrateState = kDone;
		[[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkCrateStartStatusChanged object:self];
		[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(startCrateProcess) object:nil];
		[self stopCrate];
	}
	@catch (NSException* localException) {
	}
		
	NSString* resourcePath = [[NSBundle mainBundle] resourcePath];
	ORTaskSequence* aSequence = [ORTaskSequence taskSequenceWithDelegate:self];
    
    NSString* pwd = [passWord length]?passWord:@"\n";

	[aSequence addTask:[resourcePath stringByAppendingPathComponent:@"loginScript"] 
			 arguments:[NSArray arrayWithObjects:userName,pwd,IPNumber,@"~/ORCA/killScript",nil]];
	
	[aSequence setVerbose:verbose];
	[aSequence setTextToDelegate:YES];
	
	[aSequence launch];
}


- (void) taskFinished:(ORPingTask*)aTask
{
	if(aTask == pingTask){
		[pingTask release];
		pingTask = nil;
		[[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkPingTask object:self];
	}
}

- (void) taskData:(NSDictionary*)taskData
{
    id       aTask = [taskData objectForKey:@"Task"];
    NSString* text = [taskData objectForKey:@"Text"];
    if(aTask != pingTask){
        //NSLog(@"%@\n",text);
        if([text rangeOfString:@"error:"].location!=NSNotFound){
            [self setCompilerErrors:compilerErrors+1];
            NSLogColor([NSColor redColor], @"%@\n",text);
        }
        else if([text rangeOfString:@"Permission denied"].location!= NSNotFound){
            permissionDenied = YES;
        }
        else if([text rangeOfString:@"warning"].location!=NSNotFound){
            [self setCompilerWarnings:compilerWarnings+1];
            NSLogColor([NSColor redColor], @"%@\n",text);
        }
        else if([text rangeOfString:@"goScript:"].location != NSNotFound){
            [self setGoScriptFailed:YES];
            NSLogColor([NSColor redColor], @"%@\n",text);
        }
    }
    else {
        if([text rangeOfString:@" 0.0% packet loss"].location != NSNotFound){
            pingedSuccessfully = YES;
        }
        else if([text rangeOfString:@"100.0% packet loss"].location != NSNotFound){
            [self disconnectFromPingFailure];
        }
        else if([text rangeOfString:@"Host is down"].location != NSNotFound){
            [self disconnectFromPingFailure];
        }
        else if([text rangeOfString:@"No route to host"].location != NSNotFound){
            [self disconnectFromPingFailure];
        }
    }
}

- (void) disconnectFromPingFailure
{
    if([self isConnected]){
        [self disconnect];
        [self sbcConnectionDropped];
        [[NSNotificationCenter defaultCenter] postNotificationOnMainThreadWithName:SBC_SocketDroppedUnexpectedly  object:self];
    }
}

- (BOOL) pingInProgress
{
    return pingTask!=nil;
}

- (BOOL)pingedSuccessfully
{
    return pingedSuccessfully;
}

- (void) toggleCrate
{
	if([self isConnected]){
		@try {
			[self stopCrate];
		}
		@catch (NSException* localException) {
			[self disconnect];
		}
	}
	else {
		[self setTryingToStartCrate:YES];
//		if(forceReload){
//			startCrateState = kReloadCode;
//		}
//		else {
            permissionDenied = NO;
			startCrateState = kPing;
//		}
		[self performSelector:@selector(startCrateProcess) withObject:self afterDelay:0];
	}
}

- (void) startCrate
{
	if(!tryingTostartCrate){		
		[self setTryingToStartCrate:YES];
        permissionDenied = NO;
		startCrateState = kPing;
		[self performSelector:@selector(startCrateProcess) withObject:self afterDelay:0];
	}
}

- (void) stopCrate
{
	SBC_CmdOptionStruct optionBlock;
	int i;
	for(i=0;i<kMaxOptions;i++){
		//future run options could be added here.
		optionBlock.option[i]	= 0;
	}
	[self sendCommand:kSBC_Exit withOptions:&optionBlock  expectResponse:NO];
	[self disconnect];
}

- (void) startCrateCode
{
	[self setGoScriptFailed:NO];
	NSString* resourcePath = [[NSBundle mainBundle] resourcePath];
	ORTaskSequence* aSequence = [ORTaskSequence taskSequenceWithDelegate:self];
    NSString* pwd = [passWord length]?passWord:@"\n";
	[aSequence addTask:[resourcePath stringByAppendingPathComponent:@"loginScript"] 
			 arguments:[NSArray arrayWithObjects:userName,pwd,IPNumber,@"~/ORCA/goScript",nil]];

	[aSequence setVerbose:verbose];
	[aSequence setTextToDelegate:YES];
	
	[aSequence launch];
}

- (void) shutDown:(NSString*)rootPwd reboot:(BOOL)reboot
{
	[self disconnect];
	[self setGoScriptFailed:NO];
	NSString* resourcePath = [[NSBundle mainBundle] resourcePath];
	ORTaskSequence* aSequence = [ORTaskSequence taskSequenceWithDelegate:self];
    NSString* pwd = [rootPwd length]?rootPwd:@"\n";
	if(reboot){
		[aSequence addTask:[resourcePath stringByAppendingPathComponent:@"loginScript"] 
				 arguments:[NSArray arrayWithObjects:@"root",pwd,IPNumber,@"shutdown",@"-r",@"now",nil]];
	}
	else {
		[aSequence addTask:[resourcePath stringByAppendingPathComponent:@"loginScript"] 
				 arguments:[NSArray arrayWithObjects:@"root",pwd,IPNumber,@"shutdown",@"-h",@"now",nil]];
	}
	[aSequence setVerbose:verbose];
	[aSequence setTextToDelegate:YES];
	
	[aSequence launch];
	
}

- (void) tellClientToStartRun
{
	
	[self sendPayloadSize:65000];
	
	SBC_CmdOptionStruct optionBlock;
	int i;
	for(i=0;i<kMaxOptions;i++){
		//future run options could be added here.
		optionBlock.option[i]	= 0;
	}
	
    optionBlock.option[0]	= sbcPollingRate;
	[self sendCommand:kSBC_SetPollingDelay withOptions:&optionBlock expectResponse:YES];
    if(optionBlock.option[0] == 0){
        NSLog(@"SBC,%d,%d polling at fastest rate\n",[delegate crateNumber],[delegate slot]);
    }
    else {
        NSLog(@"SBC,%d,%d polling at ~%luHz\n",[delegate crateNumber],[delegate slot],optionBlock.option[0]);
    }
    
    optionBlock.option[0]	= 0;//reset the option block
	[self sendCommand:kSBC_StartRun withOptions:&optionBlock expectResponse:YES];
	
	if(optionBlock.option[0] == 1){
		isRunning = YES;
	}
	else {
		isRunning = NO;
		[NSException raise:@"Run Didn't Start" format:@"%@ failed to start run",[self crateName]];	
	}
}

- (void) tellClientToStopRun
{
	SBC_CmdOptionStruct optionBlock;
	int i;
	for(i=0;i<kMaxOptions;i++){
		//future run options could be added here.
		optionBlock.option[i]	= 0;
	}
	
	[self sendCommand:kSBC_StopRun withOptions:&optionBlock expectResponse:YES];
	
	if(optionBlock.option[0] == 0){
		isRunning = NO;
	}
	else {
		[NSException raise:@"Run Didn't Stop" format:@"%@ failed to stop run",[self crateName]];	
	}
}

- (void) pauseRun
{
	SBC_CmdOptionStruct optionBlock;
	int i;
	for(i=0;i<kMaxOptions;i++){
		//future pause options could be added here.
		optionBlock.option[i]	= 0;
	}
	
	[self sendCommand:kSBC_PauseRun withOptions:&optionBlock expectResponse:YES];
	
	if(optionBlock.option[0] == 0){
	}
	else {
		[NSException raise:@"Run Didn't Pause" format:@"%@ failed to pause run",[self crateName]];	
	}
}

- (void) setPollingDelay:(unsigned long)numMicroseconds
{
	SBC_CmdOptionStruct optionBlock;
	int i;
	for(i=0;i<kMaxOptions;i++){
		//future pause options could be added here.
		optionBlock.option[i]	= 0;
	}
    optionBlock.option[0]	= numMicroseconds;

	[self sendCommand:kSBC_SetPollingDelay withOptions:&optionBlock expectResponse:NO];
}


- (void) resumeRun
{
	SBC_CmdOptionStruct optionBlock;
	int i;
	for(i=0;i<kMaxOptions;i++){
		//future pause options could be added here.
		optionBlock.option[i]	= 0;
	}
	
	[self sendCommand:kSBC_ResumeRun withOptions:&optionBlock expectResponse:YES];
	
	if(optionBlock.option[0] == 0){
	}
	else {
		[NSException raise:@"Run Didn't Resume" format:@"%@ failed to resume run",[self crateName]];	
	}
}

- (void) sendCommand:(long)aCmd withOptions:(SBC_CmdOptionStruct*)optionBlock expectResponse:(BOOL)askForResponse
{
	id pw = [[SBCPacketWrapper alloc] init];
	SBC_Packet* aPacket = [pw sbcPacket];
	
	aPacket->cmdHeader.destination		= kSBC_Process;
	aPacket->cmdHeader.cmdID			= aCmd;
	aPacket->cmdHeader.numberBytesinPayload	= sizeof(SBC_CmdOptionStruct);
	memcpy(aPacket->payload,optionBlock,sizeof(SBC_CmdOptionStruct));
	
	@try {
		[socketLock lock]; //begin critical section
		[self write:socketfd buffer:aPacket];
		
		if(askForResponse){
			//get the response....
			[self read:socketfd buffer:aPacket];
			SBC_CmdOptionStruct* optionPtr = (SBC_CmdOptionStruct*)aPacket->payload;
			int i;
			for(i=0;i<kMaxOptions;i++){
				optionBlock->option[i] = optionPtr->option[i];
			}
		}
		[socketLock unlock]; //end critical section
		
	}
	@catch (NSException* localException) {
		[socketLock unlock]; //end critical section
		[localException raise];
	} @finally {
        [pw releaseAndCache];
    }
	
}

- (void) writeLongBlock:(long*) buffer
			  atAddress:(unsigned long) anAddress
			 numToWrite:(unsigned int)  numberLongs
{
    id pw = [[SBCPacketWrapper alloc] init];    
	@try {
		[socketLock lock]; //begin critical section
		SBC_Packet* aPacket = [pw sbcPacket];
		aPacket->cmdHeader.destination			= kSBC_Process;
		aPacket->cmdHeader.cmdID				= kSBC_WriteBlock;
		aPacket->cmdHeader.numberBytesinPayload	= sizeof(SBC_WriteBlockStruct) + numberLongs*sizeof(long);
		
		SBC_WriteBlockStruct* writeBlockPtr = (SBC_WriteBlockStruct*)aPacket->payload;
		writeBlockPtr->address		= anAddress;
		writeBlockPtr->numLongs		= numberLongs;
		writeBlockPtr++;
		memcpy(writeBlockPtr,buffer,numberLongs*sizeof(long));
		
		[self write:socketfd buffer:aPacket];
		[socketLock unlock]; //end critical section
	}
	@catch (NSException* localException) {
		[socketLock unlock]; //end critical section
		[localException raise];
	} @finally {
        [pw releaseAndCache];
    }
}


- (void) readLongBlock:(long*) buffer
			 atAddress:(unsigned long) anAddress
			 numToRead:(unsigned int) numberLongs
{
    id pw = [[SBCPacketWrapper alloc] init];    
	@try {
		[socketLock lock]; //begin critical section
		SBC_Packet* aPacket = [pw sbcPacket];
		aPacket->cmdHeader.destination			= kSBC_Process;
		aPacket->cmdHeader.cmdID				= kSBC_ReadBlock;
		aPacket->cmdHeader.numberBytesinPayload	= sizeof(SBC_ReadBlockStruct);
		
		SBC_ReadBlockStruct* readBlockPtr = (SBC_ReadBlockStruct*)aPacket->payload;
		readBlockPtr->address		= anAddress;
		readBlockPtr->numLongs		= numberLongs;
		
		//Do NOT call the combo send:receive method here... we have the locks already in place
		[self write:socketfd buffer:aPacket]; //write the packet
		[self read:socketfd buffer:aPacket]; //read the response
		
		SBC_ReadBlockStruct* rp = (SBC_ReadBlockStruct*)aPacket->payload;
		int numLongs = rp->numLongs;
		rp++;
		long* dp = (long*)rp;
		int i;
		for(i=0;i<numLongs;i++){
			buffer[i] = dp[i];
		}
		[socketLock unlock]; //end critical section
	}
	@catch (NSException* localException) {
		[socketLock unlock]; //end critical section
		[localException raise];
	} @finally {
        [pw releaseAndCache];
    }
}


- (void) _readBlock:(void *) buffer
          atAddress:(unsigned int) aVmeAddress
           numBytes:(unsigned int) numberBytes
         withAddMod:(unsigned short) anAddressModifier
      usingAddSpace:(unsigned short) anAddressSpace
       withUnitSize:(unsigned short) unitSize
{
    assert(numberBytes % unitSize == 0);
    id pw = [[SBCPacketWrapper alloc] init];    
	@try {
		[socketLock lock]; //begin critical section
		SBC_Packet* aPacket = [pw sbcPacket];
		aPacket->cmdHeader.destination			= kSBC_Process;
		aPacket->cmdHeader.cmdID				= kSBC_ReadBlock;
		aPacket->cmdHeader.numberBytesinPayload	= sizeof(SBC_VmeReadBlockStruct);
		
		SBC_VmeReadBlockStruct* readBlockPtr = (SBC_VmeReadBlockStruct*)aPacket->payload;
		readBlockPtr->address			= aVmeAddress;
		readBlockPtr->addressModifier	= anAddressModifier;
		readBlockPtr->addressSpace		= anAddressSpace;
		readBlockPtr->unitSize			= unitSize;
		readBlockPtr->numItems			= numberBytes/unitSize;
		
		//Do NOT call the combo send:receive method here... we have the locks already in place
		[self write:socketfd buffer:aPacket]; //write the packet
		[self read:socketfd buffer:aPacket];  //read the response
		
		SBC_VmeReadBlockStruct* rp = (SBC_VmeReadBlockStruct*)aPacket->payload;
		if(!rp->errorCode){
			void* dp = (void*)(rp+1);
			memcpy(buffer,dp,numberBytes);
		}
		else [self throwError:rp->errorCode address:aVmeAddress];
		[socketLock unlock]; //end critical section
	}
	@catch (NSException* localException) {
		[socketLock unlock]; //end critical section
		[localException raise];
	}
	@finally {
		[pw releaseAndCache];
	}
}

- (void) readByteBlock:(unsigned char *) buffer
			 atAddress:(unsigned int) aVmeAddress
			 numToRead:(unsigned int) numberBytes
			withAddMod:(unsigned short) anAddressModifier
		 usingAddSpace:(unsigned short) anAddressSpace;
{
    [self _readBlock:buffer
           atAddress:aVmeAddress
            numBytes:numberBytes
          withAddMod:anAddressModifier
       usingAddSpace:anAddressSpace
        withUnitSize:1];
}

- (void) readWordBlock:(unsigned short *) buffer
			 atAddress:(unsigned int) aVmeAddress
			 numToRead:(unsigned int) numberWords
			withAddMod:(unsigned short) anAddressModifier
		 usingAddSpace:(unsigned short) anAddressSpace
{
    [self _readBlock:buffer
           atAddress:aVmeAddress
            numBytes:numberWords*2
          withAddMod:anAddressModifier
       usingAddSpace:anAddressSpace
        withUnitSize:2];
}

- (void) readLongBlock:(unsigned long *) buffer
			 atAddress:(unsigned int) aVmeAddress
			 numToRead:(unsigned int) numberLongs
			withAddMod:(unsigned short) anAddressModifier
		 usingAddSpace:(unsigned short) anAddressSpace
{
    [self _readBlock:buffer
           atAddress:aVmeAddress
            numBytes:numberLongs*4
          withAddMod:anAddressModifier
       usingAddSpace:anAddressSpace
        withUnitSize:4];
}


- (void) _writeBlock:(void *) buffer
           atAddress:(unsigned int) aVmeAddress
            numBytes:(unsigned int) numberBytes
          withAddMod:(unsigned short) anAddressModifier
       usingAddSpace:(unsigned short) anAddressSpace
        withUnitSize:(unsigned short) unitSize
{
    assert(numberBytes % unitSize == 0);
    id pw = [[SBCPacketWrapper alloc] init];    
	@try {
		[socketLock lock]; //begin critical section
		
		SBC_Packet* aPacket = [pw sbcPacket];
		aPacket->cmdHeader.destination			= kSBC_Process;
		aPacket->cmdHeader.cmdID				= kSBC_WriteBlock;
		aPacket->cmdHeader.numberBytesinPayload	= sizeof(SBC_VmeWriteBlockStruct) + numberBytes;
		
		SBC_VmeWriteBlockStruct* writeBlockPtr = (SBC_VmeWriteBlockStruct*)aPacket->payload;
		writeBlockPtr->address			= aVmeAddress;
		writeBlockPtr->addressModifier	= anAddressModifier;
		writeBlockPtr->addressSpace		= anAddressSpace;
		writeBlockPtr->unitSize			= unitSize;
		writeBlockPtr->numItems			= numberBytes/unitSize;
		writeBlockPtr++; //point to the payload
		memcpy(writeBlockPtr,buffer,numberBytes);
		
		//Do NOT call the combo send:receive method here... we have the locks already in place
		[self write:socketfd buffer:aPacket];	//write the packet
		[self read:socketfd buffer:aPacket];		//read the response
		
		SBC_VmeReadBlockStruct* rp = (SBC_VmeReadBlockStruct*)aPacket->payload;
		if(rp->errorCode)[self throwError:rp->errorCode address:aVmeAddress];
		[socketLock unlock]; //end critical section
	}
	@catch (NSException* localException) {
		[socketLock unlock]; //end critical section
		[localException raise];
	}
	@finally {
        [pw releaseAndCache];
	}

}
- (void) writeByteBlock:(unsigned char *) buffer
			  atAddress:(unsigned int) aVmeAddress
			 numToWrite:(unsigned int) numberBytes
			 withAddMod:(unsigned short) anAddressModifier
		  usingAddSpace:(unsigned short) anAddressSpace
{
    [self _writeBlock:buffer
            atAddress:aVmeAddress
             numBytes:numberBytes
           withAddMod:anAddressModifier
        usingAddSpace:anAddressSpace
         withUnitSize:1];
}


- (void) writeWordBlock:(unsigned short *) buffer
			  atAddress:(unsigned int) aVmeAddress
			 numToWrite:(unsigned int) numberWords
			 withAddMod:(unsigned short) anAddressModifier
		  usingAddSpace:(unsigned short) anAddressSpace
{
    [self _writeBlock:buffer
            atAddress:aVmeAddress
             numBytes:numberWords*2
           withAddMod:anAddressModifier
        usingAddSpace:anAddressSpace
         withUnitSize:2];
}

- (void) writeLongBlock:(unsigned long *) buffer
			  atAddress:(unsigned int) aVmeAddress
			 numToWrite:(unsigned int) numberLongs
			 withAddMod:(unsigned short) anAddressModifier
		  usingAddSpace:(unsigned short) anAddressSpace
{
    [self _writeBlock:buffer
            atAddress:aVmeAddress
             numBytes:numberLongs*4
           withAddMod:anAddressModifier
        usingAddSpace:anAddressSpace
         withUnitSize:4];
}


//temp discrete ops
- (void) executeCommandList:(ORCommandList*)aList
{
    id pw = [[SBCPacketWrapper alloc] init];
	@try {
	
        [socketLock lock]; //begin critical section
        
        SBC_Packet* blockPacket = [pw sbcPacket];
        [aList SBCPacket:blockPacket];
		
		//Do NOT call the combo send:receive method here... we have the locks already in place
		[self write:socketfd buffer:blockPacket];	//write the packet
		[self read:socketfd buffer:blockPacket];	//read the response
		
		[aList extractData:blockPacket];
        [socketLock unlock]; //end critical section
        
	}
	@catch (NSException* localException) {
		[socketLock unlock]; //end critical section
		[localException raise];
	}
	@finally {
		[pw releaseAndCache];
	}
}


- (void) send:(SBC_Packet*)aSendPacket receive:(SBC_Packet*)aReceivePacket
{
	@try {
		[socketLock lock]; //begin critial section
		[self write:socketfd buffer:aSendPacket];
		[self read:socketfd buffer:aReceivePacket];
		[socketLock unlock]; //end critial section
	}
	@catch (NSException* localException) {
		[socketLock unlock]; //end critial section
		[localException raise];
	}
}



- (void) update
{
	[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(update) object:nil];
	if(isRunning){
		[self getRunInfoBlock];
        [self calculateRates];
		if(runInfo.readCycles == oldCycleCount){
			if(++missedHeartBeat == 10){
				if(!eCpuDeadAlarm){
					eCpuDeadAlarm = [[ORAlarm alloc] initWithName:@"eCPU appears dead" severity:kHardwareAlarm];
					[eCpuDeadAlarm setSticky:NO];
					[eCpuDeadAlarm setHelpStringFromFile:@"eCPUDeadHelp"];
				}
				if(![eCpuDeadAlarm isPosted]){
					[eCpuDeadAlarm setAcknowledged:NO];
					[eCpuDeadAlarm postAlarm];
				}
			}
		}
		else {
			oldCycleCount = runInfo.readCycles;
		}
		
		
		float percentBufferFilled = 100.*runInfo.amountInBuffer/runInfo.bufferSize;

		if(percentBufferFilled > 30){
			if(!eCpuCBFillingAlarm){
				eCpuCBFillingAlarm = [[ORAlarm alloc] initWithName:@"Data Rate Too High" severity:kDataFlowAlarm];
				[eCpuCBFillingAlarm setSticky:NO];
				[eCpuCBFillingAlarm setHelpString:@"The SBC circular buffer is filling because the data rate is too high. If the buffer fills completely, data will be lost. Reduce the data rate."];
			}
			if(![eCpuCBFillingAlarm isPosted]){
				[eCpuCBFillingAlarm setAcknowledged:NO];
				[eCpuCBFillingAlarm postAlarm];
			}
			
			if (throttle > 0 && percentBufferFilled > kAmountInBufferThreshold) {
				/* Let's try diminishing the throttle */
				throttle -= kShrinkThrottleBy;
                if(throttle<0) throttle=0;
			 }
		}
		if(runInfo.lostByteCount > 0 ){
			if(!eCpuCBLostDataAlarm){
				eCpuCBLostDataAlarm = [[ORAlarm alloc] initWithName:@"Data Rate Too High" severity:kDataFlowAlarm];
				[eCpuCBLostDataAlarm setSticky:YES];
				[eCpuCBLostDataAlarm setHelpString:@"The SBC circular buffer is full and data is being lost. Reduce the data rate."];
			}
			if(![eCpuCBLostDataAlarm isPosted]){
				[eCpuCBLostDataAlarm setAcknowledged:NO];
				[eCpuCBLostDataAlarm postAlarm];
			}
		}
        if(updateCount%120 == 0){
            [self getErrorInfoBlock];
            [self postCouchDBRecord];
        }
        updateCount++;

	}
 
	if(isRunning){
		[self performSelector:@selector(update) withObject:nil afterDelay:.5];
	}
}

- (void) runTaskStarted:(ORDataPacket*)aDataPacket userInfo:(NSDictionary*)userInfo
{
    updateCount=0;
	if([[self orcaObjects] count]){
		//set up the irq thread to watch that socket, but only if there are LAMS defined
		stopWatchingIRQ = NO;
		[NSThread detachNewThreadSelector:@selector(watchIrqSocket) toTarget:self withObject:nil];
	}
	
    [errorsAlarm         clearAlarm];
    
    [eCpuDeadAlarm       clearAlarm];
	[eRunFailedAlarm     clearAlarm];
	[eCpuCBFillingAlarm  clearAlarm];
	[eCpuCBLostDataAlarm clearAlarm];

	throttleCount = 0;
	missedHeartBeat = 0;
    
	if(disableThrottle)throttle = 0;
    else               throttle = 1000;
    
	[self tellClientToStartRun];
    [self clearRates];
    [self update];
}

-(void) takeData:(ORDataPacket*)aDataPacket userInfo:(NSDictionary*)userInfo
{
	//this stuff is socket based, so no need to try to ask for data too often. A larger throttleCount
	//will result in larger sized buffers from the SBC.
	if(++throttleCount>throttle){
		throttleCount = 0;
		id pw = [[SBCPacketWrapper alloc] init];
		SBC_Packet* aPacket = [pw sbcPacket];
		aPacket->cmdHeader.destination	= kSBC_Process;
		aPacket->cmdHeader.cmdID			= kSBC_CBRead;
		aPacket->cmdHeader.numberBytesinPayload = 0;
		[self send:aPacket receive:aPacket];
		
		unsigned long* rp = (unsigned long*)aPacket->payload;
		long numLongs = aPacket->cmdHeader.numberBytesinPayload/sizeof(long);
		if(numLongs>0){
			[aDataPacket addLongsToFrameBuffer:rp length:numLongs];
		}
		[pw releaseAndCache];
	}
}

- (void) runIsStopping:(ORDataPacket*)aDataPacket userInfo:(NSDictionary*)userInfo
{
	@try {
		[self tellClientToStopRun];
		stopWatchingIRQ = YES;
		[self getRunInfoBlock];

		/* We no longer need the throttle since we are just clearing the circular buffer.
		 It will be reset when the run starts.                                           */
		throttle = 0;
		if(runInfo.amountInBuffer > 0){
			lastAmountInBuffer = runInfo.amountInBuffer;
			NSLog(@"%@ %d %d reading out last %d bytes in CB\n",[delegate className],[delegate crateNumber],[delegate slot],runInfo.amountInBuffer);
		}
	}
	@catch (NSException* localException) {
		NSLog(@"%@\n",localException);
	}
}

- (BOOL) doneTakingData
{
	//the remote client has  been told to stop taking data, but there is probably still
	//data in the CB. The run will not actually stop until we return YES from this method.
	[self getRunInfoBlock];

	if(lastAmountInBuffer != runInfo.amountInBuffer){
		//as long as the amount in the buffer is changing, we'll ask for more time.
		[[NSNotificationCenter defaultCenter] postNotificationName: ORNeedMoreTimeToStopRun object:self];
		lastAmountInBuffer = runInfo.amountInBuffer;
	}
	
	return (runInfo.amountInBuffer == 0) && !irqThreadRunning;
}

//SV
- (void) waitForPingTask
{
    if([self pingTaskRunning]){
        [self performSelector:@selector(waitForPingTask) withObject:self afterDelay:5];
    }
}

- (void) runTaskStopped:(ORDataPacket*)aDataPacket userInfo:(NSDictionary*)userInfo
{	
    [self performSelector:@selector(getRunInfoBlock) withObject:self afterDelay:1];
    [self waitForPingTask]; //SV
    [self pingVerbose:NO]; //SV - moved. Used to be before [self clearRates];
    [self getErrorInfoBlock];
    [self reportErrorsByCard];
	[eCpuCBFillingAlarm clearAlarm];
	[eCpuCBLostDataAlarm clearAlarm];
    [self clearRates];
    [self postCouchDBRecord];
}

- (void) reportErrorsByCard
{
    unsigned long busErrorCount = 0;
    unsigned long errorCount    = 0;
    unsigned long messageCount  = 0;
    int slot;
    for(slot=0;slot<MAX_CARDS;slot++){
        busErrorCount     += errorInfo.card[slot].busErrorCount;
        errorCount        += errorInfo.card[slot].errorCount;
        messageCount      += errorInfo.card[slot].messageCount;
    }
    if(messageCount || errorCount || busErrorCount){
        NSLog(@"----------------------------\n");
        NSLog(@"Error Report For Crate %d\n",[delegate crateNumber]);
    
        if(messageCount){
            NSLog(@"------Messages------\n");
            for(slot=0;slot<MAX_CARDS;slot++){
                if(errorInfo.card[slot].messageCount)NSLog(@"slot %d: %d\n",slot, errorInfo.card[slot].messageCount);
            }
        }
        if(errorCount){
            NSLog(@"------Errors------\n");
            for(slot=0;slot<MAX_CARDS;slot++){
                if(errorInfo.card[slot].errorCount)NSLog(@"slot %d: %d\n",slot, errorInfo.card[slot].errorCount);
            }
        }
        if(busErrorCount){
            NSLog(@"------Bus Errors------\n");
            for(slot=0;slot<MAX_CARDS;slot++){
                if(errorInfo.card[slot].busErrorCount)NSLog(@"slot %d: %d\n",slot, errorInfo.card[slot].busErrorCount);
            }
        }
        NSLog(@"----------------------------\n");
    }
    else NSLog(@"No Errors reported for crate %d\n",[delegate crateNumber]);
}

- (void) load_HW_Config:(SBC_crate_config*) aConfig
{	
	id pw = [[SBCPacketWrapper alloc] init];
	SBC_Packet* aPacket = [pw sbcPacket];
	
	aPacket->cmdHeader.destination			= kSBC_Process;
	aPacket->cmdHeader.cmdID					= kSBC_LoadConfig;
	aPacket->cmdHeader.numberBytesinPayload	= sizeof(SBC_crate_config);
	memcpy(aPacket->payload,aConfig,sizeof(SBC_crate_config));
	
	[self write:socketfd buffer:aPacket];	
	[pw releaseAndCache];
}

#pragma mark ***DataSource
- (void) getQueMinValue:(unsigned long*)aMinValue maxValue:(unsigned long*)aMaxValue head:(unsigned long*)aHeadValue tail:(unsigned long*)aTailValue
{
	*aMinValue  = 0;
	*aMaxValue  = runInfo.bufferSize;
	*aHeadValue = runInfo.writeIndex;
	*aTailValue = runInfo.readIndex;
	
}

//--------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------
- (void) connect
{
	if(!socketfd && !irqfd && ([IPNumber length]!=0) && (portNumber!=0)){
		@try {
			//get the socket descriptor for the main com link
			socketfd = [self connectToPort:portNumber];
			
			//send a test word to determine if swapping will be needed. All swapping is handled on the 'other' side.
			long testWord = 0x0000DCBA;
			int bytesWritten = write(socketfd,&testWord,4);
			if(bytesWritten!=4) [NSException raise:@"Test Send Failed" format:@"Couldn't write to %@",IPNumber];
		
			//get the socket descriptor for the interrupt link
			irqfd = [self connectToPort:portNumber+1];
			
			[self setIsConnected: YES];
			[self setTimeConnected:[NSDate date]];
			[self setReloading:NO];
			
			NSLog(@"Connected to %@ <%@> port: %d\n",[self crateName],IPNumber,portNumber);
			[[delegate crate] performSelector:@selector(connected) withObject:nil afterDelay:1];
            [self getMacAddress];
            [self checkSBCTime:NO];
		}
		@catch (NSException* localException) {
			if(socketfd){
				close(socketfd);
				socketfd = 0;
			}
			if(irqfd){
				close(irqfd);
				irqfd = 0;
			}
			[self setIsConnected: NO];
			[self setTimeConnected:nil];
			
			[localException raise];
		}
		
	}
}

- (void) disconnect
{
	if([self cbTestRunning]){
		exitCBTest = YES;
		[[ORGlobal sharedGlobal] removeRunVeto:@"CBTestInProgress"];
		[[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkCBTest object:self];
	}
	if(socketfd){
		close(socketfd);
		socketfd = 0;
	}
	if(irqfd){
		close(irqfd);
		irqfd = 0;
	}
	
	[self setIsConnected: NO];
	[self setTimeConnected:nil];
	NSLog(@"Disconnected from %@ <%@> port: %d\n",[self crateName],IPNumber,portNumber);
	[[delegate crate] disconnected];
	
}

- (int) connectToPort:(unsigned short) aPort
{
	//get the host info
	struct sockaddr_in target_address;					// connector's address information 
	struct hostent* he=gethostbyname([IPNumber cStringUsingEncoding:NSASCIIStringEncoding]);
	if(!he) [NSException raise:@"HostByName Failed" format:@"Couldn't get hostname for %@",IPNumber];
	
	target_address.sin_family = AF_INET;				// host byte order 
	target_address.sin_port = htons(aPort);				// short, network byte order 
	target_address.sin_addr = *((struct in_addr *)he->h_addr);
	memset(&(target_address.sin_zero), '\0', 8);		// zero the rest of the struct 
	
    int sck = socket(AF_INET, SOCK_STREAM, 0);
	if(sck == kError)[NSException raise:@"Socket Failed" format:@"Couldn't get a socket for %@ Port %d",IPNumber,aPort];
	
	int oflag = fcntl(sck, F_GETFL);
	fcntl(sck, F_SETFL, oflag | O_NONBLOCK);
	time_t now = time(NULL);
	while (connect(sck, (struct sockaddr *) &target_address, sizeof(target_address)) == -1) {
		if([self canWriteTo:sck]) break;
		if ((time(NULL) - now) > 3){
			[NSException raise:@"Connection Failed" format:@"Couldn't get a connection for %@ Port %d -- Check power and connections.",IPNumber,portNumber];
		}
	}
	//fcntl(sck, F_SETFL, oflag | O_NONBLOCK);
	
	return sck;
}


- (NSString*) crateProcessState
{
	switch(startCrateState){
		case kIdle:				return @"";
        case kPing:             return @"Pinging";
        case kWaitForPing:      return @"Wait for Ping";
        case kAfterPing:        return @"Ping OK";
        case kTryToConnect:		return @"Trying to connect";
		case kTryToStartCode:	return @"Trying to start";
		case kWaitingForStart:	return @"Waiting for start";
		case kReloadCode:		return @"Reloading/Compiling";
		case kWaitingForReload: return @"Waiting for Reload";
		case kTryToConnect2:	return @"Trying to connect";
		case kDone:				return @"";
		default:				return @"";
	}
}

- (NSString*) crateName
{
	NSString* crateName = [[delegate crate] className];
	if(crateName){
		if([crateName hasPrefix:@"OR"])crateName = [crateName substringFromIndex:2];
		if([crateName hasSuffix:@"Model"])crateName = [crateName substringToIndex:[crateName length]-5];
	}
	else {
		crateName = [[IPNumber copy] autorelease];
	}
	return crateName;
}

- (void) ping
{
    [self pingVerbose:YES];
}


- (void) pingVerbose:(BOOL)aFlag
{
	if(!pingTask){
        pingedSuccessfully = NO;
        
        pingTask = [[ORPingTask pingTaskWithDelegate:self] retain];
        
        pingTask.launchPath= @"/sbin/ping";
        pingTask.arguments = [NSArray arrayWithObjects:@"-c",@"1",@"-t",@"1",@"-q",IPNumber,nil];
        
        pingTask.verbose = aFlag;
        pingTask.textToDelegate = YES;
        [pingTask ping];

        [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkPingTask object:self];
	}
}

- (BOOL) pingTaskRunning
{
	return pingTask != nil;
}

- (void) startCBTransferTest
{
	if([self cbTestRunning]){
		exitCBTest = YES;
		[[ORGlobal sharedGlobal] removeRunVeto:@"CBTestInProgress"];
	}
	else if(![gOrcaGlobals runInProgress]){
		[[ORGlobal sharedGlobal] addRunVeto:@"CBTestInProgress" comment:@"CB Test In Progress"];
		exitCBTest = NO;
		cbTestCount = 0;
		totalRecordsChecked = 0;
		totalErrors = 0;
		startBlockSize = 1000;
		endBlockSize   = 1000000;
		productionSpeedValueValid = NO;
		productionSpeed = 0;
		doingProductionTest = NO;
		
		memset(recordSizeHisto,0, 1000*sizeof(int));
		deltaBlockSize = (endBlockSize-startBlockSize)/(numTestPoints-1);
		[self doCBTransferTest];
	}
}

- (int) cbTestCount
{
	return cbTestCount;
}

- (long) totalRecordsChecked
{
	return totalRecordsChecked;
}

- (long) totalErrors
{
	return totalErrors;
}


- (NSPoint) cbPoint:(NSUInteger)i
{
    if(i<cbTestCount)return cbPoints[i];
    else return NSZeroPoint;
}

- (BOOL) cbTestRunning
{
	return cbTestRunning || !exitCBTest;
}

- (double) cbTestProgress
{
	double val =  100*currentBlockSize/(double)(endBlockSize - startBlockSize + deltaBlockSize);
	return val;
}

- (void) sendPayloadSize:(long)aSize
{
	SBC_CmdOptionStruct optionBlock;
	optionBlock.option[0]	= aSize;
	[self sendCommand:kSBC_PacketOptions withOptions:&optionBlock expectResponse:YES];
}

- (long) payloadSize
{
	return payloadSize;
}

- (void) setPayloadSize:(long)aValue
{
    [[[self undoManager] prepareWithInvocationTarget:self] setPayloadSize:payloadSize];
    
	if(aValue<=5000)aValue = 5000;
	else if(aValue>kSBC_MaxPayloadSizeBytes)aValue = kSBC_MaxPayloadSizeBytes;
	
    payloadSize = aValue;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkNumPayloadSizeChanged object:self];
}


- (int) recordSizeHisto:(int)aChannel
{
	return recordSizeHisto[aChannel];
}

- (int) numHistoChannels
{
	return 1000; //hardcoded all over the place, don't change...
}
- (BOOL) productionSpeedValueValid
{
	return productionSpeedValueValid;
}

- (float) productionSpeed
{
	return productionSpeed;
}


- (void) throwError:(int)anError address:(unsigned long)anAddress
{
	NSString* baseString = [NSString stringWithFormat:@"Address Exception. "];
	NSString* details;
	if(anError == EPERM)		details = @"Operation not permitted";
	else if(anError == ENODEV)	details = @"No such device";
	else if(anError == ENXIO)	details = @"No such device or address";
	else if(anError == EINVAL)	details = @"Invalid argument";
	else if(anError == EFAULT)	details = @"Bad address";
	else if(anError == EBUSY)	details = @"Device Busy";
	else if(anError == ENOMEM)	details = @"Out of Memory";
	else details = [NSString stringWithFormat:@"%d",anError];
	//[NSException raise: @"SBC access Error" format:@"%@:%@\nAddress: 0x%08lx",baseString,details,anAddress];
    [NSException raise: [NSString stringWithFormat:@"SBC,%d,%d access Error",[delegate crateNumber],[delegate slot]] format:@"%@:ErrorCode:%@\nAddress: 0x%08lx ",baseString,details,anAddress];//give more info -tb-
}

- (void) fillInScript:(NSString*)theScript
{
	//first, find it in the staging area
	NSString* newScriptPath = [[mainStagingFolder stringByAppendingPathComponent:theScript] stringByExpandingTildeInPath];
	NSMutableString* contents = [NSMutableString stringWithContentsOfFile:newScriptPath encoding:NSASCIIStringEncoding error:nil];
	[contents replaceOccurrencesOfString:@"<serverName>" withString:@"OrcaReadout" options:NSCaseInsensitiveSearch range:NSMakeRange(0, [contents length])];
	[contents replaceOccurrencesOfString:@"<port>" withString:[NSString stringWithFormat:@"%d",portNumber] options:NSCaseInsensitiveSearch range:NSMakeRange(0, [contents length])];

	NSFileManager* fm = [NSFileManager defaultManager];
	if([fm fileExistsAtPath: newScriptPath]) [fm removeItemAtPath:newScriptPath error:nil];
	NSDictionary *attrib = [NSDictionary dictionaryWithObjectsAndKeys: [NSNumber numberWithInt:0777], NSFilePosixPermissions, NSFileTypeRegular, NSFileType,nil];
	[fm createFileAtPath:newScriptPath contents:[contents dataUsingEncoding:NSASCIIStringEncoding] attributes:attrib]; 
}

- (void) runFailed
{
	[[NSNotificationCenter defaultCenter] postNotificationName:ORRequestRunHalt object:self];
	if(!eRunFailedAlarm){
		eRunFailedAlarm = [[ORAlarm alloc] initWithName:@"Crate failed to start run" severity:kRunInhibitorAlarm];
		[eRunFailedAlarm setSticky:NO];
		//[eRunFailedAlarm setHelpStringFromFile:@"eCPUDeadHelp"];
	}
	if(![eRunFailedAlarm isPosted]){
		[eRunFailedAlarm setAcknowledged:NO];
		[eRunFailedAlarm postAlarm];
	}
}

- (void) sbcConnectionDropped
{
	if(!connectionDroppedAlarm){
		connectionDroppedAlarm = [[ORAlarm alloc] initWithName:@"Crate connection dropped" severity:kHardwareAlarm];
		[connectionDroppedAlarm setSticky:NO];
		[connectionDroppedAlarm setHelpString:[NSString stringWithFormat:@"Socket to SBC %@ was dropped because of a ping failure. This alarm will go away if the connection is restored or if acknowledged.",[self IPNumber]]];
	}
	if(![connectionDroppedAlarm isPosted]){
		[connectionDroppedAlarm setAcknowledged:NO];
		[connectionDroppedAlarm postAlarm];
	}
}

- (void) startCrateProcess
{
    
    if (permissionDenied) {
        NSLog(@"Check log-in credentials\n");
        startCrateState = kDone;
    }

	int oldState = startCrateState;
	switch(startCrateState){
        case kPing:
            NSLog(@"Trying to ping SBC\n");
            [self pingVerbose:YES];
            startCrateState = kWaitForPing;
            waitCount = 0;
            break;
            
        case kWaitForPing:
            if(pingedSuccessfully){
                NSLog(@"SBC returned ping\n");
                startCrateState = kAfterPing;
            }
            else if(!pingTask){
                NSLog(@"No communication to SBC (ping failed)\n");
                [self setReloading:NO];
                startCrateState = kDone;
            }
            else {
                waitCount++;
                if(waitCount > 20){
                    waitCount = 0;
                    NSLog(@"No communication to SBC (ping failed)\n");
                    [self setReloading:NO];
                    startCrateState = kDone;
               }
            }
           break;
            
        case kAfterPing:
            if(forceReload) startCrateState = kReloadCode;
            else            startCrateState = kTryToConnect;
            break;
            
        case kTryToConnect:
			@try {
				NSLog(@"Trying to connect to SBC\n");
				[self connect]; //will throw if can't connect
				startCrateState = kDone;
			}
			@catch (NSException* localException) {
				//couldn't connect, try to start the code
				NSLog(@"Connection to SBC Failed. SBC probably not running.\n");

				startCrateState = kTryToStartCode;
			}
			break;
			
		case kTryToStartCode:
			@try {
				NSLog(@"Starting SBC code\n");
				[self startCrateCode];
				[ORTimer delay:.3];
				startCrateState = kWaitingForStart;
				waitCount = 0;
			}
			@catch (NSException* localException) {
				startCrateState = kReloadCode;
			}
			break;
			
		case kWaitingForStart:
			if(isConnected)            startCrateState = kDone;
 			else if (goScriptFailed)   startCrateState = kReloadCode;
			else {
				@try {
					[self connect];
					startCrateState = kDone;
				}
				@catch (NSException* localException) {
				}
				waitCount++;
				if(waitCount > 200){
					waitCount = 0;
					startCrateState = kReloadCode;
				}
			}
			break;
			
		case kReloadCode:
			[self reloadClient];
			NSLog(@"Waiting for SBC code reload \n");
            startCrateState = kWaitingForReload;
            waitCount = 0;
			break;
			
		case kWaitingForReload:
			if(!reloading){
				startCrateState = kTryToConnect2;
				waitCount = 0;
			}
			else {
				waitCount++;
				if(waitCount > 600){
					waitCount = 0;
					startCrateState = kDone;
					//failed......
					NSLog(@"Failed to reload\n");
					[self setReloading:NO];
				}
			}
			break;
			
		case kTryToConnect2:
			if(isConnected)startCrateState = kDone;
			else {
				@try {
					[self connect];
				}
				@catch (NSException* localException) {
				}
				waitCount++;
				if(waitCount > 10){
					waitCount = 0;
					startCrateState = kDone;
					//failed......
                    if(reloading)NSLog(@"Failed to connect after reload\n");
                    NSLog(@"Check log-in credentials\n");
					[self setReloading:NO];
				}
			}
			break;
	} 
	
	if(startCrateState != oldState){
		[[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkCrateStartStatusChanged object:self];
	}
	
	
	if(startCrateState!=kDone){
		[self performSelector:@selector(startCrateProcess) withObject:self afterDelay:.1];
	}
	else [self setTryingToStartCrate:NO];
}

- (void) watchIrqSocket
{
	irqThreadRunning = YES;
	id pw = [[SBCPacketWrapper alloc] init];
	SBC_Packet* aPacket = [pw sbcPacket];
	lamsToAck    = [[ORSafeQueue alloc] init];
	while([self isConnected]){
		if([self dataAvailable:irqfd]){
			[self readSocket:irqfd buffer:aPacket]; //read the irq
			int irqNumber = aPacket->payload[0];
			int i;
			for(i=0;i<[[self orcaObjects] count]; i++){
				ORSBC_LAMModel* lamObj = [[self orcaObjects] objectAtIndex:i];
				if([lamObj slot] == irqNumber){
					if(![lamObj isBusy]){
						[lamObj processPacket:aPacket];
						[lamsToAck enqueue:lamObj];
					}
					break;
				}
			}
		}
		
		//ack any lams that have been processed on this side
		int n = [lamsToAck count];
		if(n){
			SBC_LamAckStruct *p = (SBC_LamAckStruct*)aPacket->payload;
			char* lamPtr = (char*)(p+1);
			ORSBC_LAMModel* lamObj = nil;
			do {
				lamObj = [lamsToAck dequeue];
				if(lamObj){
					*lamPtr++ = [lamObj slot];
					p->numToAck++;
				}
			}while(lamObj);
			//send off the ack packet
			[self write:irqfd buffer:aPacket];
		}
		else if(stopWatchingIRQ) break;
	}
	
	irqThreadRunning = NO;
	[lamsToAck release];
	[pw releaseAndCache];
	
	lamsToAck    = nil;
}

- (void) write:(int)aSocket buffer:(SBC_Packet*)aPacket
{
	//Note there are NO locks on this method, but it is private and can only be called from this object. Care must
	//be taken that thread locks are provided at a higher level.
    if (!(aPacket->cmdHeader.destination == kSBC_Command && aPacket->cmdHeader.cmdID == kSBC_GenericJob )) {
        aPacket->message[0] = '\0';
    }
	if(!aSocket)	[NSException raise:@"Write Error" format:@"SBC Not Connected %@ <%@> port: %d",[self crateName],IPNumber,portNumber];
	
	
	// wait until timeout or data received
    int selectionResult = 0;
    int bytesWritten = 0;
	int numBytesToSend = sizeof(long) +
	sizeof(SBC_CommandHeader) + 
	kSBC_MaxMessageSizeBytes + 
	aPacket->cmdHeader.numberBytesinPayload;
	aPacket->numBytes = numBytesToSend;
	char* packetPtr = (char*)aPacket;		//recast the first 'real' word in the packet
	while (numBytesToSend) {
		// The loop is to ignore EAGAIN and EINTR errors as these are harmless 
		do {
			// set up the file descriptor set
			fd_set write_fds;
			FD_ZERO(&write_fds);
			FD_SET(aSocket, &write_fds);
			
			struct timeval tv;
			tv.tv_sec  = 2;
			tv.tv_usec = 0;
			selectionResult = select(aSocket+1, NULL, &write_fds, NULL, &tv);
		} while (selectionResult == kSelectionError && (errno == EAGAIN || errno == EINTR));
		
        if (selectionResult == kSelectionError){
            [NSException raise:@"Write Error" format:@"Write Error %@ <%@>: %s",[self crateName],IPNumber,strerror(errno)];
        }
        else if (selectionResult == kSelectionTimeout) {
            [NSException raise:@"ConnectionTimeOut" format:@"Write from %@ <%@> port: %d timed out",[self crateName],IPNumber,portNumber];
        }   
		do {
			bytesWritten = write(aSocket,packetPtr,numBytesToSend);
		} while (bytesWritten < 0 && (errno == EAGAIN || errno == EINTR));
		if (bytesWritten > 0) {
			packetPtr += bytesWritten;
			numBytesToSend -= bytesWritten;
			bytesSent += bytesWritten;
		} 
		else if (bytesWritten < 0) {
            if (errno == EPIPE) {
                [self disconnect];
                [[NSNotificationCenter defaultCenter] postNotificationOnMainThreadWithName:SBC_SocketDroppedUnexpectedly  object:self];
            }
			[NSException raise:@"Write Error" format:@"Write Error(%s) %@ <%@> port: %d",strerror(errno),[self crateName],IPNumber,portNumber];
		}
	}
}

- (void) read:(int)aSocket buffer:(SBC_Packet*)aPacket
{	
	//Note that there are NO locks on this method, but it is private and can only be called from this object. 
	//Care must be taken that thread locks are provided at a higher level in this object
	if(!aSocket)	[NSException raise:@"Read Error" format:@"SBC Not Connected %@ <%@> port: %d",[self crateName],IPNumber,portNumber];
	
	// wait until timeout or data received
	int  selectionResult;
	
	// The loop is to ignore EAGAIN and EINTR errors as these are harmless 
	do {
		// set up the file descriptor set
		fd_set read_fds;
		FD_ZERO(&read_fds);
		FD_SET(aSocket, &read_fds);
		
		struct timeval tv;
		tv.tv_sec  = 2;
		tv.tv_usec = 0;
		selectionResult = select(aSocket+1, &read_fds, NULL, NULL, &tv);
	} while (selectionResult == kSelectionError && (errno == EAGAIN || errno == EINTR));
	
	if(selectionResult > 0){
		[self readSocket:aSocket buffer:aPacket];
	}
	else if (selectionResult == kSelectionError){
		[NSException raise:@"Read Error" format:@"Read Error %@ <%@>: %s",[self crateName], IPNumber,strerror(errno)];
	}
	else if (selectionResult == kSelectionTimeout) {
		[NSException raise:@"ConnectionTimeOut" format:@"Read from %@ <%@> port: %d timed out (A)",[self crateName],IPNumber,portNumber];
	}
	if(aPacket->message[0] && (aPacket->cmdHeader.cmdID != kSBC_JobStatus))NSLog(@"SBC,%d,%d remote message:%s\n",[delegate crateNumber],[delegate slot],aPacket->message);
} 

- (void) readSocket:(int)aSocket buffer:(SBC_Packet*)aPacket
{
	int n;			
    int  selectionResult = 0;
	long numBytesToGet = 0;
	time_t t1 = time(0);
	do {
		n = recv(aSocket, &numBytesToGet, sizeof(numBytesToGet), 0);
		if(n<0 && (errno == EAGAIN || errno == EINTR)){
			int timeout = [self errorTimeOutSeconds];
			if(timeout>0){
				if((time(0)-t1)>timeout) {
					[self disconnect];
                    [[NSNotificationCenter defaultCenter] postNotificationOnMainThreadWithName:SBC_SocketDroppedUnexpectedly  object:self];
					[NSException raise:@"Socket Disconnected" format:@"%@ Disconnected",IPNumber];
				}
			}
		}
		else break;

	} while (1);
	
	if(n==0){
		[self disconnect];
        [[NSNotificationCenter defaultCenter] postNotificationOnMainThreadWithName:SBC_SocketDroppedUnexpectedly  object:self];
		[NSException raise:@"Socket Disconnected" format:@"%@ Disconnected",IPNumber];
	}
	else if (n<0) {
		[NSException raise:@"Socket Error" format:@"Error: %s",strerror(errno)];
    } 
	else if (n < sizeof(long)) {
        /* We didn't get the whole word.  This probably will never happen. */
        int numToGet = sizeof(numBytesToGet) - n;
        char* ptrToNumBytesToGet = ((char*)&numBytesToGet) + n;
        while (numToGet) {
			// The loop is to ignore EAGAIN and EINTR errors as these are harmless 
			do {
				// set up the file descriptor set
				fd_set read_fds;
				FD_ZERO(&read_fds);
				FD_SET(aSocket, &read_fds);
				
				struct timeval tv;
				tv.tv_sec  = 2;
				tv.tv_usec = 0;
				selectionResult = select(aSocket+1, &read_fds, NULL, NULL, &tv);
			} while (selectionResult == kSelectionError && (errno == EAGAIN || errno == EINTR));

            if(selectionResult > 0){
				time_t t1 = time(0);
				do {
					n = recv(aSocket, ptrToNumBytesToGet, numToGet, 0);	
					if(n<0 && (errno == EAGAIN || errno == EINTR)){
						int timeout = [self errorTimeOutSeconds];
						if(timeout>0){
							if((time(0)-t1)>timeout) {
								[self disconnect];
                                [[NSNotificationCenter defaultCenter] postNotificationOnMainThreadWithName:SBC_SocketDroppedUnexpectedly  object:self];
								[NSException raise:@"Socket Disconnected" format:@"%@ Disconnected",IPNumber];
							}
						}
					}
					else break;
				} while (1);
				if(n==0){
					[self disconnect];
                    [[NSNotificationCenter defaultCenter] postNotificationOnMainThreadWithName:SBC_SocketDroppedUnexpectedly  object:self];
					[NSException raise:@"Socket Disconnected" format:@"%@ Disconnected",IPNumber];
				} 
				else if (n<0) {
					[NSException raise:@"Socket Error" format:@"Error <%@>: %s",IPNumber,strerror(errno)];
				} else {
					numToGet -= n;
					ptrToNumBytesToGet += n;    
				}
            }
            else if (selectionResult == kSelectionError){
                [NSException raise:@"Read Error" format:@"Read Error %@ <%@>: %s",[self crateName],IPNumber,strerror(errno)];
            }
            else if (selectionResult == kSelectionTimeout) {
                [NSException raise:@"ConnectionTimeOut" format:@"Read from %@ <%@> port: %d timed out (B)",[self crateName],IPNumber,portNumber];
            }
            
        }
    }
	bytesReceived += sizeof(numBytesToGet);
	numBytesToGet -= sizeof(numBytesToGet);
	
	char* packetPtr = (char*)&aPacket->cmdHeader;
	while(numBytesToGet){
		// The loop is to ignore EAGAIN and EINTR errors as these are harmless 
		do {
			// set up the file descriptor set
			fd_set read_fds;
			FD_ZERO(&read_fds);
			FD_SET(aSocket, &read_fds);
			
			struct timeval tv;
			tv.tv_sec  = 2;
			tv.tv_usec = 0;
			selectionResult = select(aSocket+1, &read_fds, NULL,  NULL, &tv);
		} while (selectionResult == kSelectionError && (errno == EAGAIN || errno == EINTR));
		
        if (selectionResult == kSelectionError){
            [NSException raise:@"Read Error" format:@"Read Error %@ <%@>: %s",[self crateName],IPNumber,strerror(errno)];
        }
        else if (selectionResult == kSelectionTimeout) {
            [NSException raise:@"ConnectionTimeOut" format:@"Read from %@ <%@> port: %d timed out (C)",[self crateName],IPNumber,portNumber];
        }
		time_t t1 = time(0);
		do {
			n = recv(aSocket, packetPtr, numBytesToGet, 0);
			if(n<0 && (errno == EAGAIN || errno == EINTR)){
				int timeout = [self errorTimeOutSeconds];
				if(timeout>0){
					if((time(0)-t1)>timeout) {
						[self disconnect];
                        [[NSNotificationCenter defaultCenter] postNotificationOnMainThreadWithName:SBC_SocketDroppedUnexpectedly  object:self];
						[NSException raise:@"Socket Disconnected" format:@"%@ Disconnected",IPNumber];
					}
				}
			}
			else break;
			
		} while (1);
		
        if(n==0){
            [self disconnect];
            [[NSNotificationCenter defaultCenter] postNotificationOnMainThreadWithName:SBC_SocketDroppedUnexpectedly  object:self];
            [NSException raise:@"Socket Disconnected" format:@"%@ Disconnected",IPNumber];
        } 
		else if (n<0) {
            [NSException raise:@"Socket Error" format:@"Error <%@>: %s",IPNumber,strerror(errno)];
        } 
		else {
            packetPtr += n;
            numBytesToGet -= n;
            bytesReceived += n;
            missedHeartBeat = 0;
        }
 	}
}

- (BOOL) canWriteTo:(int) sck
{
	fd_set wfds;
	struct timeval tv;
	
	FD_ZERO(&wfds);
	FD_SET(sck, &wfds);
	
	tv.tv_sec = 0;
	tv.tv_usec = 0;
	
	int retval = select(sck + 1, NULL, &wfds, NULL, &tv);
	return (retval > 0) && FD_ISSET(sck, &wfds);
}

- (BOOL) dataAvailable:(int) aSocket
{
	if(!aSocket)return NO;
	
	// set up the file descriptor set
	fd_set fds;
	FD_ZERO(&fds);
	FD_SET(aSocket, &fds);
	
	struct timeval tv;
	tv.tv_sec  = 0;
	tv.tv_usec = 10000;
	
	// wait until timeout or data received
	int  selectionResult = select(aSocket+1, &fds, NULL, NULL, &tv);
	return (selectionResult > 0) && FD_ISSET(aSocket, &fds);
}

- (void) doCBTransferTest
{	
	if(exitCBTest) {
		[[ORGlobal sharedGlobal] removeRunVeto:@"CBTestInProgress"];
		[[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkCBTest object:self];
		return;
	}
	if(!cbTestRunning){
		currentBlockSize = startBlockSize + cbTestCount*deltaBlockSize;
		
		if(currentBlockSize <= endBlockSize) [self doOneCBTransferTest:currentBlockSize];
		else if(!productionSpeedValueValid){
			doingProductionTest = YES;
			[self doOneCBTransferTest:payloadSize];
		}
		else {
			exitCBTest = YES;
			[[ORGlobal sharedGlobal] removeRunVeto:@"CBTestInProgress"];
			
			[[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkCBTest object:self];
			return;
		}
	}
	
	[self performSelector:@selector(doCBTransferTest) withObject:nil afterDelay:1];
	
}

- (void) doOneCBTransferTest:(long)aPayloadSize
{
	totalTime = totalPayload = totalMeasurements = 0;
	
	[self sendPayloadSize:aPayloadSize];
	
	SBC_CmdOptionStruct optionBlock;
	[self sendCommand:kSBC_CBTest withOptions:&optionBlock expectResponse:YES];
	
	if(optionBlock.option[0] == 1){
		[self performSelector:@selector(sampleCBTransferSpeed) withObject:nil afterDelay:1];
		cbTestRunning = YES;
		lastInfoUpdate = [[NSDate date] retain];
	}
	
	[[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkCBTest object:self];
}


- (void) sampleCBTransferSpeed
{
	[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(sampleCBTransferSpeed) object:nil];
	
	NSDate* now = [NSDate date];
	if([now timeIntervalSinceDate:lastInfoUpdate] > .5){
		[self getRunInfoBlock];
		[lastInfoUpdate release];
		lastInfoUpdate = [now retain];
	}
	
	id pw = [[SBCPacketWrapper alloc] init];
	SBC_Packet* aPacket = [pw sbcPacket];
	aPacket->cmdHeader.destination	= kSBC_Process;
	aPacket->cmdHeader.cmdID			= kSBC_CBRead;
	aPacket->cmdHeader.numberBytesinPayload = 0;
	
	ORTimer* timer = [[ORTimer alloc] init];
	[timer start];
	[self send:aPacket receive:aPacket];
	totalTime += [timer microseconds];
	totalPayload += aPacket->cmdHeader.numberBytesinPayload;
	totalMeasurements++;
	[timer release];
	
	unsigned long* rp = (unsigned long*)aPacket->payload;
	long numLongs = aPacket->cmdHeader.numberBytesinPayload/sizeof(long);
	unsigned long* endPt = rp + numLongs;
	
	
	while(rp<endPt){
		unsigned long n = *rp++;
		long i;
		for(i=1;i<n;i++){
			if(*rp++ != i)totalErrors++;
		}
		totalRecordsChecked++;
		if(n<1000)recordSizeHisto[n]++;
	}
	int sampleSize;
	if(doingProductionTest)sampleSize = 500;
	else sampleSize = 100;
	if(!exitCBTest && runInfo.amountInBuffer > 0 && totalMeasurements < sampleSize){
		[self performSelector:@selector(sampleCBTransferSpeed) withObject:nil afterDelay:0];
	}
	else {
		if(totalMeasurements){
			double aveTime		= totalTime/(double)totalMeasurements;
			double avePayload	= totalPayload/(double)totalMeasurements;
			if(aveTime){
				if(!doingProductionTest){
					cbPoints[cbTestCount].x = currentBlockSize/1000.;
					cbPoints[cbTestCount].y = avePayload/aveTime;
					cbTestCount++;
				}
				else {
					productionSpeedValueValid = YES;
					productionSpeed = avePayload/aveTime;
					NSLog(@"Run-Time socket throughput estimated to be: %.1f MB/sec with payload size of %d KB \n",productionSpeed,payloadSize/1000);
				}
			}
		}
		cbTestRunning = NO;
		[[NSNotificationCenter defaultCenter] postNotificationName:SBC_LinkCBTest object:self];
	}
	[pw releaseAndCache];
}

- (void) monitorJobFor:(id)aDelegate statusSelector:(SEL)aSelector
{
	jobDelegate = aDelegate;
	statusSelector= aSelector;
	[self monitorJob];
}

- (void) monitorJob
{
	id pw = [[SBCPacketWrapper alloc] init];
	SBC_Packet* aPacket = [pw sbcPacket];
	aPacket->cmdHeader.destination			= kSBC_Process;
	aPacket->cmdHeader.cmdID					= kSBC_JobStatus;
	aPacket->cmdHeader.numberBytesinPayload	= sizeof(SBC_JobStatusStruct);
	
	@try {
		[self send:aPacket receive:aPacket];
		
		SBC_JobStatusStruct* p	= (SBC_JobStatusStruct*)aPacket->payload;
		if([jobDelegate respondsToSelector:statusSelector]){
			ORSBCLinkJobStatus* aJobStatus = [ORSBCLinkJobStatus jobStatus:p message:aPacket->message];
			[self setJobStatus:aJobStatus];
			//NSLog(@"monitor job ok: job %s running with message: %s\n", [aJobStatus running]?"is":"is not", [aJobStatus message]);
			[jobDelegate performSelector:statusSelector withObject:jobStatus];
		}
		if(p->running){
			[self performSelector:@selector(monitorJob) withObject:nil afterDelay:0.1];
		}
	}
	@catch(NSException* localException) {
	}
	@finally {
		[pw releaseAndCache];
	}
}

- (void) writeGeneral:(long*) buffer
			  operation:(unsigned long) anOperationID
			 numToWrite:(unsigned int)  numberLongs
{
    id pw = [[SBCPacketWrapper alloc] init];
	@try {
		[socketLock lock]; //begin critical section
		SBC_Packet* aPacket = [pw sbcPacket];
		aPacket->cmdHeader.destination			= kSBC_Process;
		aPacket->cmdHeader.cmdID					= kSBC_GeneralWrite;
		aPacket->cmdHeader.numberBytesinPayload	= sizeof(SBC_WriteBlockStruct) + numberLongs*sizeof(long);
		
		SBC_WriteBlockStruct* dataPtr = (SBC_WriteBlockStruct*)aPacket->payload;
		dataPtr->address		= anOperationID;
		dataPtr->numLongs		= numberLongs;
		dataPtr++;
		memcpy(dataPtr,buffer,numberLongs*sizeof(long));
		
		[self write:socketfd buffer:aPacket];
        [self read:socketfd buffer:aPacket]; //read the response
		
		SBC_ReadBlockStruct* rp = (SBC_ReadBlockStruct*)aPacket->payload;
		int numLongs = rp->numLongs;
		rp++;
		long* dp = (long*)rp;
		int i;
		for(i=0;i<numLongs;i++){
			buffer[i] = dp[i];
		}

		[socketLock unlock]; //end critical section
	}
	@catch (NSException* localException) {
		[socketLock unlock]; //end critical section
		[localException raise];
	}
	@finally {
		[pw releaseAndCache];
	}
}


- (void) readGeneral:(long*) buffer
		   operation:(unsigned long) anOperationID
		   numToRead:(unsigned int) numberLongs
{
    id pw = [[SBCPacketWrapper alloc] init];    
	@try {
		[socketLock lock]; //begin critical section
		SBC_Packet* aPacket = [pw sbcPacket];
		aPacket->cmdHeader.destination			= kSBC_Process;
		aPacket->cmdHeader.cmdID					= kSBC_GeneralRead;
		aPacket->cmdHeader.numberBytesinPayload	= sizeof(SBC_ReadBlockStruct);
		
		SBC_ReadBlockStruct* readBlockPtr = (SBC_ReadBlockStruct*)aPacket->payload;
		readBlockPtr->address		= anOperationID;
		readBlockPtr->numLongs		= numberLongs;
		
		//Do NOT call the combo send:receive method here... we have the locks already in place
		[self write:socketfd buffer:aPacket]; //write the packet
		[self read:socketfd buffer:aPacket]; //read the response
		
		SBC_ReadBlockStruct* rp = (SBC_ReadBlockStruct*)aPacket->payload;
		int numLongs = rp->numLongs;
		rp++;
		long* dp = (long*)rp;
		int i;
		for(i=0;i<numLongs;i++){
			buffer[i] = dp[i];
		}
		[socketLock unlock]; //end critical section
	}
	@catch (NSException* localException) {
		[socketLock unlock]; //end critical section
		[localException raise];
	}
	@finally {
		[pw releaseAndCache];
	}
}

- (void) postCouchDBRecord
{
    NSMutableArray* cardErrorCounts     = [NSMutableArray arrayWithCapacity:MAX_CARDS];
    NSMutableArray* cardBusErrorCounts  = [NSMutableArray arrayWithCapacity:MAX_CARDS];
    NSMutableArray* cardMessageCounts   = [NSMutableArray arrayWithCapacity:MAX_CARDS];
    unsigned long cardErrorCount        = 0;
    unsigned long cardBusErrorCount     = 0;
    unsigned long cardMessageCount      = 0;
    int i;
    for(i=0;i<MAX_CARDS;i++){
        [cardErrorCounts    addObject:[NSNumber numberWithUnsignedLong:errorInfo.card[i].errorCount]];
        [cardBusErrorCounts addObject:[NSNumber numberWithUnsignedLong:errorInfo.card[i].busErrorCount]];
        [cardMessageCounts  addObject:[NSNumber numberWithUnsignedLong:errorInfo.card[i].messageCount]];
        cardErrorCount     += errorInfo.card[i].errorCount;
        cardBusErrorCount  += errorInfo.card[i].busErrorCount;
        cardMessageCount   += errorInfo.card[i].messageCount;
    }
    
    NSDictionary* values = [NSDictionary dictionaryWithObjectsAndKeys:
                            [NSNumber numberWithLong: runInfo.statusBits],          @"statusBits",
                            [NSNumber numberWithLong: runInfo.err_count],           @"err_count",
                            [NSNumber numberWithLong: runInfo.lostByteCount],       @"lostByteCount",
                            [NSNumber numberWithLong: runInfo.amountInBuffer],      @"amountInBuffer",
                            [NSNumber numberWithLong: runInfo.pollingRate],         @"pollingRate",
                            [NSNumber numberWithLong: runInfo.wrapArounds],         @"wrapArounds",
                            [NSNumber numberWithLong: runInfo.recordsTransfered],   @"recordsTransfered",
                            [NSNumber numberWithLong: byteRateReceived],            @"byteRateReceived",
                            [NSNumber numberWithLong: byteRateSent],                @"byteRateSent",
                            [NSNumber numberWithLong: timeSkew],                    @"timeSkew",
                            [NSNumber numberWithLong: timeSkewValid],               @"timeSkewValid",
                            [NSNumber numberWithLong: cardErrorCount],              @"cardErrorCount",
                            [NSNumber numberWithLong: cardBusErrorCount],           @"cardBusErrorCount",
                            [NSNumber numberWithLong: cardMessageCount],            @"cardMessageCount",
                            cardErrorCounts,                                        @"cardErrorCounts",
                            cardBusErrorCounts,                                     @"cardBusErrorCounts",
                            cardMessageCounts,                                      @"cardMessageCounts",
                            nil];
    [[NSNotificationCenter defaultCenter] postNotificationName:@"ORCouchDBAddObjectRecord" object:delegate userInfo:values];

    NSDictionary* historyRecord = [NSDictionary dictionaryWithObjectsAndKeys:
                                   [delegate fullID],               @"name",
                                   @"SBCInfo",                      @"title",
                                   [NSArray arrayWithObjects:
                                    [NSDictionary dictionaryWithObject: [NSNumber numberWithLong: runInfo.statusBits]        forKey:@"statusBits"],
                                    [NSDictionary dictionaryWithObject: [NSNumber numberWithLong: runInfo.err_count]         forKey:@"err_count"],
                                    [NSDictionary dictionaryWithObject: [NSNumber numberWithLong: runInfo.lostByteCount]     forKey:@"lostByteCount"],
                                    [NSDictionary dictionaryWithObject: [NSNumber numberWithLong: runInfo.amountInBuffer]    forKey:@"amountInBuffer"],
                                    [NSDictionary dictionaryWithObject: [NSNumber numberWithLong: runInfo.pollingRate]       forKey:@"pollingRate"],
                                    [NSDictionary dictionaryWithObject: [NSNumber numberWithLong: runInfo.wrapArounds]       forKey:@"wrapArounds"],
                                    [NSDictionary dictionaryWithObject: [NSNumber numberWithLong: runInfo.recordsTransfered] forKey:@"recordsTransfered"],
                                    [NSDictionary dictionaryWithObject: [NSNumber numberWithDouble: byteRateReceived]        forKey:@"byteRateReceived"],
                                    [NSDictionary dictionaryWithObject: [NSNumber numberWithDouble: byteRateSent]           forKey:@"byteRateSent"],
                                    [NSDictionary dictionaryWithObject: [NSNumber numberWithLong: timeSkew] forKey:@"timeSkew"],
                                    nil
                                    ],
                                   @"adcs",
                                   nil
                                   ];
    
        [[NSNotificationCenter defaultCenter] postNotificationName:@"ORCouchDBAddHistoryAdcRecord" object:self userInfo:historyRecord];
}

@end

//a quicky wrapper so we can pass the job status around as an object.
@implementation ORSBCLinkJobStatus
+ (id) jobStatus:(SBC_JobStatusStruct*) p message:(char*)aPacketMessage
{
	return [[[ORSBCLinkJobStatus alloc] initWith:p message:aPacketMessage] autorelease];
}
- (id) initWith:(SBC_JobStatusStruct*)p message:(char*)aPacketMessage
{
	self = [super init];
	memcpy(&status,p,sizeof(SBC_JobStatusStruct));
	message = [[NSString stringWithCString:aPacketMessage encoding:NSASCIIStringEncoding] retain];
	return self;
}
- (void) dealloc
{
	[message release];
	[super dealloc];
}
- (NSString*) message {return message;}
- (long) running	 { return status.running; }
- (long) finalStatus { return status.finalStatus; }
- (long) progress	 { return status.progress; }

@end
