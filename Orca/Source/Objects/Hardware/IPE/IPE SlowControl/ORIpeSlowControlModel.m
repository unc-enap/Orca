//--------------------------------------------------------
// ORIpeSlowControlModel
// Created by Mark  A. Howe on Mon Apr 11 2005
// Code partially generated by the OrcaCodeWizard. Written by Mark A. Howe.
// Copyright (c) 2005 CENPA, University of Washington. All rights reserved.
//-----------------------------------------------------------
//This program was prepared for the Regents of the University of 
//Washington at the Center for Experimental Nuclear Physics and 
//Astrophysics (CENPA) sponsored in part by the United States 
//Department of Energy (DOE) under Grant #DE-FG02-97ER41020. 
//The University has certain rights in the program pursuant to 
//the contract and the program should not be copied or distributed 
//outside your organization.  The DOE and the University of 
//Washington reserve all rights in the program. Neither the authors,
//University of Washington, or U.S. Government make any warranty, 
//express or implied, or assume any liability or responsibility 
//for the use of this software.
//-------------------------------------------------------------
//
// 2009-2013: Till.Bergmann@kit.edu
//

#pragma mark ***Imported Files

#import "ORIpeSlowControlModel.h"
#import "ORDataTaker.h"
#import "ORDataTypeAssigner.h"
#import "ORAdeiLoader.h"

#if MAC_OS_X_VERSION_MAX_ALLOWED > MAC_OS_X_VERSION_10_4
#import "objc/runtime.h"  //for class_getName
#endif

#pragma mark •••Notification Strings
NSString* ORIpeSlowControlModelRePostStillPendingRequestsChanged = @"ORIpeSlowControlModelRePostStillPendingRequestsChanged";
NSString* ORIpeSlowControlModelManualTypeChanged = @"ORIpeSlowControlModelManualTypeChanged";
NSString* ORIpeSlowControlModelManualPathChanged = @"ORIpeSlowControlModelManualPathChanged";
NSString* ORIpeSlowControlModelShowDebugOutputChanged = @"ORIpeSlowControlModelShowDebugOutputChanged";
NSString* ORIpeSlowControlModelShipRecordsChanged	= @"ORIpeSlowControlModelShipRecordsChanged";
NSString* ORIpeSlowControlModelTotalRequestCountChanged = @"ORIpeSlowControlModelTotalRequestCountChanged";
NSString* ORIpeSlowControlModelTimeOutCountChanged	= @"ORIpeSlowControlModelTimeOutCountChanged";
NSString* ORIpeSlowControlModelFastGenSetupChanged	= @"ORIpeSlowControlModelFastGenSetupChanged";
NSString* ORIpeSlowControlModelSetPointChanged		= @"ORIpeSlowControlModelSetPointChanged";
NSString* ORIpeSlowControlModelItemTypeChanged		= @"ORIpeSlowControlModelItemTypeChanged";
NSString* ORIpeSlowControlModelViewItemNameChanged	= @"ORIpeSlowControlModelViewItemNameChanged";
NSString* ORIpeSlowControlLock                      = @"ORIpeSlowControlLock";
NSString* ORIpeSlowControlSelectedSensorNumChanged  = @"ORIpeSlowControlSelectedSensorNumChanged";
NSString* ORIpeSlowControlItemListChanged			= @"ORIpeSlowControlItemListChanged";
NSString* ORIpeSlowControlAdeiBaseUrlForSensorChanged = @"ORIpeSlowControlAdeiBaseUrlForSensorChanged";
NSString* ORIpeSlowControlPollTimeChanged			= @"ORIpeSlowControlPollTimeChanged";
NSString* ORIpeSlowControlLastRequestChanged		= @"ORIpeSlowControlLastRequestChanged";
NSString* ORIpeSlowControlIPNumberChanged			= @"ORIpeSlowControlIPNumberChanged";
NSString* ORIpeSlowItemTreeChanged					= @"ORIpeSlowItemTreeChanged";
NSString* ORIpeSlowControlModelHistogramChanged		= @"ORIpeSlowControlModelHistogramChanged";
NSString* ORIpeSlowControlPendingRequestsChanged	= @"ORIpeSlowControlPendingRequestsChanged";
NSString* ORIpeSlowControlSetpointRequestQueueChanged	= @"ORIpeSlowControlSetpointRequestQueueChanged";

//Removed connector MAH May 18,2010
//NSString* ORADEIInConnection						= @"ORADEIInConnection";

@interface NSString (ParsingExtensions)
-(NSArray *)csvRows;
@end

#define IPE_SLOW_CONTROL_SHORT_NAME @"IPE-ADEI"

@interface ORIpeSlowControlModel (private)
- (NSMutableArray*) insertNode:(id)aNode intoArray:(NSMutableArray*)anArray path:(NSString*)aPath nodeName:(NSString*)nodeName isLeaf:(BOOL)isLeaf;
- (void) itemTreeResults:(id)result path:(NSString*)aPath;
- (void) polledItemResult:(id)result path:(NSString*)aPath;
- (void) handleSilentItemResult:(id)result path:(NSString*)aPath;
- (void) clearPendingRequest:(NSString*)anItemKey;
- (void) setPendingRequest:(NSString*)anItemKey;
- (void) checkForTimeOuts;
- (void) shipTheRecords;
- (NSTimeInterval) timeFromADEIDate:(NSString*)aDate;
- (void) addItemKeyToPollingLookup:(NSString*) anItemKey;
- (void) removeItemKeyFromPollingLookup:(NSString*) anItemKey;
- (void) sortPollingItems;
@end

@implementation ORIpeSlowControlModel
- (id) init
{
	self = [super init];
	[self initBasics];
	return self;
}

- (id) initBasics
{
    //FZK-internal: [self setAdeiServiceUrl: @"http://ipepdvadei.ka.fzk.de/adei/services/"];//TODO: make attribute -tb-
    [self setIPNumber: @"fuzzy.fzk.de/adei"];
    currentQueueErrorIndex=1;
	if(!requestCache)   requestCache = [[NSMutableDictionary dictionary] retain];
	if(!pollingLookUp)  pollingLookUp = [[NSMutableArray array] retain];
	return self;
}

- (void) dealloc
{
    [manualPath release];
    [setpointRequestsQueue release];
	[NSObject cancelPreviousPerformRequestsWithTarget:self];
	[connectionHistory release];
	[itemTreeRoot release];
	[requestCache release];
	[super dealloc];
}

- (void) awakeAfterDocumentLoaded
{
	//----------------------------------------------------------------
	//Removed connector MAH May 18,2010
	//this bit of code is for backward compatibility
	ORConnector* aConnector = [self connectorOn:@"ORADEIInConnection"];
	[aConnector disconnect];
	[connectors release];
	connectors = nil;
	//----------------------------------------------------------------
}

- (void) setUpImage
{
	[self setImage:[NSImage imageNamed:@"IpeSlowControl"]];
}

- (void) makeMainController
{
	[self linkToController:@"ORIpeSlowControlController"];
}


//Removed connector MAH May 18,2010
/*-(void) makeConnectors
{
	//we  have three permanent connectors. The rest we manage for the pci objects.
    ORConnector* aConnector = [[ORConnector alloc] initAt:NSMakePoint(0, 0) withGuardian:self withObjectLink:self];
    [[self connectors] setObject:aConnector forKey:ORADEIInConnection];
    [aConnector setOffColor:[NSColor magentaColor]];
    [aConnector setOffColor:[NSColor brownColor]];
	[aConnector setConnectorType: 'ADEI'];
	[aConnector addRestrictedConnectionType: 'ADEO']; //can only connect to DB Inputs
    [aConnector release];
}
*/

- (void) initConnectionHistory
{
	ipNumberIndex = [[NSUserDefaults standardUserDefaults] integerForKey: [NSString stringWithFormat:@"orca.%@.IPNumberIndex",[self className]]];
	if(!connectionHistory){
		NSArray* his = [[NSUserDefaults standardUserDefaults] objectForKey: [NSString stringWithFormat:@"orca.%@.ConnectionHistory",[self className]]];
		connectionHistory = [his mutableCopy];
	}
	if(!connectionHistory)connectionHistory = [[NSMutableArray alloc] init];
}

- (void) clearHistory
{
	[connectionHistory release];
	connectionHistory = nil;
	
	[self setIPNumber:IPNumber];
}


#pragma mark ***Accessors

- (int) rePostStillPendingRequests
{
    return rePostStillPendingRequests;
}

- (void) setRePostStillPendingRequests:(int)aRePostStillPendingRequests
{
    [[[self undoManager] prepareWithInvocationTarget:self] setRePostStillPendingRequests:rePostStillPendingRequests];
    
    rePostStillPendingRequests = aRePostStillPendingRequests;

    [[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSlowControlModelRePostStillPendingRequestsChanged object:self];
}

- (int) manualType
{
    return manualType;
}

- (void) setManualType:(int)aManualType
{
    manualType = aManualType;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSlowControlModelManualTypeChanged object:self];
}

- (NSString*) manualPath
{
    if(manualPath==nil) return @"";
    return manualPath;
}

- (void) setManualPath:(NSString*)aManualPath
{
    [[[self undoManager] prepareWithInvocationTarget:self] setManualPath:manualPath];
	if([aManualPath length]==0) aManualPath = @"";
    [manualPath autorelease];
    manualPath = [aManualPath copy];    
    [[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSlowControlModelManualPathChanged object:self];
}

- (NSMutableArray*) setpointRequestsQueue
{
    return setpointRequestsQueue;
}

- (void) setSetpointRequestsQueue:(NSMutableArray*)aSetpointRequestsQueue
{
	//never used
#if 0
    [aSetpointRequestsQueue retain];
    [setpointRequestsQueue release];
    setpointRequestsQueue = aSetpointRequestsQueue;
#endif
}

- (int) setpointRequestsQueueCount
{	
	if(!setpointRequestsQueue) return 0;
	return [setpointRequestsQueue count];  
}



//is private but left here because it belongs to 'sendSetpointRequestQueue'
//sort requests into a tree ...
- (void) fillRequest:(NSDictionary*)unusedobj intoTree:(NSMutableDictionary*)requestTree accordingTo:(NSArray*)pathThroughTree level:(int)level
{
	NSString *currLevelString = [pathThroughTree objectAtIndex:level];
	id obj=[requestTree objectForKey:currLevelString];
	if(!obj){//item not in tree: create it ...
		obj=[NSMutableDictionary dictionary];
		[requestTree setObject: obj forKey: currLevelString];
	}
	
	//level == 0: URL; 1:db_server; 2:database; 3: group; 4: (control) item
	if(level<4){
		[self fillRequest: unusedobj intoTree: obj accordingTo: pathThroughTree level: level+1];
	}
	
	if(level==4){
		[obj setObject:[unusedobj objectForKey:@"Setpoint"] forKey:@"Setpoint"];
	}
}




//to see the debug output for the request list handling uncomment this line (-tb- 2011-01),
//TODO: to switch off debug output comment out this line: ------------------------------------->
//#define SHOW_REQUEST_LIST_DEBUG_OUTPUT



//is private but left here because it belongs to 'sendSetpointRequestQueue'
//generate a request list of sensor groups out of the tree created with fillRequest:intoTree:...
- (void) traverseTree:(NSMutableDictionary*)theTree level:(int)level requestString:(NSMutableString*)aString requestStringList:(NSMutableArray*)requestStringList
{
	if(level>=5) return;
	
	if(aString==nil) aString=[NSMutableString stringWithCapacity:1000];
	
	NSInteger count = [theTree count];
	id objects[count];
	id keys[count];
	[theTree getObjects:objects andKeys:keys];
	
	int i;
	for (i = 0; i < count; i++) {
		id obj = objects[i];
		id key = keys[i];
		#ifdef SHOW_REQUEST_LIST_DEBUG_OUTPUT
		//NSLog(@"%@ -> %@", obj, key);
		if(level<=3){
			NSLog(@"level %i -> %@  \n", level, key);
		}else if(level==4){
			NSLog(@"level %i -> %@ (setpoint %@) \n", level, key,[obj objectForKey: @"Setpoint"]);
		}
		#endif
		NSMutableString *nextLevelString=[[aString mutableCopy] autorelease];
		switch(level){
		    case 0: //URL
				[nextLevelString appendString:[NSString stringWithFormat:@"%@services/control.php?target=send",key]];
		    break;
		    case 1: //db_server
				[nextLevelString appendString:[NSString stringWithFormat:@"&db_server=%@",key]];
		    break;
			case 2: //db_name
				[nextLevelString appendString:[NSString stringWithFormat:@"&db_name=%@",key]];
			break;
			case 3: //group
				[nextLevelString appendString:[NSString stringWithFormat:@"&control_group=%@",key]];
			break;
			case 4: break;//handle below - this is the item list + setpoint list
			default: NSLog(@" traverseTree:level:requestString:requestStringList: bad level value:%@   \n", level); break;
		}

		if(level<=3){
			[self traverseTree:obj level:level+1 requestString:nextLevelString requestStringList:requestStringList];
		}else{
			//NSLog(@" Setpoint:%@   \n", [obj objectForKey: @"Setpoint"]);
		}		
	}
	
	if(level==4){
		NSMutableString *nextLevelString=[[aString mutableCopy]autorelease];
		[nextLevelString appendString:[NSString stringWithFormat:@"&control_mask="]];
		for (i = 0; i < count; i++) {
			id key = keys[i];
			[nextLevelString appendString:[NSString stringWithFormat:@"%@",key]];
			if(i<count-1) [nextLevelString appendString:@","]; // omit last comma
		}
		[nextLevelString appendString:[NSString stringWithFormat:@"&control_values="]];
		for (i = 0; i < count; i++) {
			id obj = objects[i];
			[nextLevelString appendString:[NSString stringWithFormat:@"%@",[obj objectForKey: @"Setpoint"]]];
			if(i<count-1) [nextLevelString appendString:@","]; // omit last comma
		}
		[requestStringList addObject:nextLevelString];
	}
	
}







- (BOOL) showDebugOutput
{
    return showDebugOutput;
}

- (void) setShowDebugOutput:(BOOL)aShowDebugOutput
{
    [[[self undoManager] prepareWithInvocationTarget:self] setShowDebugOutput:showDebugOutput];
    showDebugOutput = aShowDebugOutput;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSlowControlModelShowDebugOutputChanged object:self];
}

- (BOOL) shipRecords
{
    return shipRecords;
}

- (void) setShipRecords:(BOOL)aShipRecords
{
    [[[self undoManager] prepareWithInvocationTarget:self] setShipRecords:shipRecords];
    shipRecords = aShipRecords;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSlowControlModelShipRecordsChanged object:self];
}

- (int) totalRequestCount
{
    return totalRequestCount;
}

- (void) setTotalRequestCount:(int)aTotalRequestCount
{
    totalRequestCount = aTotalRequestCount;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSlowControlModelTotalRequestCountChanged object:self];
}

- (int) timeOutCount
{
    return timeOutCount;
}

- (void) setTimeOutCount:(int)aTimeOutCount
{
    timeOutCount = aTimeOutCount;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSlowControlModelTimeOutCountChanged object:self];
}

- (BOOL) fastGenSetup
{
    return fastGenSetup;
}

- (void) setFastGenSetup:(BOOL)aFastGenSetup
{
    [[[self undoManager] prepareWithInvocationTarget:self] setFastGenSetup:fastGenSetup];
    fastGenSetup = aFastGenSetup;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSlowControlModelFastGenSetupChanged object:self];
}

- (double) setPoint
{
    return setPoint;
}

- (void) setSetPoint:(double)aSetPoint
{
    [[[self undoManager] prepareWithInvocationTarget:self] setSetPoint:setPoint];
    setPoint = aSetPoint;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSlowControlModelSetPointChanged object:self];
}

- (int) itemType
{
    return itemType;
}

- (void) setItemType:(int)aItemType
{
    [[[self undoManager] prepareWithInvocationTarget:self] setItemType:itemType];
    itemType = aItemType;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSlowControlModelItemTypeChanged object:self];
}

- (BOOL) viewItemName
{
    return viewItemName;
}

- (void) setViewItemName:(BOOL)aViewItemName
{
    [[[self undoManager] prepareWithInvocationTarget:self] setViewItemName:viewItemName];
    viewItemName = aViewItemName;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSlowControlModelViewItemNameChanged object:self];
}

- (NSUInteger) connectionHistoryCount
{
	return [connectionHistory count];
}

- (id) connectionHistoryItem:(NSUInteger)index
{
	if(connectionHistory && index<[connectionHistory count])return [connectionHistory objectAtIndex:index];
	else return nil;
}

- (NSUInteger) ipNumberIndex
{
	return ipNumberIndex;
}

- (NSString*) IPNumber
{
	if(!IPNumber)return @"";
    return IPNumber;
}

- (void) setIPNumber:(NSString*)aIPNumber
{
	if(!aIPNumber) aIPNumber = @"http://ipepdvadei.ka.fzk.de/adei";
	[[[self undoManager] prepareWithInvocationTarget:self] setIPNumber:IPNumber];
	
	[IPNumber autorelease];
	IPNumber = [aIPNumber copy];    
	
	//load into the connection history for the comboxbox popup
	if(!connectionHistory)connectionHistory = [[NSMutableArray alloc] init];
	if(![connectionHistory containsObject:IPNumber]){
		[connectionHistory addObject:IPNumber];
	}
	ipNumberIndex = [connectionHistory indexOfObject:aIPNumber];
	
	[[NSUserDefaults standardUserDefaults] setObject:connectionHistory forKey:[NSString stringWithFormat:@"orca.%@.ConnectionHistory",[self className]]];
	[[NSUserDefaults standardUserDefaults] setInteger:ipNumberIndex forKey:[NSString stringWithFormat:@"orca.%@.IPNumberIndex",[self className]]];
	[[NSUserDefaults standardUserDefaults] synchronize];
	
	[[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSlowControlIPNumberChanged object:self];
}

- (NSString*) ipNumberToURL
{
	//convert a host name xxx.xxx.xxx to a url of form http://xxxx.xxx.xxx
	NSMutableString* goodUrl = [NSMutableString stringWithString: [self IPNumber]];
	if([goodUrl length]){
		if(![goodUrl hasPrefix:   @"http://"]) [goodUrl insertString: @"http://"  atIndex: 0];
		if(![goodUrl hasSuffix:   @"/"]) [goodUrl appendString: @"/"];
	}
	return goodUrl;
}

- (NSString*) lastRequest
{
	if(!lastRequest)return @"";
	return lastRequest;
}

- (void) setLastRequest:(NSString*)aString
{
	if([aString length]==0)aString = @"";
	[aString autorelease];
	lastRequest = [aString copy];
	[[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSlowControlLastRequestChanged object:self];
}

- (int) pollTime
{
    return pollTime;
}

- (void) setPollTime:(int)aPollTime
{
    [[[self undoManager] prepareWithInvocationTarget:self] setPollTime:pollTime];
    pollTime = aPollTime;
    [[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSlowControlPollTimeChanged object:self];
	
	if(pollTime)[self performSelector:@selector(pollSlowControls) withObject:nil afterDelay:2];
	else		[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(pollSlowControls) object:nil];
}

- (void) setDataIds:(id)assigner
{
    channelDataId = [assigner assignDataIds:kLongForm];
}

- (void) syncDataIdsWith:(id)anotherObject
{
    [self setChannelDataId:     [anotherObject channelDataId]];
}

- (int) channelDataId
{
    return channelDataId;
}

- (void) setChannelDataId:(int) aValue
{
    channelDataId = aValue;
}

- (void) dumpSensorlist
{
	NSLog(@"requestCache:\n%@\n",requestCache);
	NSLog(@"channelLookup:\n%@\n",channelLookup);
	NSLog(@"pollingLookUp:\n%@\n",pollingLookUp);
}

#pragma mark ***Polled Item via LookupTable index
- (BOOL) itemExists:(int)anIndex
{
	return anIndex<[pollingLookUp count];//TODO: this may be wrong as we can have gaps in the channel numbers? -tb-
}

- (BOOL) isControlItem:(int)anIndex
{
	//anIndex is NOT the channel Number
	if(anIndex<[pollingLookUp count]){
		NSString* itemKey = [pollingLookUp objectAtIndex:anIndex];
		NSDictionary* topLevelDictionary = [requestCache objectForKey:itemKey];
		NSDictionary* itemDictionary = [topLevelDictionary objectForKey:itemKey];
		return [itemDictionary objectForKey:@"Control"]!=nil;
	}
	else return NO;
}

- (BOOL) isControlItemWithItemKey:(NSString*)itemKey
{
		NSDictionary* topLevelDictionary = [requestCache objectForKey:itemKey];
		NSDictionary* itemDictionary = [topLevelDictionary objectForKey:itemKey];
		return [itemDictionary objectForKey:@"Control"]!=nil;
}

- (NSString*) requestCacheItemKey:(int)anIndex
{
	//Note: index is NOT channel, it is the index of the item in the details panel
	//use the lookup table to return the polingCache's topLevelDictionary
	//to have fast access by index to the requestCache, there is a lookupTable Array of the 
	//form: itemKey0,itemKey1,itemKey2....
	if(anIndex<[pollingLookUp count]){
		return [pollingLookUp objectAtIndex:anIndex];
	}
	else return nil;
}

- (NSDictionary*) requestCacheItem:(int)anIndex
{
	//Note: index is NOT channel, it is the index of the item in the details panel
	//use the lookup table to return the polingCache's topLevelDictionary
	//to have fast access by index to the requestCache, there is a lookupTable Array of the 
	//form: itemKey0,itemKey1,itemKey2....
	if(anIndex<[pollingLookUp count]){
		NSString* itemKey = [pollingLookUp objectAtIndex:anIndex];
		NSDictionary* topLevelDictionary = [requestCache objectForKey:itemKey];
		return [topLevelDictionary objectForKey:itemKey];
	}
	else return nil;
}

- (NSUInteger) pollingLookUpCount
{
	return [pollingLookUp count];
}

- (NSString*) createWebRequestForItem:(int)anIndex
{
	//anIndex is NOT the channel number
	//examples for a single sensor request:
	//fuzzy.fzk.de/adei/#db_server=katrin&db_name=hauptspektrometer&db_group=0&db_mask=1&experiment=0-0&window=0&history_id=1232130010554
	//fuzzy.fzk.de/adei/#db_server=katrin&db_name=hauptspektrometer&db_group=0&db_mask=1&experiment=0-0&window=0
	//fuzzy.fzk.de/adei/#minimal=graph&db_server=katrin&db_name=hauptspektrometer&db_group=0&db_mask=1&window=0
	NSString* requestString = nil;
	if(anIndex<[pollingLookUp count]){
		NSString* itemKey	= [pollingLookUp objectAtIndex:anIndex];
		NSDictionary* topLevelDictionary = [requestCache objectForKey:itemKey];
		NSDictionary* itemDictionary	 = [topLevelDictionary objectForKey:itemKey];
		NSString* url		= [itemDictionary objectForKey:@"URL"];
		NSString* path		= [itemDictionary objectForKey:@"Path"];
		requestString = [ORAdeiLoader webRequestStringUrl:url itemPath:path];
		[self setTotalRequestCount:totalRequestCount+1];
	}
	return requestString;
}


#pragma mark •••Polled item access via itemKey
- (NSMutableDictionary*) topLevelPollingDictionary:(id)anItemKey
{
	return [requestCache objectForKey:anItemKey];
}

#pragma mark •••Channel Loop Up Methods
- (void) makeChannelLookup
{
	[channelLookup release];
	channelLookup = [[NSMutableDictionary dictionary] retain];
	for(id itemKey in pollingLookUp){ //TODO: we need to see the channels used by scripts ... -tb-
		NSDictionary* topLevelDictionary = [requestCache objectForKey:itemKey];
		id channelNumber = [topLevelDictionary objectForKey:@"ChannelNumber"];
		if(channelNumber){
			[channelLookup setObject:itemKey forKey:channelNumber];
		}
	}
}


- (BOOL) channelExists:(int)aChan
{
	NSString* itemKey = [channelLookup objectForKey:[NSNumber numberWithInt:aChan]];
    return (itemKey!=nil);
}


- (int) nextUnusedChannelNumber
{
	int proposedIndex = 0;
	do {
		BOOL alreadyUsed = NO;
		for(id itemKey in pollingLookUp){
			NSDictionary* topLevelDictionary = [requestCache objectForKey:itemKey];
			int aChannelNumber = [[topLevelDictionary objectForKey:@"ChannelNumber"] intValue];
			if(aChannelNumber == proposedIndex){
				alreadyUsed = YES;
				proposedIndex++;
				break; //no need to continue this loop
			}
		}
		if(!alreadyUsed)break;
	} while(1);
	return proposedIndex;
}
- (int) channelNumberForItemKey:(NSString*) anItemKey;
{
        NSMutableDictionary* topLevelDictionary = [requestCache objectForKey: anItemKey];
        int chan=-1;
        id chanNumObj = [topLevelDictionary objectForKey:@"ChannelNumber"];
        if(chanNumObj) chan = [chanNumObj intValue];
		return chan;
        //TODO:  or better search itemKey in channelLookup -> ensure that this is always up to date -tb-
}

//!We return the channel which was set; if the channel already exists, a negative number is returned
- (int) setChannelNumber:(int) aChan forItemKey:(NSString*) anItemKey 
{
    NSMutableDictionary* topLevelDictionary = [requestCache objectForKey: anItemKey];
    if(!topLevelDictionary) return -2;
    int oldChan = [self channelNumberForItemKey: anItemKey];
    if(oldChan == aChan) return aChan; //nothing to do
    [[[self undoManager] prepareWithInvocationTarget:self] setChannelNumber:oldChan forItemKey:anItemKey];
    [topLevelDictionary setObject:[NSNumber numberWithInt:aChan]	forKey:@"ChannelNumber"]; //channel number for access by the processing system
    
    //fill it into the channelLookup
    if(channelLookup){
        [channelLookup removeObjectForKey: [NSNumber numberWithInt: oldChan]];
        [channelLookup setObject:anItemKey  forKey: [NSNumber numberWithInt: aChan]];
    }
    
#if 0  // must be done somewhere else (addItemKeyToPollingLookup, removeItemKeyFromPollingLookup)-tb-
    //pollingLookup
    NSLog( @"setChannelNumber: pollingLookup: key %@, oldch  %i  new ch %i",anItemKey,oldChan,aChan);
    if(oldChan<0 && aChan>=0){
     [pollingLookUp addObject:anItemKey];//[self addItemKeyToPollingLookup:anItemKey];  //adding new item to polling lookup
    }
    if(oldChan>=0 && aChan<0) [pollingLookUp removeObject:anItemKey];// [self removeItemKeyFromPollingLookup:anItemKey];  //adding new item to polling lookup
#endif
    //NSLog( @"setChannelNumber: itemkey:%@, old chan %i, new chan %i\n",anItemKey,oldChan,aChan);

    [[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSlowControlItemListChanged object:self];
    return aChan;
}

#pragma mark •••Polling Cache Management
//addItems to the polling loop
- (void) addItems:(NSArray*)anItemArray
{
	if(!requestCache)   requestCache = [[NSMutableDictionary dictionary] retain];
	if(!pollingLookUp)  pollingLookUp = [[NSMutableArray array] retain];
	for(id anItem in anItemArray){
		NSString* itemKey = [self itemKey:[anItem objectForKey:@"URL"] path:[anItem objectForKey:@"Path"]];
		
		if(![pollingLookUp containsObject:itemKey]){
			//we have never seen this item before, so add it alone with some extra info for the processing system
			//item not in the list yet... add it
			int aChannelNumber = [self nextUnusedChannelNumber]; //find an unused channel number in the polling List
			NSMutableDictionary* topLevelDictionary = [self makeTopLevelDictionary];
			[topLevelDictionary setObject:anItem forKey:itemKey];		
			//example of anItem: {    Date = "14-Dec-11 16:19:43.000000";    Name = " item1 [Temperatures]";    Path = "test_zeus/cfp_test/0/1";
            //                        URL = "http://ipepdvadei2.ka.fzk.de/test/";    Value = " 8.0786074540863";  }	
			[topLevelDictionary setObject:[NSNumber numberWithInt:aChannelNumber]	forKey:@"ChannelNumber"]; //channel number for access by the processing system
			//or [self setChannelNumber:aChannelNumber  forItemKey:itemKey]; // with undo ...
            
			[requestCache setObject:topLevelDictionary forKey:itemKey];
			[self addItemKeyToPollingLookup:itemKey];
		}
	}
}

- (void) removeSet:(NSIndexSet*)aSetToRemove
{
	NSMutableArray* itemsToRemove = [NSMutableArray array];
	NSUInteger current_index = [aSetToRemove firstIndex];
    while (current_index != NSNotFound) {
		if(current_index<[pollingLookUp count]){
			NSString* itemKey = [self requestCacheItemKey:current_index];
			[itemsToRemove addObject:itemKey];
		}
		current_index = [aSetToRemove indexGreaterThanIndex: current_index];
    }
	for(id aKey in itemsToRemove){
		[self removeItemKeyFromPollingLookup:aKey];
	}
}


- (NSMutableDictionary*) makeTopLevelDictionary
{
	NSMutableDictionary* topLevelDictionary = [NSMutableDictionary dictionary];
	[topLevelDictionary setObject:[NSNumber numberWithInt:0]		forKey:@"LoAlarm"]; //used by processing
	[topLevelDictionary setObject:[NSNumber numberWithInt:100]		forKey:@"HiAlarm"]; //used by processing
	[topLevelDictionary setObject:[NSNumber numberWithInt:0]		forKey:@"LoLimit"]; //used by processing
	[topLevelDictionary setObject:[NSNumber numberWithInt:100]		forKey:@"HiLimit"]; //used by processing
	[topLevelDictionary setObject:[NSNumber numberWithInt:-1]		forKey:@"ChannelNumber"];   //used for initializing
	[topLevelDictionary setObject:@"--"		forKey:@"DBValue"];     //used for initializing
	[topLevelDictionary setObject:@"--"     forKey:@"DBTimestamp"]; //used for initializing
	return topLevelDictionary;
}


#pragma mark •••Item Tree Management
- (void) setItemTreeRoot:(NSMutableArray*)anArray
{
	[anArray retain];
	[itemTreeRoot release];
	itemTreeRoot = anArray;
	[[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSlowItemTreeChanged object:self];
}

- (NSArray*) itemTreeRoot
{
	return itemTreeRoot;
}

- (void) loadItemTree
{
	[itemTreeRoot release];
	itemTreeRoot = nil;
	[[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSlowItemTreeChanged object:self];
	ORAdeiLoader* aLoader = [ORAdeiLoader loaderWithAdeiHost:[self ipNumberToURL] adeiType:itemType delegate:self didFinishSelector:@selector(itemTreeResults:path:)];
    [aLoader setShowDebugOutput: showDebugOutput];//TODO: timeout debugging -tb-
	[aLoader loadPath:@"/" recursive:YES];
}

- (NSString*) itemDetails:(int)anIndex
{
	//anIndex is NOT channel number
	if(anIndex<[pollingLookUp count]){
		NSString* itemKey = [pollingLookUp objectAtIndex:anIndex];
		id topLevelDictionary = [requestCache objectForKey:itemKey];
		NSString* s = [topLevelDictionary description];
		s = [s stringByReplacingOccurrencesOfString:@"{" withString:@""];
		s = [s stringByReplacingOccurrencesOfString:@"}" withString:@""];
		s = [s stringByReplacingOccurrencesOfString:@"\t" withString:@""];
		s = [s stringByReplacingOccurrencesOfString:@";" withString:@""];
		return s;
	}
	else return @"<Error: index out of bounds>";
}


//create new channel item, return channel number or -1 for failure; if aChan==-1 choose first unused channel
- (int)  createChannelWithUrl:(NSString*)aUrl path:(NSString*)aPath chan:(int)aChan controlType:(int)isControl
{
//input: URL, manual path, controlType, channelNumber

	//CHECK WHETHER PATH has length 4 and URL not empty ...  -tb-
	int componentCount = [[aPath componentsSeparatedByString:@"/"] count];
	if(componentCount!=4){
	    NSLog(@"Path %@ needs to have 4 items, but has %i items!\n",manualPath,componentCount);
	    return -1;
	}

	//convert a host name xxx.xxx.xxx to a url of form http://xxxx.xxx.xxx, see - (NSString*) ipNumberToURL
	NSMutableString* goodUrl = [NSMutableString stringWithString: aUrl];
	if([goodUrl length]){
		if(![goodUrl hasPrefix:   @"http://"]) [goodUrl insertString: @"http://"  atIndex: 0];
		if(![goodUrl hasSuffix:   @"/"]) [goodUrl appendString: @"/"];
	}

    NSString* itemKey = nil;
    itemKey = [self itemKey:goodUrl path:aPath];
	NSMutableDictionary* topLevelDictionary = [requestCache objectForKey:itemKey];
	if(topLevelDictionary){//channel/item already exists
	    //search the channel
//		int ch = [self channelNumberForItemKey: itemKey];
		int ch = [[topLevelDictionary objectForKey:@"ChannelNumber"] intValue];
        
		if(ch == -1){
	        //NSLog(@"Item %@ previously was removed!\n",itemKey);
		}else{
            int existingIsControl = ([self isControlItemWithItemKey: itemKey] ? 1 : 0);//I need 0 or 1, not bool ...
            if(existingIsControl == isControl){
    	        NSLog(@"Item key %@ already exists with channel %i!\n",itemKey,ch);
            }else{
    	        NSLog(@"Item key %@ already exists with different sensor/control type with channel %i!\n",itemKey,ch);
    	        NSLog(@"For internal reasons this is not allowed! USE A SECOND ADEI OBJECT TO USE THIS ITEM!\n");
            }
            return ch;
		}
	}

    //see - (void) addItems:(NSArray*)anItemArray
	int aChannelNumber = aChan; 
	if( nil != [channelLookup objectForKey:[NSNumber numberWithInt:aChan]]) aChan = -1; // if chan is already used, choose a other chan number
	if(aChan==-1) aChannelNumber = [self nextUnusedChannelNumber]; //find an unused channel number in the polling List
	topLevelDictionary = [self makeTopLevelDictionary];
	[topLevelDictionary setObject:[NSNumber numberWithInt:aChannelNumber]	forKey:@"ChannelNumber"]; //channel number for access by the processing system
	//make second level dictionary (see requestCache) (( = itemDictionary))
			//example of secondLevelDictionary: {    Date = "14-Dec-11 16:19:43.000000";    Name = " item1 [Temperatures]";    Path = "test_zeus/cfp_test/0/1";
            //                                       URL = "http://ipepdvadei2.ka.fzk.de/test/";    Value = " 8.0786074540863";  }	
	//NSMutableDictionary* secondLevelDictionary = [NSMutableDictionary dictionary];
	NSMutableDictionary* secondLevelDictionary = [NSMutableDictionary dictionaryWithObjectsAndKeys:
	    @"yet unknown",    @"Name",
		goodUrl,           @"URL",
		aPath,			   @"Path",
	    @"--",             @"Value",
	nil ];
	if(isControl==1) [secondLevelDictionary setValue:[NSNumber numberWithInt:1]  forKey:@"Control"];
	[topLevelDictionary setObject:secondLevelDictionary	forKey:itemKey]; 

	
	[requestCache setObject:topLevelDictionary forKey:itemKey];
	[self addItemKeyToPollingLookup:itemKey];
	//return topLevelDictionary;

    return aChannelNumber;
}

- (void) manuallyCreateChannel
{
	//NSLog(@"called %@::%@ \n",NSStringFromClass([self class]),NSStringFromSelector(_cmd));//TODO: debug output -tb-
	//NSLog(@"Create with: Url: %@  (%@),   Path:%@  , Type:%i  \n", IPNumber, [self ipNumberToURL]  ,manualPath, manualType);

    [self createChannelWithUrl:[self ipNumberToURL] path:manualPath chan:-1 controlType:manualType];
}



- (NSString*) itemKey:aUrl path:aPath
{
    if(aUrl==nil || aPath==nil) return nil;
	if([aPath hasPrefix:@"/"])return [NSString stringWithFormat:@"%@%@",aUrl,aPath];
	else return [NSString stringWithFormat:@"%@/%@",aUrl,aPath];
}

#pragma mark •••Archival
- (id) initWithCoder:(NSCoder*)decoder
{
	self = [super initWithCoder:decoder];

	[[self undoManager] disableUndoRegistration];
	
 	[self initConnectionHistory];
   
    [self initBasics];
	[self setRePostStillPendingRequests:[decoder decodeIntForKey:@"rePostStillPendingRequests"]];
	[self setManualType:		[decoder decodeIntForKey:@"manualType"]];
	[self setManualPath:		[decoder decodeObjectForKey:@"manualPath"]];
	[self setShowDebugOutput:	[decoder decodeBoolForKey:    @"showDebugOutput"]];
	[self setShipRecords:		[decoder decodeBoolForKey:	  @"shipRecords"]];
	[self setFastGenSetup:		[decoder decodeBoolForKey:	  @"fastGen"]];
	[self setSetPoint:			[decoder decodeDoubleForKey:  @"setPoint"]];
	[self setItemType:			[decoder decodeIntForKey:	  @"itemType"]];
	[self setViewItemName:		[decoder decodeBoolForKey:	  @"viewItemName"]];
	[self setPollTime:			[decoder decodeIntForKey:	  @"pollTime"]];
	[self setIPNumber:			[decoder decodeObjectForKey:  @"IPNumber"]];
	//[self setItemTreeRoot:		[decoder decodeObjectForKey:  @"itemTreeRoot"]]; //commented out: let the user load the tree
	
	requestCache =				[[decoder decodeObjectForKey: @"requestCache"]retain];
	pollingLookUp =				[[decoder decodeObjectForKey: @"pollingLookUp"]retain];

	if(!requestCache)   requestCache = [[NSMutableDictionary dictionary] retain];
	if(!pollingLookUp)  pollingLookUp = [[NSMutableArray array] retain];

	[self makeChannelLookup];
	[[self undoManager] enableUndoRegistration];
     
	
	return self;
}

- (void) encodeWithCoder:(NSCoder*)encoder
{
    [super encodeWithCoder:encoder];    
	[encoder encodeInt:rePostStillPendingRequests forKey:@"rePostStillPendingRequests"];
	[encoder encodeInt:manualType			forKey:@"manualType"];
	[encoder encodeObject:manualPath		forKey:@"manualPath"];
	[encoder encodeBool:showDebugOutput		forKey:@"showDebugOutput"];
	[encoder encodeBool:shipRecords			forKey:@"shipRecords"];
	[encoder encodeBool:fastGenSetup		forKey:@"fastGen"];
	[encoder encodeDouble:setPoint			forKey:@"setPoint"];
	[encoder encodeInt:itemType				forKey:@"itemType"];
	[encoder encodeBool:viewItemName		forKey:@"viewItemName"];
	[encoder encodeInt:pollTime				forKey:@"pollTime"];
 	[encoder encodeObject:IPNumber			forKey:@"IPNumber"];
 	//[encoder encodeObject:itemTreeRoot		forKey:@"itemTreeRoot"];
 	[encoder encodeObject:pollingLookUp		forKey:@"pollingLookUp"];
	//only store the part of the requestCache that is polled
	NSMutableDictionary* itemsToStore = [NSMutableDictionary dictionary];
	for(id itemKey in pollingLookUp){
		NSDictionary* topLevelDictionary = [requestCache objectForKey:itemKey];
		[itemsToStore setObject:topLevelDictionary forKey:itemKey];
	}
 	[encoder encodeObject:itemsToStore		forKey:@"requestCache"];
	
}

- (NSDictionary*) dataRecordDescription
{
    NSMutableDictionary* dataDictionary = [NSMutableDictionary dictionary];
    NSDictionary* aDictionary = [NSDictionary dictionaryWithObjectsAndKeys:
								 @"ORIpeSlowControlDecoderForChannelData",  @"decoder",
								 [NSNumber numberWithLong:channelDataId],   @"dataId",
								 [NSNumber numberWithBool:YES],       @"variable",
								 [NSNumber numberWithLong:-1],        @"length",
								 nil];
    [dataDictionary setObject:aDictionary forKey:@"ChannelData"];
    return dataDictionary;
}

//put out parameters into the header. Called automagically.
- (NSMutableDictionary*) addParametersToDictionary:(NSMutableDictionary*)dictionary
{    
    NSMutableDictionary* objDictionary = [super addParametersToDictionary:dictionary];
	NSMutableDictionary* itemsToPutInHeader = [NSMutableDictionary dictionary];
	for(id itemKey in pollingLookUp){
		NSDictionary* topLevelDictionary = [requestCache objectForKey:itemKey];
		[itemsToPutInHeader setObject:topLevelDictionary forKey:itemKey];
	}
    [objDictionary setObject:itemsToPutInHeader forKey:@"WatchedItems"];    	
    return objDictionary;
}

- (void) appendDataDescription:(ORDataPacket*)aDataPacket userInfo:(NSDictionary*)userInfo
{
    [aDataPacket addDataDescriptionItem:[self dataRecordDescription] forKey:@"IP320"];
}

#pragma mark •••Related to Adc or Bit Processing Protocol
// methods for setting LoAlarm, HiAlarm, LoLimit (=minValue), HiLimit (=maxValue)
- (void) setLoAlarmForChan:(int)channel value:(double)aValue
{
    NSString *itemKey = [channelLookup objectForKey:[NSNumber numberWithInt:channel]];
	NSMutableDictionary* topLevelDictionary	= [requestCache objectForKey:itemKey];
	[topLevelDictionary setObject: [NSString stringWithFormat:@"%f",aValue] forKey: @"LoAlarm"];
}

- (void) setHiAlarmForChan:(int)channel value:(double)aValue
{
    NSString *itemKey = [channelLookup objectForKey:[NSNumber numberWithInt:channel]];
	NSMutableDictionary* topLevelDictionary	= [requestCache objectForKey:itemKey];
	[topLevelDictionary setObject: [NSString stringWithFormat:@"%f",aValue] forKey: @"HiAlarm"];
}

- (void) setLoLimitForChan:(int)channel value:(double)aValue
{
    NSString *itemKey = [channelLookup objectForKey:[NSNumber numberWithInt:channel]];
	NSMutableDictionary* topLevelDictionary	= [requestCache objectForKey:itemKey];
	[topLevelDictionary setObject: [NSString stringWithFormat:@"%f",aValue] forKey: @"LoLimit"];
}

- (void) setHiLimitForChan:(int)channel value:(double)aValue
{
    NSString *itemKey = [channelLookup objectForKey:[NSNumber numberWithInt:channel]];
	NSMutableDictionary* topLevelDictionary	= [requestCache objectForKey:itemKey];
	[topLevelDictionary setObject: [NSString stringWithFormat:@"%f",aValue] forKey: @"HiLimit"];
}


#pragma mark •••Adc or Bit Processing Protocol
/** This is called once per "processing" cycle and is called at the begin of the process cycle.
  * The process control calls (also in test mode): processIsStarting, multiple times (startProcessCycle, endProcessCycle) , processIsStopping
  * The ORAdcModel calls (not in test mode!):  
  @verbatim
  normal cycle is:
    maxValueForChan:
    minValueForChan:
    getAlarmRangeLow:high:channel:
    convertedValue:    
  @endverbatim
  
  * <br>
  * The protocol ORAdcProcessing is in: ORAdcProcessing.h
  * The protocol ORBitProcessing is in: ORBitProcessing.h
  */
//note that everything called by these routines MUST be threadsafe
- (void) processIsStarting
{
	//called when processing is started. nothing to do for now. 
	//called at the HW polling rate in the process dialog. 
	//For now we just use the local polling
}

- (void)processIsStopping
{
	//called when processing is stopping. nothing to do for now.
}

- (void) startProcessCycle
{
	//called at the HW polling rate in the process dialog. 
	//ignore for now.
}

- (void) endProcessCycle
{
}

- (NSString*) processingTitle
{
    return [NSString stringWithFormat: @"%@-%lu",IPE_SLOW_CONTROL_SHORT_NAME,[self uniqueIdNumber]];
}


- (void) setProcessOutput:(int)channel value:(int)value
{
    //nothing to do
}

/** Note: Adc  Processing supports 30 channels; shipping SC packs channel number into 16 bit (0x00-0xff or 0 ... 255).
  * But there is no limit to the channel number (except it must be a int).
  *
  */ //-tb-
- (BOOL) processValue:(int)channel
{
	return [self convertedValue:channel]!=0;
}

//!convertedValue: and valueForChan: are the same.
- (double) convertedValue:(int)channel
{    
    return [self valueForChan:channel];
}

- (double) maxValueForChan:(int)channel
{
	NSString* itemKey = [channelLookup objectForKey:[NSNumber numberWithInt:channel]];
	if(itemKey){
		NSDictionary* topLevelDictionary = [requestCache objectForKey: itemKey];
		return [[topLevelDictionary objectForKey:@"HiLimit"] doubleValue];
	}
	return 0; // return something if channel number out of range
}

- (double) lowAlarm:(int)channel
{    
	NSString* itemKey = [channelLookup objectForKey:[NSNumber numberWithInt:channel]];
	if(itemKey){
		NSDictionary* topLevelDictionary = [requestCache objectForKey: itemKey];
		return [[topLevelDictionary objectForKey:@"LoAlarm"] doubleValue];
	}
	return 0; // return something if channel number out of range
}

- (double) highAlarm:(int)channel
{
	NSString* itemKey = [channelLookup objectForKey:[NSNumber numberWithInt:channel]];
	if(itemKey){
		NSDictionary* topLevelDictionary = [requestCache objectForKey: itemKey];
		return [[topLevelDictionary objectForKey:@"HiAlarm"] doubleValue];
	}
	return 0; // return something if channel number out of range
}

- (double) minValueForChan:(int)channel
{
	NSString* itemKey = [channelLookup objectForKey:[NSNumber numberWithInt:channel]];
	if(itemKey){
		NSDictionary* topLevelDictionary = [requestCache objectForKey: itemKey];
		return [[topLevelDictionary objectForKey:@"LoLimit"] doubleValue];
	}
	return 0; // return something if channel number out of range
}

//alarm limits for the processing framework.
- (void) getAlarmRangeLow:(double*)theLowLimit high:(double*)theHighLimit  channel:(int)channel
{	
	NSString* itemKey = [channelLookup objectForKey:[NSNumber numberWithInt:channel]];
	if(itemKey){
		NSDictionary* topLevelDictionary = [requestCache objectForKey: itemKey];
		*theLowLimit  =  [[topLevelDictionary objectForKey:@"LoAlarm"]doubleValue] ;
		*theHighLimit  =  [[topLevelDictionary objectForKey:@"HiAlarm"]doubleValue] ;
	}
}

#pragma mark •••polling
- (void) pollSlowControls
{
	///
	//TODO
	//-----collect requests for groups into one request. The response code should handle the result...
	//TODO
	//
	NSArray* setupOptions = nil;
	if(fastGenSetup){
		setupOptions = [NSArray arrayWithObjects:@"fastgen",nil];
	}
	[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(pollSlowControls) object:nil];
	for(id anItemKey in pollingLookUp){
		if([self requestIsPending:anItemKey]){//request is still pending
            NSLog( @"You posted a request for a still pending request: %@\n",anItemKey);
            if(![self rePostStillPendingRequests]) continue;
            else NSLog( @"Repeating the request! WARNING - may overload the ADEI server!\n");
        }
		id topLevelDictionary = [requestCache objectForKey:anItemKey];
		id anItem = [topLevelDictionary objectForKey:anItemKey];
		int aType = [[anItem objectForKey:@"Control"] intValue];
		ORAdeiLoader* aLoader = [ORAdeiLoader loaderWithAdeiHost:[anItem objectForKey:@"URL"] adeiType:aType delegate:self didFinishSelector:@selector(polledItemResult:path:) setupOptions:setupOptions];
        [aLoader setShowDebugOutput: showDebugOutput];//TODO: timeout debugging -tb-
		[aLoader requestItem:[anItem objectForKey:@"Path"]];
        [self setPendingRequest:anItemKey];
		[self setTotalRequestCount:totalRequestCount+1];

	}		
	
	if(pollTime)[self performSelector:@selector(pollSlowControls) withObject:nil afterDelay:pollTime];
	
	if(shipRecords) [self shipTheRecords];
}

#pragma mark •••ID Helpers (see OrcaObject)
- (NSString*) identifier
{
    return [NSString stringWithFormat: @"%@-%lu",IPE_SLOW_CONTROL_SHORT_NAME,[self uniqueIdNumber]];
}

#pragma mark •••Methods Useful For Scripting
// listCommonScriptMethods
//-------------should use only these methods in scripts---------------------------------
- (NSString*) commonScriptMethods
{
    NSMutableString *methods = [[NSMutableString alloc] init];
    //I return two types of methods:
	// 1. manually added methods
	NSArray* selectorArray = [NSArray arrayWithObjects:
							  @"convertedValue:(int)channel",
							  @"maxValueForChan:(int)channel",
							  @"minValueForChan:(int)channel",
							  nil];
	
    [methods appendString: [selectorArray componentsJoinedByString:@"\n"]];
    [methods appendString: @"\n"];

	// 2. all methods between methods commonScriptMethodSectionBegin and commonScriptMethodSectionBegin
    [methods appendString: methodsInCommonSection(self)];

    return [methods autorelease];
}


//-------------Methode to flag beginning of common script methods---------------------------------
- (void) commonScriptMethodSectionBegin { }

//Send the request,  wait for response.
- (void) postSensorRequest:(NSString*)aUrl path:(NSString*)aPath
{
//NSLog( @"postSensorRequest: \n");//TODO: debug1
    NSString* anItemKey = [self itemKey:aUrl path:aPath];
//NSLog( @"postSensorRequest: item: %@\n",anItemKey);//TODO: debug1
		if([self requestIsPending:anItemKey]){//request is still pending
            NSLog( @"You posted a request for a still pending item: %@\n",anItemKey);
            if(![self rePostStillPendingRequests]) return;
            else NSLog( @"Repeating the request! WARNING - may overload the ADEI server!\n");
        }
	ORAdeiLoader* aLoader;
	aLoader = [ORAdeiLoader loaderWithAdeiHost:aUrl adeiType:kSensorType delegate:self didFinishSelector:@selector(polledItemResult:path:)];
    [aLoader setShowDebugOutput: showDebugOutput];//TODO: timeout debugging -tb-
	[aLoader requestItem:aPath];
	[self setPendingRequest:anItemKey];
	[self setTotalRequestCount:totalRequestCount+1];
}

//Send the request,  wait for response.
- (void) postControlRequest:(NSString*)aUrl path:(NSString*)aPath
{
//NSLog( @"postControlRequest: \n");//TODO: debug1
    NSString* anItemKey = [self itemKey:aUrl path:aPath];
		if([self requestIsPending:anItemKey]){//request is still pending
            NSLog( @"You posted a request for a still pending item: %@\n",anItemKey);
            if(![self rePostStillPendingRequests]) return;
            else NSLog( @"Repeating the request! WARNING - may overload the ADEI server!\n");
        }
	ORAdeiLoader* aLoader;
	aLoader = [ORAdeiLoader loaderWithAdeiHost:aUrl adeiType:kControlType delegate:self didFinishSelector:@selector(polledItemResult:path:)];
    [aLoader setShowDebugOutput: showDebugOutput];//TODO: timeout debugging -tb-
	[aLoader requestItem:aPath];
	[self setPendingRequest:anItemKey];
	[self setTotalRequestCount:totalRequestCount+1];
}

//Send the request,  wait for response.
- (void) postControlSetpoint:(NSString*)aUrl path:(NSString*)aPath value:(double)aValue
{
    NSString* anItemKey = [self itemKey:aUrl path:aPath];
		if([self requestIsPending:anItemKey]){//request is still pending
            NSLog( @"You posted a request for a still pending item: %@\n",anItemKey);
            if(![self rePostStillPendingRequests]) return;
            else NSLog( @"Repeating the request! WARNING - may overload the ADEI server!\n");
        }
    ORAdeiLoader* aLoader = [ORAdeiLoader loaderWithAdeiHost:aUrl adeiType:kControlType delegate:self didFinishSelector:@selector(polledItemResult:path:)];
    [aLoader setShowDebugOutput: showDebugOutput];//TODO: timeout debugging -tb-
    [aLoader setControlSetpoint:aPath value:aValue];
	[self setPendingRequest:anItemKey];
    [self setTotalRequestCount:totalRequestCount+1];
}

//Just send the request, don't wait for response.
- (void) sendControlSetpoint:(NSString*)aUrl path:(NSString*)aPath value:(double)aValue
{
    NSString* anItemKey = [self itemKey:aUrl path:aPath];
		if([self requestIsPending:anItemKey]){//request is still pending
            NSLog( @"You posted a request for a still pending item: %@\n",anItemKey);
            if(![self rePostStillPendingRequests]) return;
            else NSLog( @"Repeating the request! WARNING - may overload the ADEI server!\n");
        }
    ORAdeiLoader* aLoader = [ORAdeiLoader loaderWithAdeiHost:aUrl adeiType:kControlType delegate:self didFinishSelector:@selector(handleSilentItemResult:path:)];
    [aLoader setShowDebugOutput: showDebugOutput];//TODO: timeout debugging -tb-
    [aLoader sendControlSetpoint:aPath value:aValue];
	[self setPendingRequest:anItemKey];
    [self setTotalRequestCount:totalRequestCount+1];
}

//Just send the request string, don't wait for response.
//extended to store a queueErrorIndex -tb- 2014-04-04
- (void) sendRequestString:(NSString*)requestString withQueueErrorIndex:(int) aIndex;
{
	//NSLog(@"%@::%@: requestString:%@\n",NSStringFromClass([self class]),NSStringFromSelector(_cmd),requestString);//TODO: debug output -tb-

    NSString* anItemKey = [self itemKey:@"requestString" path:requestString];
		if([self requestIsPending:anItemKey]){//request is still pending
            NSLog( @"You posted a request for a still pending item: %@\n",anItemKey);
            if(![self rePostStillPendingRequests]) return;
            else NSLog( @"Repeating the request! WARNING - may overload the ADEI server!\n");
        }
    ORAdeiLoader* aLoader = [ORAdeiLoader loaderWithAdeiType:kRequestStringType delegate:self didFinishSelector:@selector(handleSilentItemResult:path:)];
    [aLoader setShowDebugOutput: showDebugOutput];//TODO: timeout debugging -tb-
    [aLoader setQueueErrorIndex:aIndex];
    [aLoader sendRequestString:requestString];
	[self setPendingRequest:anItemKey];
    [self setTotalRequestCount:totalRequestCount+1];

}

//extended to store a queueErrorIndex -tb- 2014-08-04 - see above
- (void) sendRequestString:(NSString*)requestString
{
    [self sendRequestString:requestString withQueueErrorIndex:-1];
}

/*
NSStringEncoding

Type for string encoding.

typedef NSUInteger NSStringEncoding;

Discussion

See “String Encodings” for possible values.
Availability

    * Available in Mac OS X v10.0 and later.

Declared In
NSString.h
String Encodings

The following constants are provided by NSString as possible string encodings.

enum {
   NSASCIIStringEncoding = 1,
   NSNEXTSTEPStringEncoding = 2,
   NSJapaneseEUCStringEncoding = 3,
   NSUTF8StringEncoding = 4,
   NSISOLatin1StringEncoding = 5,
   NSSymbolStringEncoding = 6,
   NSNonLossyASCIIStringEncoding = 7,
   NSShiftJISStringEncoding = 8,
   NSISOLatin2StringEncoding = 9,
   NSUnicodeStringEncoding = 10,
   NSWindowsCP1251StringEncoding = 11,
   NSWindowsCP1252StringEncoding = 12,
   NSWindowsCP1253StringEncoding = 13,
   NSWindowsCP1254StringEncoding = 14,
   NSWindowsCP1250StringEncoding = 15,
   NSISO2022JPStringEncoding = 21,
   NSMacOSRomanStringEncoding = 30,
   NSUTF16StringEncoding = NSUnicodeStringEncoding,
   NSUTF16BigEndianStringEncoding = 0x90000100,
   NSUTF16LittleEndianStringEncoding = 0x94000100,
   NSUTF32StringEncoding = 0x8c000100,
   NSUTF32BigEndianStringEncoding = 0x98000100,
   NSUTF32LittleEndianStringEncoding = 0x9c000100,
   NSProprietaryStringEncoding = 65536
};

*/
- (BOOL) loadChannelTableFile:(NSString*) filename
{
	NSLog(@"Called: %@::%@\n",NSStringFromClass([self class]),NSStringFromSelector(_cmd));//TODO: debug output -tb-

    NSStringEncoding encoding=0;
	
    NSError* error=nil;
    NSString* myString = [NSString stringWithContentsOfFile:filename usedEncoding:&encoding error:&error];
	if(error) NSLog(@"Error >>>%@<<<\n",error);
	if(!myString){
	    NSLog(@"Could not read file!\n");
	    return FALSE;
	}
	//NSLog(@"Encoding >>>%i<<<\n",encoding);
	//NSLog(@"Read string >>>%@<<<\n",myString);
    //NSLog(@"Read with encoding %@ string >>>%@<<<\n",&encoding,myString);

    NSArray *csvtable = [myString csvRows];
	if(!csvtable) return FALSE;
	int nlines = [csvtable count];
	//if(csvtable) NSLog(@"csvtable (%i lines) >>>%@<<<\n", nlines, csvtable);//TODO: enable with debug output setting??? -tb-
	if(nlines<=1) return FALSE;
	
	int indexChan, indexName, indexURL, indexPath, indexLoAlarm, indexHiAlarm, indexLoLimit, indexHiLimit, indexType;
	NSArray *colnames = [csvtable objectAtIndex: 0];
	indexChan = [colnames indexOfObject: @"Chan"];
	indexName = [colnames indexOfObject: @"Name"];
	indexURL = [colnames indexOfObject: @"URL"];
	indexPath = [colnames indexOfObject: @"Path"];
	indexLoAlarm = [colnames indexOfObject: @"LoAlarm"];
	indexHiAlarm = [colnames indexOfObject: @"HiAlarm"];
	indexLoLimit = [colnames indexOfObject: @"LoLimit"];
	indexHiLimit = [colnames indexOfObject: @"HiLimit"];
	indexType = [colnames indexOfObject: @"Type"];
	
	
	//NSLog(@"colnames >>>%@<<<\n", colnames);
	//NSLog(@"indexChan, indexName, indexURL, indexPath, indexLoAlarm, indexHiAlarm, indexLoLimit, indexHiLimit, indexType is %i, %i, %i, %i, %i, %i, %i, %i, %i \n", 
	//        indexChan, indexName, indexURL, indexPath, indexLoAlarm, indexHiAlarm, indexLoLimit, indexHiLimit, indexType);

    //now create channels
    NSArray *line;
	int chan=0, chantest, newchan, controlType=0;
	NSString *url;
	NSString *path;
	NSString *type;
	NSString *itemKey;
	int i;
    for(i=1; i<nlines; i++){
	    line = [csvtable objectAtIndex: i];
		//NSLog(@"Scan line: %@  \n",line);
	    chan = [[line  objectAtIndex: indexChan] intValue];
		//NSLog(@"---> search chan: %i  \n",chan);
//[self dumpSensorlist];// dumps the requestCache and others  -tb-

        itemKey = [channelLookup objectForKey:[NSNumber numberWithInt:chan]];
		if(itemKey) NSLog(@"The channel %i is already used by %@!\n",chan,itemKey);
	    url =  [line  objectAtIndex: indexURL] ;
	    path =  [line  objectAtIndex: indexPath] ;
		chantest = [self findChanOfItem: url path: path];
		if(chantest != -1){
		    NSLog(@"This item already exists! (%@  ,  %@)\n",url,path);
			continue;
		}
	    chan = [[line  objectAtIndex: indexChan] intValue];
		type = [line  objectAtIndex: indexType] ;
		controlType = 0; //Sensor
		if([type isEqualToString:@"Control"]) controlType=1;
		
		//create new chan
		//NSLog(@"Create: URL:%@  ,  path:%@  \n",url,path);
		newchan = [self createChannelWithUrl:url path:path chan:chan controlType:controlType];// if chan already used, it will assign a free chan and return it
		if(newchan != chan) NSLog(@"Created chan %i instead of chan %i with  URL:%@  ,  path:%@  \n",newchan, chan, url,path);
        //... and make settings
		itemKey = [channelLookup objectForKey:[NSNumber numberWithInt:chan]];
	    NSMutableDictionary* topLevelDictionary	= [requestCache objectForKey:itemKey];
		NSMutableDictionary* itemDictionary = [topLevelDictionary objectForKey:itemKey];
		[topLevelDictionary setObject:[line objectAtIndex: indexLoAlarm]  forKey:@"LoAlarm"];
		[topLevelDictionary setObject:[line objectAtIndex: indexHiAlarm]  forKey:@"HiAlarm"];
		[topLevelDictionary setObject:[line objectAtIndex: indexLoLimit]  forKey:@"LoLimit"];
		[topLevelDictionary setObject:[line objectAtIndex: indexHiLimit]  forKey:@"HiLimit"];
		if(controlType) [itemDictionary setObject:[line objectAtIndex: indexName]  forKey:@"name"];
		else  [itemDictionary setObject:[line objectAtIndex: indexName]  forKey:@"Name"];
	}

	return FALSE;
}

- (BOOL) saveAsChannelTableFile:(NSString*) filename
{
	NSLog(@"Called: %@::%@\n",NSStringFromClass([self class]),NSStringFromSelector(_cmd));//TODO: debug output -tb-
	NSMutableString *csvtableString = [NSMutableString stringWithString: @"Chan,Name,URL,Path,LoAlarm,HiAlarm,LoLimit,HiLimit,Type\n"];
	
	int chan=0;
	int LoAlarm,HiAlarm,LoLimit,HiLimit;
	NSString *name;
	NSString *url;
	NSString *path;
	NSString *type;
	
	for(NSString* itemKey in pollingLookUp){
	    NSLog(@"Write Item %@\n",itemKey);
		NSDictionary* topLevelDictionary = [requestCache objectForKey:itemKey];
		NSDictionary* itemDictionary = [topLevelDictionary objectForKey:itemKey];
		
		int isControlType = [[itemDictionary objectForKey:@"Control"] intValue];
		
		//output for testing
		#if 0
		NSLog(@"  Chan: %i\n",[[topLevelDictionary objectForKey:@"ChannelNumber"] intValue]);
		if(isControlType) NSLog(@"  Name: %@\n",[itemDictionary objectForKey:@"name"]);
		else NSLog(@"  Name: %@\n",[itemDictionary objectForKey:@"Name"]);
		NSLog(@"  URL: %@\n",[itemDictionary objectForKey:@"URL"]);
		NSLog(@"  Path: %@\n",[itemDictionary objectForKey:@"Path"]);
		NSLog(@"  LoAlarm: %@\n",[topLevelDictionary objectForKey:@"LoAlarm"]);
		NSLog(@"  HiAlarm: %@\n",[topLevelDictionary objectForKey:@"HiAlarm"]);
		NSLog(@"  LoLimit: %@\n",[topLevelDictionary objectForKey:@"LoLimit"]);
		NSLog(@"  HiLimit: %@\n",[topLevelDictionary objectForKey:@"HiLimit"]);
		NSLog(@"  Type: %@\n", isControlType  == 1 ? @"Control" : @"Sensor");
		#endif
		
		chan =[[topLevelDictionary objectForKey:@"ChannelNumber"] intValue];
		if(isControlType) name = [itemDictionary objectForKey:@"name"];
		else name = [itemDictionary objectForKey:@"Name"];
		url = [itemDictionary objectForKey:@"URL"];
		path = [itemDictionary objectForKey:@"Path"];
		LoAlarm = [[topLevelDictionary objectForKey:@"LoAlarm"] doubleValue];
		HiAlarm = [[topLevelDictionary objectForKey:@"HiAlarm"] doubleValue];
		LoLimit = [[topLevelDictionary objectForKey:@"LoLimit"] doubleValue];
		HiLimit = [[topLevelDictionary objectForKey:@"HiLimit"] doubleValue];
		
		if(isControlType) type = @"Control" ; else type = @"Sensor";
		[csvtableString appendFormat: @"%i,\"%@\",\"%@\",\"%@\",%i,%i,%i,%i,\"%@\"\n",chan,name,url,path,LoAlarm,HiAlarm,LoLimit,HiLimit,type];
		
	}
	    
	//NSLog(@"TABLE:>>>%@<<<\n",csvtableString);
	BOOL success = [csvtableString writeToFile: filename atomically: YES encoding: NSASCIIStringEncoding  error: nil];
	//could use [filename stringByExpandingTildeInPath] instead of filename -tb-
	if(!success) NSLog(@"ERROR during writing the channel table to %@ ...\n",filename);
	
	return success;
}

//customn method to create a sensor (calling createChannelWithUrl:...)
- (int) createSensorWithUrl:(NSString*)aUrl path:(NSString*)aPath
{    return [self  createChannelWithUrl:aUrl path:aPath chan:-1 controlType:0];      }

//customn method to create a control (calling createChannelWithUrl:...)
- (int) createControlWithUrl:(NSString*)aUrl path:(NSString*)aPath
{    return [self  createChannelWithUrl:aUrl path:aPath chan:-1 controlType:1];      }

//customn method to create a sensor (calling createChannelWithUrl:...)
- (int) createSensorWithUrl:(NSString*)aUrl path:(NSString*)aPath chan:(int)aChan
{    return [self  createChannelWithUrl:aUrl path:aPath chan:aChan controlType:0];      }

//customn method to create a control (calling createChannelWithUrl:...)
- (int) createControlWithUrl:(NSString*)aUrl path:(NSString*)aPath chan:(int)aChan
{    return [self  createChannelWithUrl:aUrl path:aPath chan:aChan controlType:1];      }


- (int) findChanOfSensor:(NSString*)aUrl path:(NSString*)aPath
{
    int channelNumber=-1;
    NSString* itemKey = [self itemKey:aUrl path:aPath];
	NSDictionary* topLevelDictionary	= [requestCache objectForKey:itemKey];
	if(!topLevelDictionary) return -1;
	NSDictionary* itemDictionary		= [topLevelDictionary objectForKey:itemKey];
	if([itemDictionary objectForKey:@"Control"]) NSLog(@"%@: no Sensor channel found, is a Control channel!\n",NSStringFromClass([self class]));//-tb- warning output  //is a Control, not a Sensor
    else channelNumber = [[topLevelDictionary objectForKey:@"ChannelNumber"] intValue];
    return channelNumber;
}

- (int) findChanOfControl:(NSString*)aUrl path:(NSString*)aPath
{
    int channelNumber=-1;
    NSString* itemKey = [self itemKey:aUrl path:aPath];
	NSDictionary* topLevelDictionary	= [requestCache objectForKey:itemKey];
	if(!topLevelDictionary) return -1;
	NSDictionary* itemDictionary		= [topLevelDictionary objectForKey:itemKey];
	if([itemDictionary objectForKey:@"Control"]) channelNumber = [[topLevelDictionary objectForKey:@"ChannelNumber"] intValue];
    else NSLog(@"%@: no Control channel found, is a non-Control channel!\n",NSStringFromClass([self class]));//-tb- warning output //is a Sensor, not a Control
    return channelNumber;
}

- (int) findChanOfItem:(NSString*)aUrl path:(NSString*)aPath
{
    int channelNumber=-1;
    NSString* itemKey = [self itemKey:aUrl path:aPath];
	NSDictionary* topLevelDictionary	= [requestCache objectForKey:itemKey];
	if(topLevelDictionary) channelNumber = [[topLevelDictionary objectForKey:@"ChannelNumber"] intValue];
    return channelNumber;
}

- (int) findChanOfIndex:(int)anIndex
{
    //anIndex is the index/row in the itemListView ...
    int channelNumber=-1;
	if(anIndex<[pollingLookUp count]){
		NSString* itemKey = [pollingLookUp objectAtIndex:anIndex];
        NSDictionary* topLevelDictionary	= [requestCache objectForKey:itemKey];
        channelNumber = [[topLevelDictionary objectForKey:@"ChannelNumber"] intValue];
    }
    return channelNumber;
}


- (void) postRequestForChan:(int)aChan
{
    NSString* itemKey = [channelLookup objectForKey:[NSNumber numberWithInt:aChan]];
    if(itemKey){
		if([self requestIsPending:itemKey]){//request is still pending
            NSLog( @"You posted a request for a still pending item: %@\n",itemKey);
            if(![self rePostStillPendingRequests]) return;
            else NSLog( @"Repeating the request! WARNING - may overload the ADEI server!\n");
        }
		id topLevelDictionary = [requestCache objectForKey:itemKey];
		id anItem = [topLevelDictionary objectForKey:itemKey];
        NSString* aUrl  = [anItem objectForKey:@"URL"];
        NSString* aPath = [anItem objectForKey:@"Path"];
        int aType = kSensorType;
		if([anItem objectForKey:@"Control"]){
            aType = kControlType;
		}
        // post request
        ORAdeiLoader* aLoader;
        aLoader = [ORAdeiLoader loaderWithAdeiHost:aUrl adeiType:aType delegate:self didFinishSelector:@selector(polledItemResult:path:)]; //TODO: maybe I should add setupOptions: -tb-
        [aLoader setShowDebugOutput: showDebugOutput];//TODO: timeout debugging -tb-
        [aLoader requestItem:aPath];
        [self setPendingRequest:itemKey];
        [self setTotalRequestCount:totalRequestCount+1];
        //
    }else{
        NSLog(@"%@::%@: you tried to use a undefined channel!\n",NSStringFromClass([self class]),NSStringFromSelector(_cmd));
        return;
    }
}

- (void) postControlSetpointForChan:(int)aChan value:(double)aValue
{
    NSString* itemKey = [channelLookup objectForKey:[NSNumber numberWithInt:aChan]];
    if(itemKey){
		id topLevelDictionary = [requestCache objectForKey:itemKey];
		id anItem = [topLevelDictionary objectForKey:itemKey];
		if([anItem objectForKey:@"Control"]){
			NSString* aUrl  = [anItem objectForKey:@"URL"];
			NSString* aPath = [anItem objectForKey:@"Path"];
			[self postControlSetpoint:aUrl path:aPath value:aValue ];
		}else{
            NSLog(@"%@: you tried to write to a non-Control channel!\n",NSStringFromClass([self class]));//-tb- warning output
            return;
        }
    }else{
        NSLog(@"%@: you tried to use a undefined channel!\n",NSStringFromClass([self class]));
        return;
    }
}

- (void) sendControlSetpointForChan:(int)aChan value:(double)aValue
{
	//NSLog(@"%@::%@ - for chan %i send setpoint %Lg\n", NSStringFromClass([self class]), NSStringFromSelector(_cmd),aChan, aValue);//DEBUG OUTPUT -tb-  
    NSString* itemKey = [channelLookup objectForKey:[NSNumber numberWithInt:aChan]];
    if(itemKey){
		id topLevelDictionary = [requestCache objectForKey:itemKey];
		id anItem = [topLevelDictionary objectForKey:itemKey];
		if([anItem objectForKey:@"Control"]){
			NSString* aUrl  = [anItem objectForKey:@"URL"];
			NSString* aPath = [anItem objectForKey:@"Path"];
			[self sendControlSetpoint:aUrl path:aPath value:aValue ];
		}else{
            NSLog(@"%@: you tried to write to a non-Control channel!\n",NSStringFromClass([self class]));//-tb- warning output
            return;
        }
    }else{
        NSLog(@"%@: you tried to use a undefined channel!\n",NSStringFromClass([self class]));
        return;
    }
}



- (BOOL) requestIsPendingForChan:(int)aChan
{
    NSString* itemKey = [channelLookup objectForKey:[NSNumber numberWithInt:aChan]];
    if(itemKey){
		id topLevelDictionary = [requestCache objectForKey:itemKey];
		id anItem = [topLevelDictionary objectForKey:itemKey];
        NSString* aUrl  = [anItem objectForKey:@"URL"];
        NSString* aPath = [anItem objectForKey:@"Path"];
        return [pendingRequests objectForKey:[self itemKey:aUrl path:aPath]] != nil;
    }else{
        //NSLog(@"%@: you tried to use a undefined channel!\n",NSStringFromClass([self class]));
        return false;
    }
}

//TODO:
- (BOOL) wasErrorForChan:(int)aChan
{
    NSString* itemKey = [channelLookup objectForKey:[NSNumber numberWithInt:aChan]]; 
    //DEBUG        NSLog(@"%@::%@   itemKey is >>>%@<<<  \n", NSStringFromClass([self class]), NSStringFromSelector(_cmd),itemKey);//DEBUG OUTPUT -tb-
    if(itemKey){
		id topLevelDictionary = [requestCache objectForKey:itemKey];
    //DEBUG        NSLog(@"%@::%@   topLevelDictionary is >>>%@<<<  \n", NSStringFromClass([self class]), NSStringFromSelector(_cmd),topLevelDictionary);//DEBUG OUTPUT -tb-
		id anItem = [topLevelDictionary objectForKey:itemKey];
        NSString* result  = [anItem objectForKey:@"Result"];
        if(!result) return false;//key "Result" not set: no error (not yet loaded, not a control request, ...) -tb-
        int tmp=[result caseInsensitiveCompare:@"OK"];//note: caseInsensitiveCompare: returns a 'NSComparisonResult' which may be -1, 0 or 1 ({NSOrderedAscending = -1, NSOrderedSame, NSOrderedDescending})-tb-
                                                      //if "OK" not found: NSOrderedAscending (==-1), all other cases mean: found
    //DEBUG        NSLog(@"%@::%@   result is >>>%@<<< retval is:(%i)\n", NSStringFromClass([self class]), NSStringFromSelector(_cmd),result,tmp);//DEBUG OUTPUT -tb-
        //NSLog(@"%@::%@   result is >>>%@<<< retval is:%@ (%i)\n", NSStringFromClass([self class]), NSStringFromSelector(_cmd),result,[result caseInsensitiveCompare:@"OK"],[result caseInsensitiveCompare:@"OK"]);//DEBUG OUTPUT -tb-
        return (tmp==NSOrderedAscending);//note: (see above) -tb-
    }else{
        return true;
    }
}

- (NSString*) errorForChan:(int)aChan
{
    NSString* itemKey = [channelLookup objectForKey:[NSNumber numberWithInt:aChan]];
    if(itemKey){
		id topLevelDictionary = [requestCache objectForKey:itemKey];
		id anItem = [topLevelDictionary objectForKey:itemKey];
        return [anItem objectForKey:@"Error"];
    }else{
        return @"Undefined Channel";
    }
}



//TODO: control items are badly initialized under certain circumstances!! -tb-
//TODO: after dragging a control into the list its "value" displays the ADEI item number, not the control value!! -tb-
//TODO: better use new entries in the toplevel dictionary (?)
// -> DONE: using DBValue and DBTimestamp -tb-
- (double) valueForChan:(int)aChan
{
    NSString* itemKey = [channelLookup objectForKey:[NSNumber numberWithInt:aChan]];
    return [self valueForItemKey: itemKey];
}

- (double) valueForItemKey:(NSString*)itemKey
{
	if(itemKey){
        //scan the new items "DBValue", "DBTimestamp"-tb-
        #if 1
		NSDictionary* topLevelDictionary = [requestCache objectForKey: itemKey];
        return [[topLevelDictionary objectForKey:@"DBValue"] doubleValue];
        #else
		NSDictionary* topLevelDictionary = [requestCache objectForKey: itemKey];
		NSDictionary* itemDictionary = [topLevelDictionary objectForKey:itemKey];
		if([itemDictionary objectForKey:@"Control"]) return [[itemDictionary objectForKey:@"value"] doubleValue];
		else										 return [[itemDictionary objectForKey:@"Value"] doubleValue];
        #endif
	}
	return 0; // return something if channel number out of range
}


- (BOOL) requestIsPending:(NSString*)aUrl path:(NSString*)aPath
{
	return [pendingRequests objectForKey:[self itemKey:aUrl path:aPath]] != nil;
}

- (BOOL) requestIsPending:(NSString*)itemKey
{
	return [pendingRequests objectForKey:itemKey] != nil;
}

//if the item is part of the itemArray
- (void) writeSetPoint:(int)anIndex value:(double)aValue
{
	//index is NOT channel
	if(anIndex<[pollingLookUp count]){
        #if 0
        NSLog(@"pollingLookUp:\n %@\n",pollingLookUp);
        NSLog(@"channelLookup:\n %@\n",channelLookup);
        NSLog(@"requestCache:\n %@\n",requestCache);
        NSLog(@"itemTreeRoot:\n %@\n",itemTreeRoot);
        #endif
		NSString* itemKey = [pollingLookUp objectAtIndex:anIndex];
		id topLevelDictionary = [requestCache objectForKey:itemKey];
		id anItem = [topLevelDictionary objectForKey:itemKey];
		if([anItem objectForKey:@"Control"]){
			NSString* aUrl  = [anItem objectForKey:@"URL"];
			NSString* aPath = [anItem objectForKey:@"Path"];
            #if 1
            [self postControlSetpoint:aUrl path:aPath value:aValue];
            #else
            //TODO: remove from source file -tb-
			ORAdeiLoader* aLoader = [ORAdeiLoader loaderWithAdeiHost:aUrl adeiType:kControlType delegate:self didFinishSelector:nil];
			[aLoader setControlSetpoint:aPath value:aValue];
			[self setTotalRequestCount:totalRequestCount+1];
            #endif
		}
	}
}


- (void) queueControlSetpointForIndex:(int)anIndex value:(double)aValue
{
	int chan = [self findChanOfIndex: anIndex];
	[self queueControlSetpointForChan:chan value:aValue];
}


//fills a setpoint request into the request queue
- (void) queueControlSetpointForChan:(int)aChan value:(double)aValue
{
	if(!setpointRequestsQueue) setpointRequestsQueue = [[NSMutableArray arrayWithCapacity:32] retain];//[[NSMutableArray array] retain];
	int count = [self setpointRequestsQueueCount];
	//check whether this chan is already in queue, if yes, remove it
	int i;
	for(i=0; i<count; i++){
		NSMutableDictionary *aDict = [setpointRequestsQueue objectAtIndex:i];
		#ifdef SHOW_REQUEST_LIST_DEBUG_OUTPUT
		NSLog(@"aDict is %@\n",aDict);
		#endif
		if([[aDict objectForKey:@"Chan"] intValue]==aChan){
			[setpointRequestsQueue removeObjectAtIndex:i];
			NSLog(@"WARNING: The item with chan %i is already in the list: will be overwritten ...\n",aChan);
			break;
		}
	}
	#ifdef SHOW_REQUEST_LIST_DEBUG_OUTPUT
	NSLog(@"%@::%@  count %i\n", NSStringFromClass([self class]), NSStringFromSelector(_cmd),count);
	#endif
	
	//
    NSString* itemKey = [channelLookup objectForKey:[NSNumber numberWithInt:aChan]];
	if(itemKey){
		id topLevelDictionary = [requestCache objectForKey:itemKey];
		id anItem = [topLevelDictionary objectForKey:itemKey];
        NSString* aUrl  = [anItem objectForKey:@"URL"];
        NSString* aPath = [anItem objectForKey:@"Path"];
        NSString* aName = [anItem objectForKey:@"name"];
		NSMutableDictionary* aDictionary = [NSMutableDictionary dictionaryWithObjectsAndKeys:
											[NSNumber numberWithInt:aChan],@"Chan",
											//[self ipNumberToURL],@"URL",
											aUrl,@"URL",
											aPath,@"Path",
											aName,@"Name",
											[NSNumber numberWithDouble:aValue],@"Setpoint",
											//aNode,@"Children",
											nil];
		[setpointRequestsQueue addObject:aDictionary];
		
		[[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSlowControlSetpointRequestQueueChanged object:self];
		#ifdef SHOW_REQUEST_LIST_DEBUG_OUTPUT
		NSLog(@"%@\n",setpointRequestsQueue);
		#endif
		
	}
		
}




- (int) sendSetpointRequestQueue
{
	#ifdef SHOW_REQUEST_LIST_DEBUG_OUTPUT
	NSLog(@"%@::%@\n", NSStringFromClass([self class]), NSStringFromSelector(_cmd));//DEBUG OUTPUT -tb-  
	NSLog(@"The queue: %@\n",setpointRequestsQueue);
	#endif
	
    int newCurrentQueueErrorIndex = ([self currentQueueErrorIndex] + 1) % kMaxQueueErrorEntries;
    if(newCurrentQueueErrorIndex==0) newCurrentQueueErrorIndex = 1;
    [self setCurrentQueueErrorIndex: newCurrentQueueErrorIndex];
    [self setCurrentQueueError: -1];
    
	//sort the list/queue according to url and path -> build a tree
	NSMutableDictionary *requestTree = [NSMutableDictionary dictionary];
	id objx;
	for(objx in setpointRequestsQueue){
		NSDictionary *obj= objx;
		int count;
		NSString *path = [obj objectForKey:@"Path"];
		NSArray* components = nil;
		if([path isEqual:@"/"] || ([path length]==0)) count = 0;
		else {
			components = [path componentsSeparatedByString:@"/"];
			count = [components count];
		}
//		NSMutableArray *pathThroughTree = [[NSMutableArray alloc] initWithObject: [obj objectForKey:@"URL"]];
		NSMutableArray *pathThroughTree = [NSMutableArray arrayWithCapacity:5];
		[pathThroughTree addObject: [obj objectForKey:@"URL"]];
		[pathThroughTree addObjectsFromArray:components];										   
		#ifdef SHOW_REQUEST_LIST_DEBUG_OUTPUT
		NSLog(@"pathThroughTree: %@\n",pathThroughTree);//debug output: the path through the request tree <----------
		#endif
		[self fillRequest: obj intoTree: requestTree accordingTo: pathThroughTree level: 0];
	}
								 
	#ifdef SHOW_REQUEST_LIST_DEBUG_OUTPUT
	NSLog(@"requestTree:%@\n",requestTree);//debug output: the request tree <----------
	#endif
	
	NSMutableArray *requestStringList = [NSMutableArray arrayWithCapacity:5];

	[self traverseTree:requestTree level:0 requestString:nil requestStringList:requestStringList];
	#ifdef SHOW_REQUEST_LIST_DEBUG_OUTPUT
	NSLog(@"requestStringList:%@\n",requestStringList);//debug output: the request list <----------
	#endif

	// now send the request(s) to ADEI
	int count = [requestStringList count];
	//check whether this chan is already in queue, if yes, remove it
	int i;
	for(i=0; i<count; i++){
		NSMutableString *requestString = [requestStringList objectAtIndex:i];
		//NSLog(@"Request %i is: %@\n",i,requestString);
		//[self sendRequestString:requestString]; //added error handlich for queues 2014-04 -tb-
		[self sendRequestString:requestString withQueueErrorIndex:newCurrentQueueErrorIndex];
	}
	
	
	[self clearSetpointRequestQueue];	
    
    return newCurrentQueueErrorIndex;
}



	#ifdef SHOW_REQUEST_LIST_DEBUG_OUTPUT
	   #undef SHOW_REQUEST_LIST_DEBUG_OUTPUT
	#endif


- (void) clearSetpointRequestQueue
{
	//NSLog(@"%@::%@\n", NSStringFromClass([self class]), NSStringFromSelector(_cmd));//DEBUG OUTPUT -tb-  
	[setpointRequestsQueue removeAllObjects];//TODO: seems to me I missed a retain somewhere -tb-
	//NSLog(@"%@::%@  count is %i\n", NSStringFromClass([self class]), NSStringFromSelector(_cmd),[setpointRequestsQueue count]);//DEBUG OUTPUT -tb-  
    [[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSlowControlSetpointRequestQueueChanged object:self];
	//NSLog(@"%@::%@  count is %i\n", NSStringFromClass([self class]), NSStringFromSelector(_cmd),[setpointRequestsQueue count]);//DEBUG OUTPUT -tb-  

}

//count from 1 to kMaxQueueErrorEntries-1 (index 0 is reserved)
- (int) currentQueueErrorIndex
{
    return currentQueueErrorIndex;
}

- (void) setCurrentQueueErrorIndex:(int)anIndex
{
    if(anIndex<0) anIndex=0;
    if(anIndex>=kMaxQueueErrorEntries) anIndex=kMaxQueueErrorEntries;
    currentQueueErrorIndex=anIndex;
}

- (int) queueErrorForIndex:(int)anIndex
{
    if(anIndex<0) return 0;
    if(anIndex>=kMaxQueueErrorEntries) return 0;
    return queueError[anIndex];
}


//aError: -1: still pending; 0 got a reply without error; 1 = reply with error
- (void) setQueueError:(int)aError forIndex:(int)anIndex
{
    if(anIndex<0) return ;
    if(anIndex>=kMaxQueueErrorEntries) return ;
    queueError[anIndex] = aError;
}

- (void) setCurrentQueueError:(int)aError
{
    int anIndex = [self currentQueueErrorIndex];
    [self setQueueError:aError forIndex: anIndex];
}

- (int) currentQueueError
{
    int anIndex = [self currentQueueErrorIndex];
    return [self queueErrorForIndex: anIndex];
}

- (void) incCurrentQueueError
{
    int aError = [self currentQueueError];
    aError++;
    [self setCurrentQueueError:aError ];
}





- (double) valueForUrl:(NSString*)aUrl path:(NSString*)aPath
{
	NSString* itemKey = [self itemKey:aUrl path:aPath];
    return [self valueForItemKey: itemKey];
}

- (void) commonScriptMethodSectionEnd { }
//-------------end of common script methods---------------------------------

- (void) histogram:(int)milliSecs
{
	int i = milliSecs;
	if(i>=kResponseTimeHistogramSize)i=kResponseTimeHistogramSize-1;
	histogram[i]++;
	[[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSlowControlModelHistogramChanged object:self];
}

- (long) dataTimeHist:(int)index
{
	if(index<kResponseTimeHistogramSize)return histogram[index];
	else return 0;
}

- (NSUInteger) pendingRequestsCount
{
	return [[pendingRequests allKeys] count];
}

- (id) pendingRequest:(id)aKey forIndex:(int)anIndex
{
	if(anIndex < [[pendingRequests allKeys] count]){
		id aKey =  [[pendingRequests allKeys] objectAtIndex:anIndex];
		return aKey;
	}
	else return nil;
}

@end

@implementation ORIpeSlowControlModel (private)

- (NSMutableArray*) insertNode:(id)aNode intoArray:(NSMutableArray*)anArray path:(NSString*)aPath nodeName:(NSString*)nodeName isLeaf:(BOOL)isLeaf
{
	for(id aDictionary in anArray){
		NSString* thisNodesName = [aDictionary objectForKey:@"Name"];
		if(!thisNodesName)thisNodesName = [aDictionary objectForKey:@"name"];
		if([thisNodesName isEqualToString:nodeName]){
			//OK the node is already there.
			if(isLeaf){
				//It's a leaf. Replace the existing entry with the new info
				[aDictionary setObject:aNode forKey:@"Children"];
				return nil;
			}
			else return [aDictionary objectForKey:@"Children"];
		}
	}
	
	if(isLeaf){
		for(id item in aNode){
			[item setObject:[self ipNumberToURL] forKey:@"URL"];
			NSString* leafNodePath = [aPath stringByAppendingPathComponent:[item objectForKey:@"value"]];
			[item setObject:leafNodePath forKey:@"Path"];
		}
		NSMutableDictionary* aDictionary = [NSMutableDictionary dictionaryWithObjectsAndKeys:
											nodeName,@"Name",
											[self ipNumberToURL],@"URL",
											aPath,@"Path",
											aNode,@"Children",
											nil];
		[anArray addObject:aDictionary];
		return anArray;
	}
	else {
		//if we get here, there was no entry yet. make one.
		NSMutableArray* newArray = [NSMutableArray array];
		NSMutableDictionary* aDictionary = [NSMutableDictionary dictionaryWithObjectsAndKeys:
											nodeName,@"Name",
											aPath,@"Path",
											[self ipNumberToURL],@"URL",
											newArray,@"Children",
											nil];
		[anArray addObject:aDictionary];
		return newArray;
	}
}



- (void) itemTreeResults:(id)result path:(NSString*)aPath
{	
	[self setLastRequest:aPath];
	NSMutableArray* pathComponents;
	if([aPath isEqual:@"/"] || ([aPath length]==0)){
		//this was the root -- we ignore this and start with the servers
		return;
	}
	else pathComponents = [[aPath componentsSeparatedByString:@"/"] mutableCopy];
	
	if(!itemTreeRoot)itemTreeRoot = [[NSMutableArray array] retain];
	
	// paths are of the form "/server/database/group/item". Always the fourth level is the leaf node
	int level = 0;
	NSMutableArray* aNodeArray = itemTreeRoot;
    for(id nodeName in pathComponents){
        #pragma unused(nodeName)

		aNodeArray = [self insertNode:result
							intoArray:aNodeArray 
								 path: aPath
							 nodeName:[pathComponents objectAtIndex:level] 
							   isLeaf:level==2];
		if(!aNodeArray)break;
		level++;
	}
	[pathComponents release];
	[[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSlowItemTreeChanged object:self];
}

- (void) polledItemResult:(id)result path:(NSString*)aPath
{
	//got back some results from pollSlowControls. Store it in the requestCache.
	//requestCache form:
	// Array of Dictionaries of the form:
	// itemKey -> topLevelDictionary whose form is:
	//		itemKey -> thePolledItem from database (another Dictionary) 
	//		"LoAlarm" -> loAlarm Value
	//		"HiAlarm" -> hiAlarm Value
	// ...
	// ...
	//
    //NSLog(@"polledItemResult: ... result is %@ \n",result);
	for(id resultItem in result){
	    //DEBUG	        NSLog(@"%@::%@   ResultItem is >>>%@<<<\n", NSStringFromClass([self class]), NSStringFromSelector(_cmd),resultItem);//DEBUG OUTPUT -tb-
        int chan=-1;
		NSString* itemKey = [self itemKey:[resultItem objectForKey:@"URL"] path:[resultItem objectForKey:@"Path"]];
	        //DEBUG		         NSLog(@"%@::%@   itemKey   >>>%@<<<\n", NSStringFromClass([self class]), NSStringFromSelector(_cmd),itemKey);//DEBUG OUTPUT -tb-
        if(!itemKey) continue; //avoid (null) item key; this may happen if there was a alarm message in the received xml structure (contains no path/url) -tb-
                               //2013-04-12 NOW this will happen for ALLMOST ALL items, as the ADEI request returns the full control group!
                               //2013-04-16 FIXED -tb-
        //should work without: if(!requestCache)   requestCache = [[NSMutableDictionary dictionary] retain];
		id topLevelDictionary = [requestCache objectForKey:itemKey];
	        //DEBUG       NSLog(@"%@::%@   topLevelDictionary  >>>%@<<<\n", NSStringFromClass([self class]), NSStringFromSelector(_cmd),topLevelDictionary);//DEBUG OUTPUT -tb-


        //CHECK for item 'Result' = OK
        if([self isControlItemWithItemKey:itemKey]){//additional check for control items (they may not exist at all -> AdeiLoader sends a Result=Error) -tb-
            int isError = 0;
            NSString* errorObj  = [resultItem objectForKey:@"Error"];
            NSString* resultObj  = [resultItem objectForKey:@"Result"];
            if(errorObj){
                if(resultObj){//if 'Result' key is not present, we probably come from a get request ... -tb-
                    int tmp=[resultObj caseInsensitiveCompare:@"Error"];//note: caseInsensitiveCompare: returns a 'NSComparisonResult' which may be -1, 0 or 1 ({NSOrderedAscending = -1, NSOrderedSame, NSOrderedDescending})-tb-
                    //DEBUG  NSLog(@"%@::%@   result is >>>%@<<< comparison is:(%i) ((NSOrderedAscending is %i))\n", NSStringFromClass([self class]), NSStringFromSelector(_cmd),result,tmp,NSOrderedAscending);//DEBUG OUTPUT -tb-
                    if(tmp!=NSOrderedDescending){//== @"Error"  found 
                        isError=1;
                    }else{
                        NSLog(@"%@::%@   warning: Error is set, but Result is 'OK'  -   something is strange!\n", NSStringFromClass([self class]), NSStringFromSelector(_cmd));//DEBUG OUTPUT -tb-
                    }
                }else{
                    isError=1;
                }
            }else{
                if(resultObj){//if 'Result' key is not present, we probably come from a get request ... -tb-
                    int tmp=[resultObj caseInsensitiveCompare:@"Error"];//note: caseInsensitiveCompare: returns a 'NSComparisonResult' which may be -1, 0 or 1 ({NSOrderedAscending = -1, NSOrderedSame, NSOrderedDescending})-tb-
                    //DEBUG  NSLog(@"%@::%@   result is >>>%@<<< comparison is:(%i) ((NSOrderedAscending is %i))\n", NSStringFromClass([self class]), NSStringFromSelector(_cmd),result,tmp,NSOrderedAscending);//DEBUG OUTPUT -tb-
                    if(tmp!=NSOrderedDescending){//== @"Error"  found 
                        NSLog(@"%@::%@   warning: Error does not exist, but Result is 'Error'  -   something is strange!\n", NSStringFromClass([self class]), NSStringFromSelector(_cmd));//DEBUG OUTPUT -tb-
                        isError=1;
                    }
                }
            }
            
            if(isError){//this is skipped if Result=OK or (Result not existent and Error not Existent)
                    //copy error message
                    NSMutableDictionary* itemDictionary		= [topLevelDictionary objectForKey:itemKey];
                    if([resultItem objectForKey:@"Result"])[itemDictionary setObject:[resultItem objectForKey:@"Result"] forKey:@"Result"];//added if(...) to check existence of "Result"; sensor and control reads are not foreseen to return the "Result" key, but this caused a exception and skipped "clearPendingRequest" -tb-
                    else [itemDictionary setObject:@"Error" forKey:@"Result"];//fallback
                    if([resultItem objectForKey:@"Error"])[itemDictionary setObject:[resultItem objectForKey:@"Error"] forKey:@"Error"];
                    else [itemDictionary setObject:@"Unknown Error in polledItemResult:path: - please contact a Orca expert!" forKey:@"Error"];//fallback
                    [topLevelDictionary setObject:@"Error" forKey:@"DBValue"];
                    //housekeeping
		            [self clearPendingRequest:itemKey];
                    continue;
            }
        }
        
		if(!topLevelDictionary){
	        //DEBUG                       NSLog(@"%@::%@   topLevelDictionary not found  >>>%@<<<\n", NSStringFromClass([self class]), NSStringFromSelector(_cmd),topLevelDictionary);//DEBUG OUTPUT -tb-
			//wasn't in the topLevel so we haven't seen this item before. Add it to the cache.
            //REUSE "addItems:"
            //NSArray* anItemArray = [NSArray arrayWithObject: [NSDictionary dictionaryWithObjectsAndKeys:
            //    [resultItem objectForKey:@"URL"],@"URL", [resultItem objectForKey:@"Path"],@"Path",nil         ] ];
            NSArray* anItemArray = [NSArray arrayWithObject: resultItem ];
			//TODO:
            [self addItems: anItemArray];//TODO: this will silently add a item to the channel list: do we want to allow this? NO (to my opinion) -tb-
			//TODO:
            topLevelDictionary = [requestCache objectForKey:itemKey];
            #if 0
			topLevelDictionary = [self makeTopLevelDictionary];
			[requestCache setObject:topLevelDictionary forKey:itemKey];
            //TODO: insert it into the pollingLookUp and channelLookup (using the first free chan - if no chan numbers available? NSLog ...) -tb-
            chan = [self nextUnusedChannelNumber];
            [self setChannelNumber:chan forItemKey:itemKey];
            //adding to polling and channel cache was missing ...
            #endif
		}
        
        //maybe the item is in the requestCache but not in pollingLookup
        chan = [self channelNumberForItemKey:itemKey];
        if(chan<0){
            [self setChannelNumber:[self nextUnusedChannelNumber] forItemKey:itemKey];
            [self addItemKeyToPollingLookup: itemKey];
        }
        
		//we only replace the resultItem. leaving the other things in the dictionary (i.e. loAlarm, etc...) alone.
		[topLevelDictionary setObject:resultItem forKey:itemKey];
        	        //DEBUG          NSLog(@"%@::%@   topLevelDictionary AFTER SETTING RESULT ITEM:  >>>%@<<<\n", NSStringFromClass([self class]), NSStringFromSelector(_cmd),topLevelDictionary);//DEBUG OUTPUT -tb-


//TODO: check if 'value, Value, timestamp, Date' are present at all -tb- 2013-05
        if([self isControlItemWithItemKey:itemKey]){
            [topLevelDictionary setObject:[resultItem objectForKey:@"value"] forKey:@"DBValue"];
            [topLevelDictionary setObject:[resultItem objectForKey:@"timestamp"] forKey:@"DBTimestamp"];
        }
		else{
            [topLevelDictionary setObject:[resultItem objectForKey:@"Value"] forKey:@"DBValue"];
            [topLevelDictionary setObject:[resultItem objectForKey:@"Date"] forKey:@"DBTimestamp"];//TODO: use Unix time -tb- ? !!!!!!!!!!!!!
            //TODO: use Unix time -tb- ? !!!!!!!!!!!!!
            //TODO: use Unix time -tb- ? !!!!!!!!!!!!!
        }
        if([resultItem objectForKey:@"Result"])[topLevelDictionary setObject:[resultItem objectForKey:@"Result"] forKey:@"Result"];//added if(...) to check existence of "Result"; sensor and control reads are not foreseen to return the "Result" key, but this caused a exception and skipped "clearPendingRequest" -tb-
        if([resultItem objectForKey:@"Error"])[topLevelDictionary setObject:[resultItem objectForKey:@"Error"] forKey:@"Error"];

        //housekeeping
		[self clearPendingRequest:itemKey];
	}
    [[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSlowControlItemListChanged object:self];
}

- (void) handleSilentItemResult:(id)result path:(NSString*)aPath
{
	//just remove from pending list and check for errors
    //NSLog(@"handleSilentItemResult: ... result is %@ \n",result);//DEBUG OUTPUT -tb-
    //NSLog(@"handleSilentItemResult: ... aPath is %@ \n",aPath);//DEBUG OUTPUT -tb-
	{
		NSMutableDictionary* dictionary = [result objectAtIndex:0];
		NSString* itemKey = [self itemKey:[dictionary objectForKey:@"URL"] path:[dictionary objectForKey:@"Path"]];
		//NSLog(@"handleSilentItemResult: ... itemKey is %@ \n",itemKey);//DEBUG OUTPUT -tb-
        int queueErrorIndex = -23;
        
        //ERROR handling for queues
        NSNumber * num= [dictionary objectForKey:@"queueErrorIndex"] ;
        if(num){
            queueErrorIndex=[num intValue];
		    //DEBUG NSLog(@"handleSilentItemResult: ... queueErrorIndex is %i \n",queueErrorIndex);//DEBUG OUTPUT -tb-
            if([self showDebugOutput])
		        //DEBUG 
                NSLog(@"handleSilentItemResult: ... result is %@ \n",result);//DEBUG OUTPUT -tb-
            NSString* errorObj  = [dictionary objectForKey:@"Error"];
            NSString* resultObj  = [dictionary objectForKey:@"Result"];
            int isError = 0;
            int tmp=[resultObj caseInsensitiveCompare:@"Error"];//note: caseInsensitiveCompare: returns a 'NSComparisonResult' which may be -1, 0 or 1 ({NSOrderedAscending = -1, NSOrderedSame, NSOrderedDescending})-tb-
            //DEBUG  NSLog(@"%@::%@   result is >>>%@<<< comparison is:(%i) ((NSOrderedAscending is %i))\n", NSStringFromClass([self class]), NSStringFromSelector(_cmd),result,tmp,NSOrderedAscending);//DEBUG OUTPUT -tb-
            if(tmp!=NSOrderedDescending){//== @"Error"  found 
                isError=1;
                if([self showDebugOutput])
		            NSLog(@"handleSilentItemResult: ... ERROR with string: %@ \n",errorObj);//DEBUG OUTPUT -tb-
                [self setQueueError:1 forIndex: queueErrorIndex];
            }
            if([self queueErrorForIndex:queueErrorIndex] == -1) [self setQueueError:0 forIndex: queueErrorIndex];
        }


        //if(!itemKey) continue; //avoid (null) item key; this may happen if there was a alarm message in the received xml structure (contains no path/url) -tb-
        
        //housekeeping
		[self clearPendingRequest:itemKey];
	}
    //[[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSlowControlItemListChanged object:self];
}

- (void) clearPendingRequest:(NSString*) anItemKey
{
	NSTimeInterval t = [NSDate timeIntervalSinceReferenceDate];
	int deltaTime = (t - [[pendingRequests objectForKey:anItemKey] doubleValue])*1000;
	[self histogram:deltaTime];
	[pendingRequests removeObjectForKey:anItemKey];
    [[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSlowControlPendingRequestsChanged object:self];
	if([pendingRequests count]==0){
		[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(checkForTimeOuts) object:nil];
		checkingForTimeouts = NO;
	}
}

- (void) setPendingRequest:(NSString*)anItemKey
{
	if(!pendingRequests)pendingRequests = [[NSMutableDictionary dictionary] retain];
	[pendingRequests setObject:[NSNumber numberWithDouble:[NSDate timeIntervalSinceReferenceDate]] forKey:anItemKey];
    [[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSlowControlPendingRequestsChanged object:self];
	if(!checkingForTimeouts){
		[self performSelector:@selector(checkForTimeOuts) withObject:nil afterDelay:10]; //delay should be parameter
		checkingForTimeouts = YES;
	}
}


- (void) checkForTimeOuts
{
    int timeoutTime = 15;
	[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(checkForTimeOuts) object:nil];
	NSTimeInterval theCurrentTime = [NSDate timeIntervalSinceReferenceDate];
	if([pendingRequests count] == 0) return; 
	NSArray* theKeys = [pendingRequests allKeys];
	for(id anItemKey in theKeys){
		//it's a dictionary with one key -- the itemKey that holds the time the request was posted
		NSTimeInterval timePosted = [[pendingRequests objectForKey:anItemKey] doubleValue];
		if(theCurrentTime - timePosted > timeoutTime){
			NSLog(@"timeout on %@ (currentTime %f, timePosted %f)\n", anItemKey ,theCurrentTime ,timePosted);
			[self setTimeOutCount:[self timeOutCount]+1];
			[self clearPendingRequest:anItemKey];
		}
	}
	[self performSelector:@selector(checkForTimeOuts) withObject:nil afterDelay:10]; //delay should be parameter

}

- (void) shipTheRecords
{
	union {
		float asFloat;
		unsigned long asLong;
	}dataUnion;
	
	if([pollingLookUp count]){
		if([[ORGlobal sharedGlobal] runInProgress]){
			NSMutableData* theData = [NSMutableData dataWithCapacity:256]; //not a hard limit, just a hint to the data obj
			for(id anItemKey in pollingLookUp){
				NSDictionary* topLevelDictionary	= [requestCache objectForKey:anItemKey];
				NSDictionary* itemDictionary		= [topLevelDictionary objectForKey:anItemKey];
				float theValue;
                #if 0
				if([itemDictionary objectForKey:@"Control"]) theValue =  [[itemDictionary objectForKey:@"value"] floatValue];
				else										 theValue =  [[itemDictionary objectForKey:@"Value"] floatValue];
                #else
                theValue = [self valueForItemKey: anItemKey];
                #endif
				int channelNumber = [[topLevelDictionary objectForKey:@"ChannelNumber"] intValue];
                if(channelNumber ==-1) channelNumber = 0xff;//removed channels have channelNumber -1
                
				NSTimeInterval theTimeStamp =  [self timeFromADEIDate:[itemDictionary objectForKey:@"Date"]];//TODO: controls have no "Date" -tb-
				unsigned long seconds	 = (unsigned long)theTimeStamp;	  //seconds since 1970
				unsigned long subseconds = (theTimeStamp - seconds)*1000; //milliseconds
				
				unsigned long data[7];
				data[0] = channelDataId | 7;
				data[1] = (([self uniqueIdNumber]&0xf) << 21) | (channelNumber&0xff);
							
				dataUnion.asFloat = theValue;
				data[2] = dataUnion.asLong;
				data[3] = seconds; 
				data[4] = subseconds;
				data[5] = 0; //spare
				data[6] = 0; //spare
				
				[theData appendBytes:data length:7*sizeof(unsigned long)];
			}
			[[NSNotificationCenter defaultCenter] postNotificationName:ORQueueRecordForShippingNotification object:theData];
		}
	}
} 

- (NSTimeInterval) timeFromADEIDate:(NSString*)aDate
{
	NSDate *theDate = [NSDate dateFromString:aDate calendarFormat:@"%d-%b-%y %H:%M:%S.%F"];
	return [theDate timeIntervalSince1970];
}

//TODO: is this only for undo? who sets channel number? it is called only from addItems: and polledItemResult: -tb-
- (void) addItemKeyToPollingLookup:(NSString *)anItemKey
{
	//NSLog(@"Called: %@::%@\n",NSStringFromClass([self class]),NSStringFromSelector(_cmd));//TODO: debug output -tb-
    [[[self undoManager] prepareWithInvocationTarget:self] removeItemKeyFromPollingLookup:anItemKey];

    //WARNING: if pollingLookUp does not exist channel list handlich won't work! -tb- 
	if(!pollingLookUp)  pollingLookUp = [[NSMutableArray array] retain];

	[pollingLookUp addObject:anItemKey];

    //TODO: restore the old channel ...
	[self makeChannelLookup];
	[self sortPollingItems];
	[[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSlowControlItemListChanged object:self];
}

//! Remove it from pollingLookup (and channelLookup) but keep it in requestCache ...
// In topLevelDictionary of requestCache set ChannelNumber to -1 => it won't appear in the GUI any more;
// purpose: for undo: just restore the channel number
- (void) removeItemKeyFromPollingLookup:(NSString *)anItemKey
{
    [[[self undoManager] prepareWithInvocationTarget:self] addItemKeyToPollingLookup:anItemKey];
    int aChan = [self channelNumberForItemKey: anItemKey];
    [[[self undoManager] prepareWithInvocationTarget:self] setChannelNumber:aChan forItemKey:anItemKey];
    //TODO: set ChannelNumber to -1 and do a undo for it ... -tb-
        NSMutableDictionary* topLevelDictionary = [requestCache objectForKey: anItemKey];
        [topLevelDictionary setObject:[NSNumber numberWithInt:-1]	forKey:@"ChannelNumber"]; //channel number for access by the processing system
//TODO: [self setChannelNumber:-1 forItemKey:  anItemKey];     
	[pollingLookUp removeObject:anItemKey];
	[self makeChannelLookup];
	[self sortPollingItems];
	[[NSNotificationCenter defaultCenter] postNotificationName:ORIpeSlowControlItemListChanged object:self];
}

- (void) sortPollingItems
{
	if([pollingLookUp count]<=2)return;
	BOOL swapped;
	do {
		swapped = NO;
		int i;
		for(i=0;i<[pollingLookUp count] - 1; i++){
			NSDictionary* topLevelDictionary = [requestCache objectForKey:[pollingLookUp objectAtIndex:i]];
			int thisOne = [[topLevelDictionary objectForKey:@"ChannelNumber"] intValue];
			topLevelDictionary = [requestCache objectForKey:[pollingLookUp objectAtIndex:i+1]];
			int thatOne = [[topLevelDictionary objectForKey:@"ChannelNumber"] intValue];
			if (thisOne > thatOne) {
				[pollingLookUp exchangeObjectAtIndex:i withObjectAtIndex:i+1];
				swapped = YES;
			}
		}
	} while (swapped);
}

@end



//from http://www.macresearch.org/cocoa-scientists-part-xxvi-parsing-csv-data
//NSString category to read a CSV table from a given string and convert it to a array of arrays
//-tb- 2011-12-15

@implementation NSString (ParsingExtensions)

-(NSArray *)csvRows {
    NSMutableArray *rows = [NSMutableArray array];

    // Get newline character set
    NSMutableCharacterSet *newlineCharacterSet = (id)[NSMutableCharacterSet whitespaceAndNewlineCharacterSet];
    [newlineCharacterSet formIntersectionWithCharacterSet:[[NSCharacterSet whitespaceCharacterSet] invertedSet]];

    // Characters that are important to the parser
    NSMutableCharacterSet *importantCharactersSet = (id)[NSMutableCharacterSet characterSetWithCharactersInString:@",\""];
    [importantCharactersSet formUnionWithCharacterSet:newlineCharacterSet];

    // Create scanner, and scan string
    NSScanner *scanner = [NSScanner scannerWithString:self];
    [scanner setCharactersToBeSkipped:nil];
    while ( ![scanner isAtEnd] ) {        
        BOOL insideQuotes = NO;
        BOOL finishedRow = NO;
        NSMutableArray *columns = [NSMutableArray arrayWithCapacity:10];
        NSMutableString *currentColumn = [NSMutableString string];
        while ( !finishedRow ) {
            NSString *tempString;
            if ( [scanner scanUpToCharactersFromSet:importantCharactersSet intoString:&tempString] ) {
                [currentColumn appendString:tempString];
            }

            if ( [scanner isAtEnd] ) {
                if ( ![currentColumn isEqualToString:@""] ) [columns addObject:currentColumn];
                finishedRow = YES;
            }
            else if ( [scanner scanCharactersFromSet:newlineCharacterSet intoString:&tempString] ) {
                if ( insideQuotes ) {
                    // Add line break to column text
                    [currentColumn appendString:tempString];
                }
                else {
                    // End of row
                    if ( ![currentColumn isEqualToString:@""] ) [columns addObject:currentColumn];
                    finishedRow = YES;
                }
            }
            else if ( [scanner scanString:@"\"" intoString:NULL] ) {
                if ( insideQuotes && [scanner scanString:@"\"" intoString:NULL] ) {
                    // Replace double quotes with a single quote in the column string.
                    [currentColumn appendString:@"\""]; 
                }
                else {
                    // Start or end of a quoted string.
                    insideQuotes = !insideQuotes;
                }
            }
            else if ( [scanner scanString:@"," intoString:NULL] ) {  
                if ( insideQuotes ) {
                    [currentColumn appendString:@","];
                }
                else {
                    // This is a column separating comma
                    [columns addObject:currentColumn];
                    currentColumn = [NSMutableString string];
                    [scanner scanCharactersFromSet:[NSCharacterSet whitespaceCharacterSet] intoString:NULL];
                }
            }
        }
        if ( [columns count] > 0 ) [rows addObject:columns];
    }

    return rows;
}

@end
