//--------------------------------------------------------
// ORCaen1190Model
// Created by Mark  A. Howe on Mon May 19 2008
// Code partially generated by the OrcaCodeWizard. Written by Mark A. Howe.
// Copyright (c) 2008 CENPA, University of Washington. All rights reserved.
//-----------------------------------------------------------
//This program was prepared for the Regents of the University of 
//Washington at the Center for Experimental Nuclear Physics and 
//Astrophysics (CENPA) sponsored in part by the United States 
//Department of Energy (DOE) under Grant #DE-FG02-97ER41020. 
//The University has certain rights in the program pursuant to 
//the contract and the program should not be copied or distributed 
//outside your organization.  The DOE and the University of 
//Washington reserve all rights in the program. Neither the authors,
//University of Washington, or U.S. Government make any warranty, 
//express or implied, or assume any liability or responsibility 
//for the use of this software.
//-------------------------------------------------------------
#import "ORCaen1190Model.h"
#import "ORHWWizParam.h"
#import "ORRateGroup.h"

// Address information for this unit.
#define k1190DefaultBaseAddress 		0xa00000
#define k1190DefaultAddressModifier 	0x39

// Define all the registers available to this unit.
static RegisterNamesStruct reg[kNumRegisters] = {
{@"Output Buffer",      true,	true, 	true,	0x0000,		kReadOnly,	kD32}, //0
{@"Control Register",	false,  true, 	true,	0x1000,		kReadWrite,	kD16}, //1
{@"Status Register",	false,	false, 	false,	0x1002,		kReadOnly,	kD16}, //2
{@"Interrupt Level",	false,	false, 	true,	0x100A,		kReadWrite,	kD16}, //3
{@"Interrupt Vector",	false,	false, 	true,	0x100C,		kReadWrite,	kD16}, //4
{@"Geo Address",		false,	false, 	true,	0x100E,		kReadWrite,	kD16}, //5
{@"MCST Base Address",  false,	false, 	true,	0x1010,		kReadWrite,	kD16}, //6
{@"MCST Control",		false,	false, 	true,	0x1012,		kReadWrite,	kD16}, //7
{@"Module Reset",		false,	false, 	false,	0x1014,		kWriteOnly,	kD16}, //8
{@"Software Clear",		false,	false, 	false,	0x1016,		kWriteOnly,	kD16}, //9
{@"Software Event Reset",false,	false, 	false,	0x1018,		kWriteOnly,	kD16}, //10
{@"Software Trigger",	false,	false, 	false,	0x101A,		kWriteOnly,	kD16}, //11
{@"Event Counter",		true,	true, 	true,	0x101C,		kReadOnly,	kD32}, //12
{@"Event Stored",		true,	true, 	true,	0x1020,		kReadOnly,	kD16}, //13
{@"Almost Full Level",	false,	true, 	true,	0x1022,		kReadWrite,	kD16}, //14
{@"BLT Event Number",	false,	true, 	true,	0x1024,		kReadWrite,	kD16}, //15
{@"Firmware Revision",	false,	true, 	false,	0x1026,		kReadOnly,	kD16}, //16
{@"TestReg",			false,	true, 	true,	0x1028,		kReadWrite,	kD32}, //17
{@"Output Prog Control",false,	true, 	true,	0x102C,		kReadWrite,	kD16}, //18
{@"Micro",				false,	false, 	false,	0x102E,		kReadWrite,	kD16}, //18
{@"Micro Handshake",	false,	false, 	false,	0x1030,		kReadWrite,	kD16}, //18
{@"Event FIFO",			true,	true, 	true,	0x1038,		kReadWrite,	kD16}, //18
{@"Event FIFO Stored",	true,	true, 	true,	0x103C,		kReadWrite,	kD16}, //18
{@"Event FIFO Status",	false,	false, 	false,	0x103E,		kReadWrite,	kD16}, //18
{@"Dummy 32",			false,	true, 	true,	0x1200,		kReadWrite,	kD32}, //21
{@"Dummy 16",			false,	true, 	true,	0x1204,		kReadOnly,	kD16}  //22
};

NSString* ORCaen1190DeadTimeChanged					= @"ORCaen1190DeadTimeChanged";
NSString* ORCaen1190LeadingWidthResolutionChanged	= @"ORCaen1190LeadingWidthResolutionChanged";
NSString* ORCaen1190LeadingTimeResolutionChanged	= @"ORCaen1190LeadingTimeResolutionChanged";
NSString* ORCaen1190LeadingTrailingLSBChanged		= @"ORCaen1190LeadingTrailingLSBChanged";
NSString* ORCaen1190EdgeDetectionChanged			= @"ORCaen1190EdgeDetectionChanged";
NSString* ORCaen1190EnableTrigTimeSubChanged		= @"ORCaen1190EnableTrigTimeSubChanged";
NSString* ORCaen1190RejectMarginChanged				= @"ORCaen1190RejectMarginChanged";
NSString* ORCaen1190SearchMarginChanged				= @"ORCaen1190SearchMarginChanged";
NSString* ORCaen1190WindowOffsetChanged				= @"ORCaen1190WindowOffsetChanged";
NSString* ORCaen1190WindowWidthChanged				= @"ORCaen1190WindowWidthChanged";
NSString* ORCaen1190AcqModeChanged					= @"ORCaen1190AcqModeChanged";
NSString* ORCaen1190ParamGroupChanged				= @"ORCaen1190ParamGroupChanged";
NSString* ORCaen1190EnabledChanged					= @"ORCaen1190EnabledChanged";
NSString* ORCaen1190RateGroupChangedNotification    = @"ORCaen1190RateGroupChangedNotification";

@implementation ORCaen1190Model

#pragma mark ***Initialization
- (id) init
{
    self = [super init];
    [[self undoManager] disableUndoRegistration];
	
    [self setBaseAddress:k1190DefaultBaseAddress];
    [self setAddressModifier:k1190DefaultAddressModifier];
	[self setTdcRateGroup:[[[ORRateGroup alloc] initGroup:128 groupTag:0] autorelease]];
	[tdcRateGroup setIntegrationTime:5];
	
    [[self undoManager] enableUndoRegistration];
	
    return self;
}

- (void) dealloc
{
    [tdcRateGroup quit];
    [tdcRateGroup release];
	[aTimer release];
	[super dealloc];
}

- (NSRange)	memoryFootprint
{
	return NSMakeRange(baseAddress,0x1204);
}

- (NSString*) helpURL
{
	return @"VME/V1190.html";
}

#pragma mark ***Accessors
- (void) setIntegrationTime:(double)newIntegrationTime
{
	//we this here so we have undo/redo on the rate object.
    [[[self undoManager] prepareWithInvocationTarget:self] setIntegrationTime:[tdcRateGroup integrationTime]];
	[tdcRateGroup setIntegrationTime:newIntegrationTime];
}

- (id) rateObject:(int)channel
{
	return [tdcRateGroup rateObject:channel];
}

- (ORRateGroup*) tdcRateGroup
{
	return tdcRateGroup;
}

- (void) setTdcRateGroup:(ORRateGroup*)newTdcRateGroup
{
	[newTdcRateGroup retain];
	[tdcRateGroup release];
	tdcRateGroup = newTdcRateGroup;
	
    [[NSNotificationCenter defaultCenter]
	 postNotificationName:ORCaen1190RateGroupChangedNotification
	 object:self];    
}

- (int) deadTime
{
    return deadTime;
}

- (void) setDeadTime:(int)aDeadTime
{
    [[[self undoManager] prepareWithInvocationTarget:self] setDeadTime:deadTime];
    
    deadTime = aDeadTime;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORCaen1190DeadTimeChanged object:self];
}

- (int) leadingWidthResolution
{
    return leadingWidthResolution;
}

- (void) setLeadingWidthResolution:(int)aLeadingWidthResolution
{
    [[[self undoManager] prepareWithInvocationTarget:self] setLeadingWidthResolution:leadingWidthResolution];
    
    leadingWidthResolution = aLeadingWidthResolution;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORCaen1190LeadingWidthResolutionChanged object:self];
}

- (int) leadingTimeResolution
{
    return leadingTimeResolution;
}

- (void) setLeadingTimeResolution:(int)aLeadingTimeResolution
{
    [[[self undoManager] prepareWithInvocationTarget:self] setLeadingTimeResolution:leadingTimeResolution];
    
    leadingTimeResolution = aLeadingTimeResolution;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORCaen1190LeadingTimeResolutionChanged object:self];
}

- (int) leadingTrailingLSB
{
    return leadingTrailingLSB;
}

- (void) setLeadingTrailingLSB:(int)aLeadingTrailingLSB
{
    [[[self undoManager] prepareWithInvocationTarget:self] setLeadingTrailingLSB:leadingTrailingLSB];
    
    leadingTrailingLSB = aLeadingTrailingLSB;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORCaen1190LeadingTrailingLSBChanged object:self];
}

- (int) edgeDetection
{
    return edgeDetection;
}

- (void) setEdgeDetection:(int)aEdgeDetection
{
    [[[self undoManager] prepareWithInvocationTarget:self] setEdgeDetection:edgeDetection];
    
    edgeDetection = aEdgeDetection;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORCaen1190EdgeDetectionChanged object:self];
}

- (BOOL) enableTrigTimeSub { return enableTrigTimeSub; }

- (void) setEnableTrigTimeSub:(BOOL)aEnableTrigTimeSub
{
    [[[self undoManager] prepareWithInvocationTarget:self] setEnableTrigTimeSub:enableTrigTimeSub];
    
    enableTrigTimeSub = aEnableTrigTimeSub;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORCaen1190EnableTrigTimeSubChanged object:self];
}

- (int) rejectMargin { return rejectMargin; }

- (void) setRejectMargin:(int)aRejectMargin
{
    [[[self undoManager] prepareWithInvocationTarget:self] setRejectMargin:rejectMargin];
	
	if(aRejectMargin < 0)aRejectMargin = 0;
	else if(aRejectMargin>0xfff)aRejectMargin = 0xfff;
	
    rejectMargin = aRejectMargin;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORCaen1190RejectMarginChanged object:self];
}

- (int) searchMargin { return searchMargin; }

- (void) setSearchMargin:(int)aSearchMargin
{
    [[[self undoManager] prepareWithInvocationTarget:self] setSearchMargin:searchMargin];
	
    if(aSearchMargin < 0)aSearchMargin = 0;
	else if(aSearchMargin>0xfff)aSearchMargin = 0xfff;
    
    searchMargin = aSearchMargin;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORCaen1190SearchMarginChanged object:self];
}

- (short) windowOffset { return windowOffset; }

- (void) setWindowOffset:(short)aWindowOffset
{
    [[[self undoManager] prepareWithInvocationTarget:self] setWindowOffset:windowOffset];
	
    if(aWindowOffset < -2048)aWindowOffset = -2048;
	else if(aWindowOffset>40)aWindowOffset = 40;
    
    windowOffset = aWindowOffset;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORCaen1190WindowOffsetChanged object:self];
}

- (int) windowWidth { return windowWidth; }

- (void) setWindowWidth:(int)aWindowWidth
{
    [[[self undoManager] prepareWithInvocationTarget:self] setWindowWidth:windowWidth];
	
    if(aWindowWidth<0)aWindowWidth = 0;
	else if(aWindowWidth>0xfff)aWindowWidth = 0xfff;
	
    windowWidth = aWindowWidth;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORCaen1190WindowWidthChanged object:self];
}

- (int) acqMode { return acqMode; }

- (void) setAcqMode:(int)aAcqMode
{
    [[[self undoManager] prepareWithInvocationTarget:self] setAcqMode:acqMode];
    
    acqMode = aAcqMode;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORCaen1190AcqModeChanged object:self];
}

- (int) paramGroup { return paramGroup; }

- (void) setParamGroup:(int)aGroup
{
	if(aGroup<0)aGroup = 3;
	else if(aGroup > 3)aGroup = 0;
	
    [[[self undoManager] prepareWithInvocationTarget:self] setParamGroup:paramGroup];
    
    paramGroup = aGroup;
	
    [[NSNotificationCenter defaultCenter] postNotificationName:ORCaen1190ParamGroupChanged object:self];
}

- (void) setUpImage         { [self setImage:[NSImage imageNamed:@"C1190"]]; }
- (void) makeMainController { [self linkToController:@"ORCaen1190Controller"]; }


- (unsigned long)	enabledMask:(int) n { return enabledMask[n]; }

- (void) setEnabledMask:(int)n withValue:(unsigned long)aMask
{
	[[[self undoManager] prepareWithInvocationTarget:self] setEnabledMask:n withValue:enabledMask[n]];
    enabledMask[n] = aMask;
    [[NSNotificationCenter defaultCenter]
	 postNotificationName:ORCaen1190EnabledChanged
	 object:self];
	
}


#pragma mark ***Register - General routines
- (short)          getNumberRegisters	{ return kNumRegisters; }
- (unsigned long)  getBufferOffset		{ return reg[kOutputBuffer].addressOffset; }
- (unsigned short) getDataBufferSize	{ return kADCOutputBufferSize; }
- (short)          getOutputBufferIndex	{ return(kOutputBuffer); }

#pragma mark ***Register - Register specific routines
- (NSString*)     getRegisterName:(short) anIndex	{ return reg[anIndex].regName; }
- (unsigned long) getAddressOffset:(short) anIndex	{ return(reg[anIndex].addressOffset); }
- (short)		  getAccessType:(short) anIndex		{ return reg[anIndex].accessType; }
- (short)         getAccessSize:(short) anIndex		{ return reg[anIndex].size; }
- (BOOL)          dataReset:(short) anIndex			{ return reg[anIndex].dataReset; }
- (BOOL)          swReset:(short) anIndex			{ return reg[anIndex].softwareReset; }
- (BOOL)          hwReset:(short) anIndex			{ return reg[anIndex].hwReset; }

- (NSString*) identifier
{
    return [NSString stringWithFormat:@"CAEN 1190 (Slot %d) ",[self slot]];
}

#pragma mark ***HW Access

- (BOOL) writeMicroOp:(short) aCode
{
	//make sure the Write-OK bit is set
	unsigned short theWord = 0;
	if(!aTimer){
		aTimer = [[ORTimer alloc] init];
		[aTimer start];
	}
	[aTimer reset];
	int tries = 0;
	while(1){
		[self read:kMicroHandShake returnValue:&theWord];
		tries++;
		if(theWord & 0x1){
			[self write:kMicro sendValue: aCode];
			return YES;
		}
		else {
			if([aTimer microseconds] > 1000 && tries >= 3){
				//try at least 3 times over a max of 1 mSec, then give up
				break;
			}
		}
	}
	return NO;
}

- (void) writeMicroData:(short) data
{
	[self write:kMicro sendValue: data];
}

- (void) loadEnableMasks
{
	if([self writeMicroOp:0x4400]){
		int i;
		for(i=0;i<4;i++){
			[self writeMicroData:enabledMask[i] & 0x0000FFFF];
			[self writeMicroData:(enabledMask[i] & 0xFFFF0000)>>16];
		}
	}
}

- (void) loadDefaults
{
	[self setAcqMode:1];				// continous storage
	[self setWindowWidth:0x14];			// 500 ns
	[self setWindowOffset:-40];			// -1us
	[self setRejectMargin:0x4];			// 100ns
	[self setEnabledMask:0 withValue:0xFFFFFFFF];
	[self setEnabledMask:1 withValue:0xFFFFFFFF];
	[self setEnabledMask:2 withValue:0xFFFFFFFF];
	[self setEnabledMask:3 withValue:0xFFFFFFFF];
	[self writeMicroOp:0x0500];
}
- (void) loadTriggerMatch		{ [self writeMicroOp: acqMode?0x0000:0x0100];}
- (void) loadWindowWidth		{ [self writeMicroOp: 0x1000]; [self writeMicroData:windowWidth  & 0xfff];}
- (void) loadWindowOffset		{ [self writeMicroOp: 0x1100]; [self writeMicroData:windowOffset & 0xfff];}
- (void) loadSearchMargin		{ [self writeMicroOp: 0x1200]; [self writeMicroData:searchMargin & 0xfff]; }
- (void) loadRejectMargin		{ [self writeMicroOp: 0x1300]; [self writeMicroData:rejectMargin & 0xfff]; }
- (void) loadEnableTrigTimeSub	{ [self writeMicroOp: enableTrigTimeSub?0x1400:0x1500]; }
- (void) loadEdgeDetection		{ [self writeMicroOp: 0x2200]; [self writeMicroData:edgeDetection & 0x3];}
- (void) loadEdgeLSB			{ [self writeMicroOp: 0x2200]; [self writeMicroData:leadingTrailingLSB & 0x3];}
- (void) loadDeadTime			{ [self writeMicroOp: 0x2900]; [self writeMicroData:deadTime & 0x3];}
- (void) loadLeadingTimeWidthResolutions
{
	//only send if in pair mode (0)
	if(edgeDetection == 0) {
		[self writeMicroOp: 0x2500]; 
		[self writeMicroData:(leadingWidthResolution<<8 & leadingTimeResolution) & 0xfff];
	}
}

- (void) initBoard
{
	[self write:kSoftwareClr sendValue:0];
	[self write:kControlRegister sendValue:0x0100]; //enable Event FIFO
	[self loadEnableMasks];
	[self loadTriggerMatch];
	[self loadWindowWidth];
	[self loadWindowOffset];
	[self loadSearchMargin];
	[self loadRejectMargin];
	[self loadEnableTrigTimeSub];
	[self loadEdgeDetection];
	[self loadEdgeLSB];
	[self loadDeadTime];
	[self loadLeadingTimeWidthResolutions];
}

#pragma mark •••Rates
- (unsigned long) getCounter:(int)counterTag forGroup:(int)groupTag
{
	if(groupTag == 0){
		if(counterTag>=0 && counterTag<128){
			return tdcCount[counterTag];
		}	
		else return 0;
	}
	else return 0;
}

- (BOOL) bumpRateFromDecodeStage:(short)channel
{
	if(isRunning)return NO;
    
    ++tdcCount[channel];
    return YES;
}

- (unsigned long) tdcCount:(int)aChannel
{
    return tdcCount[aChannel];
}

-(void) startRates
{
	[self clearTdcCounts];
    [tdcRateGroup start:self];
}

- (void) clearTdcCounts
{
    int i;
    for(i=0;i<128;i++){
		tdcCount[i]=0;
    }
}

- (NSDictionary*) dataRecordDescription
{
    NSMutableDictionary* dataDictionary = [NSMutableDictionary dictionary];
    NSDictionary* aDictionary = [NSDictionary dictionaryWithObjectsAndKeys:
								 @"ORCaen1190DecoderForTdc",			@"decoder",
								 [NSNumber numberWithLong:dataId],	@"dataId",
								 [NSNumber numberWithBool:YES],		@"variable",
								 [NSNumber numberWithLong:-1],		@"length",
								 nil];
    [dataDictionary setObject:aDictionary forKey:@"Caen1190"];
    
    return dataDictionary;
}


- (void) 	runTaskStarted:(ORDataPacket*) aDataPacket userInfo:(NSDictionary*)userInfo
{
    //if(![[self adapter] controllerCard]){
	// [NSException raise:@"Not Connected" format:@"You must connect to a PCI Controller (i.e. a 617)."];
    //}
    
    [self startRates];
	isRunning = NO;
	
    //----------------------------------------------------------------------------------------
    // first add our description to the data description
    [aDataPacket addDataDescriptionItem:[self dataRecordDescription] forKey:NSStringFromClass([self class])]; 
    
    //make buffer for data with extra room for our 2 long word header.
    dataBuffer   = (unsigned long*)malloc([self getDataBufferSize]+2*sizeof(unsigned long));
    controller   = [self adapter]; //cache for speed
	long detectiontype = [self edgeDetection];
	locationWord = (detectiontype << 25) | (([self crateNumber] & 0x0000000f)<<21) | (([self slot] & 0x0000001f)<<16);
	
	[self flushBuffer];
    [self initBoard];
}


//-------------------------------------------------------------------------------
//data format
//0000 0000 0000 0000 0000 0000 0000 0000
//^^^^ ^^^^ ^^^^ ^^---------------------- device type
//		           ^^ ^^^^ ^^^^ ^^^^ ^^^^ length of record including this header
//0000 0000 0000 0000 0000 0000 0000 0000
//^^^^-^--------------------------------- spare
//      ^^------------------------------- edge detection
//        ^ ^^^-------------------------- crate
//             ^ ^^^^-------------------- card
// n bytes of raw data follow.
//-------------------------------------------------------------------------------
- (void) takeData:(ORDataPacket*)aDataPacket userInfo:(NSDictionary*)userInfo;
{
    
    unsigned short 	theStatus;
 	isRunning = YES;
	
    @try {
        [self read:kStatusRegister returnValue:&theStatus];
		BOOL dataIsReady 	= theStatus & 0x0001;
		
		if(dataIsReady){
			//this seq could be improved by reading all the words in the fifo, then computing the total number of words in the buffer and reading them all
			unsigned long eventFIFO;
			[controller readLongBlock:&eventFIFO
							atAddress:baseAddress + reg[kEventFIFO].addressOffset
							numToRead:1
						   withAddMod:addressModifier
						usingAddSpace:0x01];
			
			int wordCount = eventFIFO & 0x0000ffff; 
			if(wordCount){
				
				dataBuffer[0] = dataId | (wordCount+2);
				dataBuffer[1] = locationWord;
				
				[controller readLongBlock: &dataBuffer[2]
								atAddress: baseAddress + reg[kOutputBuffer].addressOffset
								numToRead: wordCount
							   withAddMod: addressModifier
							usingAddSpace: 0x01];
				
				[aDataPacket addLongsToFrameBuffer:dataBuffer length:wordCount+2];
				
				//extract the chan info so the rates can be computed.
				int i;
				for(i=0;i<<wordCount;i++){
					if((dataBuffer[2+i] >> 27) == 0x00){
						short chan = (dataBuffer[2+i]>>19) & 0x7f;
						tdcCount[chan]++;
					}
				}
			}
		}
		
	}
	@catch(NSException* localException) {
		errorCount++;
	}
}

- (void) runTaskStopped:(ORDataPacket*) aDataPacket userInfo:(NSDictionary*)userInfo
{
    free (dataBuffer);
    dataBuffer = 0;
    controller = 0;
	
    [tdcRateGroup stop];
	isRunning = NO;
}

#pragma mark ***Archival

- (id) initWithCoder:(NSCoder*) aDecoder
{    
    self = [super initWithCoder:aDecoder];
    
    [[self undoManager] disableUndoRegistration];
	
    [self setDeadTime:				[aDecoder decodeIntForKey:@"deadTime"]];
    [self setLeadingWidthResolution:[aDecoder decodeIntForKey:@"leadingWidthResolution"]];
    [self setLeadingTimeResolution:	[aDecoder decodeIntForKey:@"leadingTimeResolution"]];
    [self setLeadingTrailingLSB:	[aDecoder decodeIntForKey:@"leadingTrailingLSB"]];
    [self setEnableTrigTimeSub:		[aDecoder decodeIntForKey:@"enableTrigTimeSub"]];
    [self setEdgeDetection:	[aDecoder decodeIntForKey:@"edgeDetection"]];
    [self setRejectMargin:	[aDecoder decodeIntForKey:@"rejectMargin"]];
    [self setSearchMargin:	[aDecoder decodeIntForKey:@"searchMargin"]];
    [self setWindowOffset:	[aDecoder decodeIntForKey:@"windowOffset"]];
    [self setWindowWidth:	[aDecoder decodeIntForKey:@"windowWidth"]];
	[self setParamGroup:	[aDecoder decodeIntForKey:@"paramGroup"]];
	[self setAcqMode:		[aDecoder decodeIntForKey:@"acqMode"]];
	[self setTdcRateGroup:  [aDecoder decodeObjectForKey:@"tdcRateGroup"]];
	
	int i;
    for (i = 0; i < 4; i++){
        [self setEnabledMask:i withValue:[aDecoder decodeInt32ForKey: [NSString stringWithFormat:@"enabledMask%d", i]]];
    }
	
	if(!tdcRateGroup){
		[self setTdcRateGroup:[[[ORRateGroup alloc] initGroup:128 groupTag:0] autorelease]];
	    [tdcRateGroup setIntegrationTime:5];
    }
    [self startRates];
    [tdcRateGroup resetRates];
    [tdcRateGroup calcRates];
	
    [[self undoManager] enableUndoRegistration];
    
    return self;
}

- (void) encodeWithCoder:(NSCoder*) anEncoder
{
    short i;
    
    [super encodeWithCoder:anEncoder];
	
    [anEncoder encodeInt:deadTime			forKey:@"deadTime"];
    [anEncoder encodeInt:leadingWidthResolution forKey:@"leadingWidthResolution"];
    [anEncoder encodeInt:leadingTimeResolution	forKey:@"leadingTimeResolution"];
    [anEncoder encodeInt:leadingTrailingLSB forKey:@"leadingTrailingLSB"];
    [anEncoder encodeInt:edgeDetection		forKey:@"edgeDetection"];
    [anEncoder encodeInt:paramGroup			forKey:@"paramGroup"];
    [anEncoder encodeInt:acqMode			forKey:@"acqMode"];
	[anEncoder encodeInt:enableTrigTimeSub	forKey:@"enableTrigTimeSub"];
	[anEncoder encodeInt:rejectMargin		forKey:@"rejectMargin"];
	[anEncoder encodeInt:searchMargin		forKey:@"searchMargin"];
	[anEncoder encodeInt:windowOffset		forKey:@"windowOffset"];
	[anEncoder encodeInt:windowWidth		forKey:@"windowWidth"];
    [anEncoder encodeObject:tdcRateGroup	forKey:@"tdcRateGroup"];
    for (i = 0; i < 4; i++){
        [anEncoder encodeInt32:enabledMask[i] forKey:[NSString stringWithFormat:@"enabledMask%d", i]];
    }
}

#pragma mark •••HW Wizard
- (int) numberOfChannels
{
    return 128;
}

- (NSArray*) wizardParameters
{
    NSMutableArray* a = [NSMutableArray array];
    ORHWWizParam* p;
    
	p = [[[ORHWWizParam alloc] init] autorelease];
	[p setUseValue:NO];
	[p setName:@"Init"];
	[p setSetMethodSelector:@selector(initBoard)];
	[a addObject:p];
    
    return a;
}

- (NSNumber*) extractParam:(NSString*)param from:(NSDictionary*)fileHeader forChannel:(int)aChannel
{
	return nil;
}

- (void) logThresholds
{
	//we don't have thresholds
}

- (NSMutableDictionary*) addParametersToDictionary:(NSMutableDictionary*)dictionary
{
    NSMutableDictionary* objDictionary = [NSMutableDictionary dictionary];
    [objDictionary setObject:NSStringFromClass([self class])		forKey:@"Class Name"];
    [objDictionary setObject:[NSNumber numberWithInt:[self slot]]	forKey:@"Card"];
    [objDictionary setObject:[NSNumber numberWithLong:baseAddress]	forKey:@"baseAddress"];
    [dictionary setObject:objDictionary forKey:[self identifier]];
    return objDictionary;
}

//this is the data structure for the new SBCs (i.e. VX704 from Concurrent)
- (int) load_HW_Config_Structure:(SBC_crate_config*)configStruct index:(int)index
{
	configStruct->total_cards++;
	configStruct->card_info[index].hw_type_id	= kCaen; //should be unique
	configStruct->card_info[index].hw_mask[0]	= dataId; //better be unique
	configStruct->card_info[index].slot			= [self slot];
	configStruct->card_info[index].crate		= [self crateNumber];
	configStruct->card_info[index].add_mod		= [self addressModifier];
	configStruct->card_info[index].base_add		= [self baseAddress];
	configStruct->card_info[index].deviceSpecificData[0] = reg[kStatusRegister].addressOffset;
	configStruct->card_info[index].num_Trigger_Indexes = 0;
	configStruct->card_info[index].next_Card_Index 	= index+1;	
	return index+1;
}

@end

